"use strict";(self.webpackChunkink_docs=self.webpackChunkink_docs||[]).push([[5754],{3905:(e,a,n)=>{n.d(a,{Zo:()=>p,kt:()=>k});var t=n(7294);function r(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function l(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,t)}return n}function i(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?l(Object(n),!0).forEach((function(a){r(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function o(e,a){if(null==e)return{};var n,t,r=function(e,a){if(null==e)return{};var n,t,r={},l=Object.keys(e);for(t=0;t<l.length;t++)n=l[t],a.indexOf(n)>=0||(r[n]=e[n]);return r}(e,a);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(t=0;t<l.length;t++)n=l[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=t.createContext({}),c=function(e){var a=t.useContext(s),n=a;return e&&(n="function"==typeof e?e(a):i(i({},a),e)),n},p=function(e){var a=c(e.components);return t.createElement(s.Provider,{value:a},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},m=t.forwardRef((function(e,a){var n=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=c(n),m=r,k=d["".concat(s,".").concat(m)]||d[m]||u[m]||l;return n?t.createElement(k,i(i({ref:a},p),{},{components:n})):t.createElement(k,i({ref:a},p))}));function k(e,a){var n=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=m;var o={};for(var s in a)hasOwnProperty.call(a,s)&&(o[s]=a[s]);o.originalType=e,o[d]="string"==typeof e?e:r,i[1]=o;for(var c=2;c<l;c++)i[c]=n[c];return t.createElement.apply(null,i)}return t.createElement.apply(null,n)}m.displayName="MDXCreateElement"},4361:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>l,metadata:()=>o,toc:()=>c});var t=n(7462),r=(n(7294),n(3905));const l={title:"ink! vs. Solidity",hide_title:!0,slug:"/ink-vs-solidity"},i=void 0,o={unversionedId:"intro/ink-vs-solidity",id:"intro/ink-vs-solidity",title:"ink! vs. Solidity",description:"La siguiente tabla muestra una breve comparaci\xf3n de caracter\xedsticas entre ink! y Solidity:",source:"@site/i18n/es/docusaurus-plugin-content-docs/current/intro/ink-vs-solidity.md",sourceDirName:"intro",slug:"/ink-vs-solidity",permalink:"/es/ink-vs-solidity",draft:!1,editUrl:"https://github.com/paritytech/ink-docs/edit/master/docs/intro/ink-vs-solidity.md",tags:[],version:"current",frontMatter:{title:"ink! vs. Solidity",hide_title:!0,slug:"/ink-vs-solidity"},sidebar:"reference",previous:{title:"C\xf3mo funciona \u2012 Substrate",permalink:"/es/como-funciona"},next:{title:"ink! vs. CosmWasm",permalink:"/es/ink-vs-cosmwasm"}},s={},c=[{value:"Gu\xeda Solidity a ink!",id:"gu\xeda-solidity-a-ink",level:2},{value:"Tabla de Contenidos",id:"tabla-de-contenidos",level:3},{value:"Convertir un contrato de Solidity a ink!",id:"convertir-un-contrato-de-solidity-a-ink",level:2},{value:"1. Generar un nuevo contrato de ink!",id:"1-generar-un-nuevo-contrato-de-ink",level:3},{value:"2. Compilar el contrato",id:"2-compilar-el-contrato",level:3},{value:"3. Convertir campos de clase de Solidity a Struct de Rust",id:"3-convertir-campos-de-clase-de-solidity-a-struct-de-rust",level:3},{value:"4. Convertir cada funci\xf3n",id:"4-convertir-cada-funci\xf3n",level:3},{value:"Mejores pr\xe1cticas + Tips",id:"mejores-pr\xe1cticas--tips",level:2},{value:"Equivalencias de sintaxis",id:"equivalencias-de-sintaxis",level:2},{value:"<code>funci\xf3n p\xfablica</code>",id:"funci\xf3n-p\xfablica",level:3},{value:"<code>declaraci\xf3n de mapping </code>",id:"declaraci\xf3n-de-mapping-",level:3},{value:"<code>uso de mapping</code>",id:"uso-de-mapping",level:3},{value:"<code>struct</code>",id:"struct",level:3},{value:"<code>assertions / requires</code>",id:"assertions--requires",level:3},{value:"<code>timestamp</code>",id:"timestamp",level:3},{value:"<code>caller del contrato</code>",id:"caller-del-contrato",level:3},{value:"<code>direcci\xf3n de contrato</code>",id:"direcci\xf3n-de-contrato",level:3},{value:"<code>bytes</code>",id:"bytes",level:3},{value:"<code>uint256</code>",id:"uint256",level:3},{value:"<code>payable</code>",id:"payable",level:3},{value:"<code>dep\xf3sito recibido / pago</code>",id:"dep\xf3sito-recibido--pago",level:3},{value:"<code>balance del contrato</code>",id:"balance-del-contrato",level:3},{value:"<code>transferir tokens desde el contrato</code>",id:"transferir-tokens-desde-el-contrato",level:3},{value:"<code>eventos e indexado</code>",id:"eventos-e-indexado",level:3},{value:"<code>errores y returns</code>",id:"errores-y-returns",level:3},{value:"<code>throw</code>",id:"throw",level:4},{value:"<code>assert</code>",id:"assert",level:4},{value:"<code>require y revert</code>",id:"require-y-revert",level:4},{value:"<code>mappings anidados + estructuras custom / avanzadas</code>",id:"mappings-anidados--estructuras-custom--avanzadas",level:3},{value:"<code>llamadas entre contratos</code>",id:"llamadas-entre-contratos",level:3},{value:"<code>enviar transacci\xf3n gen\xe9rica / llamadas din\xe1micas entre contratos</code>",id:"enviar-transacci\xf3n-gen\xe9rica--llamadas-din\xe1micas-entre-contratos",level:3},{value:"Limitaciones de ink! v3",id:"limitaciones-de-ink-v3",level:2},{value:"Soluci\xf3n de problemas y errores",id:"soluci\xf3n-de-problemas-y-errores",level:2},{value:"unit testing (off-chain)",id:"unit-testing-off-chain",level:2}],p={toc:c},d="wrapper";function u(e){let{components:a,...n}=e;return(0,r.kt)(d,(0,t.Z)({},p,n,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("img",{src:"/img/title/solidity.svg",className:"titlePic"}),(0,r.kt)("h1",{id:"ink-vs-solidity"},"ink! vs. Solidity"),(0,r.kt)("p",null,"La siguiente tabla muestra una breve comparaci\xf3n de caracter\xedsticas entre ink! y Solidity:"),(0,r.kt)("div",{class:"comparison"},(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"left"}),(0,r.kt)("th",{parentName:"tr",align:"left"},"ink!"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Solidity"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"M\xe1quina virtual"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Cualquier VM Wasm"),(0,r.kt)("td",{parentName:"tr",align:"left"},"EVM")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Codificaci\xf3n"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Wasm"),(0,r.kt)("td",{parentName:"tr",align:"left"},"EVM Byte Code")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Lenguaje"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Rust"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Standalone")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Protecci\xf3n contra desbordamiento"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Habilitado por default"),(0,r.kt)("td",{parentName:"tr",align:"left"},"S\xed")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Funciones de constructor"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Multiple"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Single")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Herramientas"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Cualquiera que soporte Rust"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Custom")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Versionado"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Sem\xe1ntico"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Sem\xe1ntico")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Contiene Metadata?"),(0,r.kt)("td",{parentName:"tr",align:"left"},"S\xed"),(0,r.kt)("td",{parentName:"tr",align:"left"},"S\xed")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Proyecto de archivos m\xfaltiples"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Planeado"),(0,r.kt)("td",{parentName:"tr",align:"left"},"S\xed")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Entradas de  Storage"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Variable"),(0,r.kt)("td",{parentName:"tr",align:"left"},"256 bits")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Tipos soportados"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Docs"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Docs")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Contiene Interfaces?"),(0,r.kt)("td",{parentName:"tr",align:"left"},"S\xed (Traits de Rust)"),(0,r.kt)("td",{parentName:"tr",align:"left"},"S\xed"))))),(0,r.kt)("h2",{id:"gu\xeda-solidity-a-ink"},"Gu\xeda Solidity a ink!"),(0,r.kt)("h3",{id:"tabla-de-contenidos"},"Tabla de Contenidos"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#ink-vs-solidity"},"ink! vs. Solidity"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#gu%C3%ADa-solidity-a-ink"},"Gu\xeda Solidity a ink!"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#tabla-de-contenidos"},"Tabla de Contenidos")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#convertir-un-contrato-de-solidity-a-ink"},"Convertir un contrato de Solidity a ink!"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#1-generar-un-nuevo-contrato-de-ink"},"1. Generar un nuevo contrato de ink!")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#2-compilar-el-contrato"},"2. Compilar el contrato")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#3-convertir-campos-de-clase-de-solidity-a-struct-de-rust"},"3. Convertir campos de clase de Solidity a Struct de Rust")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#4-convertir-cada-funci%C3%B3n"},"4. Convertir cada funci\xf3n")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#mejores-pr%C3%A1cticas--tips"},"Mejores pr\xe1cticas + Tips")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#equivalencias-de-sintaxis"},"Equivalencias de sintaxis"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#funci%C3%B3n-p%C3%BAblica"},(0,r.kt)("inlineCode",{parentName:"a"},"funci\xf3n p\xfablica"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#declaraci%C3%B3n-de-mapping-"},(0,r.kt)("inlineCode",{parentName:"a"},"declaraci\xf3n de mapping "))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#uso-de-mapping"},(0,r.kt)("inlineCode",{parentName:"a"},"uso de mapping"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#struct"},(0,r.kt)("inlineCode",{parentName:"a"},"struct"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#assertions--requires"},(0,r.kt)("inlineCode",{parentName:"a"},"assertions / requires"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#timestamp"},(0,r.kt)("inlineCode",{parentName:"a"},"timestamp"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#caller-del-contrato"},(0,r.kt)("inlineCode",{parentName:"a"},"caller del contrato"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#direcci%C3%B3n-de-contrato"},(0,r.kt)("inlineCode",{parentName:"a"},"direcci\xf3n de contrato"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#bytes"},(0,r.kt)("inlineCode",{parentName:"a"},"bytes"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#uint256"},(0,r.kt)("inlineCode",{parentName:"a"},"uint256"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#payable"},(0,r.kt)("inlineCode",{parentName:"a"},"payable"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#dep%C3%B3sito-recibido--pago"},(0,r.kt)("inlineCode",{parentName:"a"},"dep\xf3sito recibido / pago"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#balance-del-contrato"},(0,r.kt)("inlineCode",{parentName:"a"},"balance del contrato"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#transferir-tokens-desde-el-contrato"},(0,r.kt)("inlineCode",{parentName:"a"},"transferir tokens desde el contrato"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#eventos-e-indexado"},(0,r.kt)("inlineCode",{parentName:"a"},"eventos e indexado"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#errores-y-returns"},(0,r.kt)("inlineCode",{parentName:"a"},"errores y returns")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#throw"},(0,r.kt)("inlineCode",{parentName:"a"},"throw"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#assert"},(0,r.kt)("inlineCode",{parentName:"a"},"assert"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#require-y-revert"},(0,r.kt)("inlineCode",{parentName:"a"},"require y revert"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#mappings-anidados--estructuras-custom--avanzadas"},(0,r.kt)("inlineCode",{parentName:"a"},"mappings anidados + estructuras custom / avanzadas"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#llamadas-entre-contratos"},(0,r.kt)("inlineCode",{parentName:"a"},"llamadas entre contratos"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#enviar-transacci%C3%B3n-gen%C3%A9rica--llamadas-din%C3%A1micas-entre-contratos"},(0,r.kt)("inlineCode",{parentName:"a"},"enviar transacci\xf3n gen\xe9rica / llamadas din\xe1micas entre contratos"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#limitaciones-de-ink-v3"},"Limitaciones de ink! v3")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#soluci%C3%B3n-de-problemas-y-errores"},"Soluci\xf3n de problemas y errores")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#unit-testing-off-chain"},"unit testing (off-chain)"))))),(0,r.kt)("h2",{id:"convertir-un-contrato-de-solidity-a-ink"},"Convertir un contrato de Solidity a ink!"),(0,r.kt)("h3",{id:"1-generar-un-nuevo-contrato-de-ink"},"1. Generar un nuevo contrato de ink!"),(0,r.kt)("p",null,'Ejecutar el siguiente comando para crear la estructura de un contrato de ink! El comando instalar\xe1 el c\xf3digo repetitivo para ink! "Hola, Mundo!" (el contrato ',(0,r.kt)("a",{parentName:"p",href:"https://github.com/paritytech/ink-examples/tree/main/flipper"},(0,r.kt)("inlineCode",{parentName:"a"},"flipper")),")"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"cargo contract new <contract-name>\n")),(0,r.kt)("h3",{id:"2-compilar-el-contrato"},"2. Compilar el contrato"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"cargo contract build\n")),(0,r.kt)("h3",{id:"3-convertir-campos-de-clase-de-solidity-a-struct-de-rust"},"3. Convertir campos de clase de Solidity a Struct de Rust"),(0,r.kt)("p",null,"Solidity es un lenguaje orientado a objetos y utiliza clases. ink! (Rust) no utiliza clases. "),(0,r.kt)("p",null,"Un ejemplo de clase de Solidity se ve as\xed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},'contract MyContract {\n    bool private _theBool;\n    event UpdatedBool(bool indexed _theBool);\n\n    constructor(bool theBool_) {\n        require(theBool_ == true, "theBool_ must start as true");\n\n        _theBool = theBool_;\n    }\n\n    function setBool(bool newBool) public returns (bool boolChanged) {\n        if _theBool == newBool {\n               boolChanged = false;\n        } else {\n            boolChanged = true;\n        }\n\n        _theBool = newBool;\n        // emit event\n        UpdatedBool(newBool);\n    }\n}\n')),(0,r.kt)("p",null,"Y el equivalente en un contrato de ink! se ve as\xed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#![cfg_attr(not(feature = "std"), no_std)]\n\nuse ink_lang as ink;\n\n#[ink::contract]\nmod mycontract {\n    #[ink(storage)]\n    pub struct MyContract {\n        the_bool: bool, // las properties de clase se convierten en campos del struct\n    }\n\n    #[ink(event)]\n    pub struct UpdatedBool {\n        #[ink(topic)] // -> indexed\n        the_bool: bool,\n    }\n\n    impl MyContract {\n        #[ink(constructor)]\n        pub fn new(the_bool: bool) -> Self {\n            assert!(the_bool == true, "the_bool must start as true");\n            Self { the_bool }\n        }\n\n        #[ink(message)] // las funciones se vuelven implementaciones del struct\n        pub fn set_bool(&mut self, new_bool: bool) -> bool {\n            let bool_changed = true;\n\n            if self.the_bool == new_bool{\n                bool_changed = false;\n            }else{\n                bool_changed = true;\n            }\n\n            self.the_bool = new_bool;\n\n            self.env().emit_event(UpdatedBool {\n                the_bool: new_bool\n            });\n\n            // return\n            bool_changed\n        }\n    }\n}\n')),(0,r.kt)("p",null,"Algunas diferencias clave son:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Las variables de clase / miembros de Solidity se colocar\xe1n en el struct del contrato de ink!"),(0,r.kt)("li",{parentName:"ul"},"Todos lo m\xe9todos de clase en Solidity son ",(0,r.kt)("inlineCode",{parentName:"li"},"impl"),"ementados para el struct del contrato en ink!"),(0,r.kt)("li",{parentName:"ul"},"Solidity frecuentemente prefija variables con un gui\xf3n bajo (",(0,r.kt)("inlineCode",{parentName:"li"},"_name"),"). ink! / Rust solamente prefija con un gui\xf3n bajo a las variables ",(0,r.kt)("em",{parentName:"li"},"no usadas"),"."),(0,r.kt)("li",{parentName:"ul"},"Solidity usa camelCase. ink! usa snake_case."),(0,r.kt)("li",{parentName:"ul"},"En Solidity, el tipo de variable aparece antes del nombre de la variable (Por ejemplo: bool myVar). Mientras que ink! especifica el tipo de var despu\xe9s del nombre de var (Por ejemplo: my_var: bool)")),(0,r.kt)("h3",{id:"4-convertir-cada-funci\xf3n"},"4. Convertir cada funci\xf3n"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Comenzar a convertir cada funci\xf3n una por una."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Un enfoque recomendado es, de ser posible, evitar las llamadas cross-contract al principio y en su lugar utilizar datos simulados."),(0,r.kt)("li",{parentName:"ul"},"Este modo de prueba de unidad off-chain puede ser escrito para probar la funcionalidad b\xe1sica.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"las unidades de prueba son off-chain y no funcionan con llamadas cross-contract."))),(0,r.kt)("li",{parentName:"ul"},"Una vez que se haya probado por completo, se comienza a agregar las llamadas cross-contract y se llevan a cabo pruebas on-chain manuales y de integraci\xf3n."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Asegurarse que la funci\xf3n de visibilidad (p\xfablica y privada) se corresponda en ink!")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Si en Solidity una funci\xf3n devuelve ",(0,r.kt)("inlineCode",{parentName:"p"},"bool success"),", ink! utilizar\xe1 un ",(0,r.kt)("inlineCode",{parentName:"p"},"Result<()>")," (",(0,r.kt)("inlineCode",{parentName:"p"},"Result::Ok")," o ",(0,r.kt)("inlineCode",{parentName:"p"},"Result::Err"),")."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// ink!\n\n// result type\npub type Result<T> = core::result::Result<T, Error>;\n\n// ...\n\n// funci\xf3n p\xfablica que devuelve un Result \n#[ink(message)]\npub fn my_function(&self) -> Result<()> {\n    Ok(())\n}\n")))),(0,r.kt)("h2",{id:"mejores-pr\xe1cticas--tips"},"Mejores pr\xe1cticas + Tips"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Si el contrato de Solidity utiliza un ",(0,r.kt)("inlineCode",{parentName:"li"},"string"),", se recomienda utilizar un ",(0,r.kt)("inlineCode",{parentName:"li"},"Vec<u8>")," para evitar la sobrecarga de un ",(0,r.kt)("inlineCode",{parentName:"li"},"String"),". Ver ",(0,r.kt)("a",{parentName:"li",href:"https://substrate.stackexchange.com/questions/1174/why-is-it-a-bad-idea-to-use-string-in-an-ink-smart-contract"},"aqu\xed")," para m\xe1s detalles del porqu\xe9. El smart contract deber\xeda contener solamente la informaci\xf3n que estrictamente necesita ubicarse en la blockchain y alcanzar un consenso. La UI (interfaz de usuario) deber\xeda usarse para visualizar strings."),(0,r.kt)("li",{parentName:"ul"},"Comprobar todos los ",(0,r.kt)("inlineCode",{parentName:"li"},".unwrap()"),"s ejecutados. Solidity no tiene un control tan estricto como ink! Por ejemplo, se puede acceder a un campo de mapping  tan simple como ",(0,r.kt)("inlineCode",{parentName:"li"},"myMapping[someKey]"),". ink!, sin embargo, requiere de ",(0,r.kt)("inlineCode",{parentName:"li"},"self.my_mapping.get(some_key).unwrap()"),". Un modo \xfatil para manipular casos ",(0,r.kt)("inlineCode",{parentName:"li"},"None")," es utilizar  ",(0,r.kt)("inlineCode",{parentName:"li"},".unwrap_or(some_val)"),"."),(0,r.kt)("li",{parentName:"ul"},"Ejecutar el nodo de los contratos con ",(0,r.kt)("inlineCode",{parentName:"li"},"substrate-contracts-node -lerror,runtime::contracts=debug")," para que las impresiones depuradas y los errores se vizualicen en la consola de nodos."),(0,r.kt)("li",{parentName:"ul"},"Al pasar par\xe1metros a un helper, se recomienda pasar referencias (incluso para las primitivas) ya que Wasm es m\xe1s eficiente con referencias.\nPor ejemplo (ver ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/paritytech/ink-examples/blob/main/erc20/lib.rs"},"erc20")," ejemplo):")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"/// Devuelve el balance de la cuenta para el `owner` especificado.\n///\n/// Devuelve `0` si es una cuenta inexistente.\n#[ink(message)]\npub fn balance_of(&self, owner: AccountId) -> Balance {\n    self.balance_of_impl(&owner)\n}\n\n/// Devuelve el balance de la cuenta para el `owner` especificado. \n///\n/// Regresa a `0` si es una cuenta inexistente.\n///\n/// # Nota\n///\n/// Es preferible llamar a este m\xe9todo antes que `balance_of` ya que este \n/// funciona usando referencias que son m\xe1s eficientes en Wasm.\n#[inline]\nfn balance_of_impl(&self, owner: &AccountId) -> Balance {\n    self.balances.get(owner).unwrap_or_default()\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Al igual que en Solidity, ink! no tiene n\xfameros de punto flotante debido al car\xe1cter no determinista. En cambio el frontend deber\xeda agregar decimales de ser necesario.")),(0,r.kt)("h2",{id:"equivalencias-de-sintaxis"},"Equivalencias de sintaxis"),(0,r.kt)("h3",{id:"funci\xf3n-p\xfablica"},(0,r.kt)("inlineCode",{parentName:"h3"},"funci\xf3n p\xfablica")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},"// solidity\nfunction fnName() public {}\n// o\n// por default, las funciones son p\xfablicas\nfunction fnName() {}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// ink!\n#[ink(message)]\npub fn fn_name(&self) {}\n")),(0,r.kt)("h3",{id:"declaraci\xf3n-de-mapping-"},(0,r.kt)("inlineCode",{parentName:"h3"},"declaraci\xf3n de mapping ")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},"// solidity\nmapping(address => uint128) private mapName;\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"//ink!\nuse ink_storage::{\n    traits::SpreadAllocate,\n    Mapping,\n};\n\n#[ink(storage)]\n#[derive(SpreadAllocate)]\npub struct ContractName {\n    map_name: Mapping<AccountId, u128>,\n}\n")),(0,r.kt)("p",null,"Cuando se usa un map en ink!, ",(0,r.kt)("inlineCode",{parentName:"p"},"ink_lang::utils::initialize_contract")," se debe usar en el constructor. Ver ",(0,r.kt)("a",{parentName:"p",href:"https://use.ink/datastructures/mapping"},"aqu\xed")," para m\xe1s detalles."),(0,r.kt)("h3",{id:"uso-de-mapping"},(0,r.kt)("inlineCode",{parentName:"h3"},"uso de mapping")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},"// solidity\n\n// insertar / actualizar\naMap[aKey] = aValue;\n\n// obtener\naMap[aKey]\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// ink!\n\n// insertar / actualizar\nself.a_map.insert(&a_key, &a_value);\n\n// obtener\nself.a_map.get(a_key).unwrap()\n")),(0,r.kt)("h3",{id:"struct"},(0,r.kt)("inlineCode",{parentName:"h3"},"struct")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},"// solidity\nstruct MyPerson{\n    address person;\n    u64 favNum;\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// ink!\nstruct MyPerson {\n    person: AccountId,\n    fav_num: u64,\n}\n")),(0,r.kt)("h3",{id:"assertions--requires"},(0,r.kt)("inlineCode",{parentName:"h3"},"assertions / requires")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},'// solidity\nrequire(someValue < 10, "someValue is not less than 10");\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// ink!\nassert!(some_value < 10, "some_value is not less than 10");\n')),(0,r.kt)("h3",{id:"timestamp"},(0,r.kt)("inlineCode",{parentName:"h3"},"timestamp")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},"// solidity\nblock.timestamp\n// or\nnow\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// ink!\nself.env().block_timestamp()\n")),(0,r.kt)("h3",{id:"caller-del-contrato"},(0,r.kt)("inlineCode",{parentName:"h3"},"caller del contrato")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},"// solidity\naddress caller = msg.sender;\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// ink!\nlet caller: AccountId = self.env().caller();\n")),(0,r.kt)("h3",{id:"direcci\xf3n-de-contrato"},(0,r.kt)("inlineCode",{parentName:"h3"},"direcci\xf3n de contrato")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},"// solidity\naddress(this)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// ink!\nself.env().account_id()\n")),(0,r.kt)("h3",{id:"bytes"},(0,r.kt)("inlineCode",{parentName:"h3"},"bytes")),(0,r.kt)("p",null,"Solidity tiene un tipo ",(0,r.kt)("inlineCode",{parentName:"p"},"bytes"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"bytes")," es (esencialmente) equivalente a un array de uint8. Por lo tanto ",(0,r.kt)("inlineCode",{parentName:"p"},"bytes")," en Solidity => ",(0,r.kt)("inlineCode",{parentName:"p"},"Vec<u8>")," o ",(0,r.kt)("inlineCode",{parentName:"p"},"[u8; ...]")," en ink!. Ver ",(0,r.kt)("a",{parentName:"p",href:"https://ethereum.stackexchange.com/questions/91119/difference-between-byte-and-uint8-datatypes-in-solidity"},"aqu\xed")," para m\xe1s detalles. Si se desea, un struct de ",(0,r.kt)("inlineCode",{parentName:"p"},"bytes")," puede ser creado en ink! para replicar el tipo ",(0,r.kt)("inlineCode",{parentName:"p"},"bytes")," en Solidity."),(0,r.kt)("h3",{id:"uint256"},(0,r.kt)("inlineCode",{parentName:"h3"},"uint256")),(0,r.kt)("p",null,"Solidity utiliza ",(0,r.kt)("inlineCode",{parentName:"p"},"uint256")," y ",(0,r.kt)("inlineCode",{parentName:"p"},"uint")," para representar un tipo de 256 bits."),(0,r.kt)("p",null,"Solidity est\xe1 optimizado para words de 256 bits / 32 bytes. Esto significa que si usamos ",(0,r.kt)("inlineCode",{parentName:"p"},"uint256")," en los contratos Solidity se reducir\xe1 el uso de gas -- pero aumentar\xe1 el uso del storage. El mayor tama\xf1o que tiene ink! es un ",(0,r.kt)("inlineCode",{parentName:"p"},"u128"),". ink! compila a Wasm. El mayor tama\xf1o de primitiva de Wasm es 64bit(debido a que la mayor\xeda de las computadoras usan 64bit). Por lo tanto no hay ning\xfan beneficio en usar una primitiva m\xe1s grande sobre una colecci\xf3n."),(0,r.kt)("p",null,"Cuando se transfiere un ",(0,r.kt)("inlineCode",{parentName:"p"},"uint256")," de Solidity a ink!, se recomienda  determinar a discreci\xf3n el rango del valor y elegir el tama\xf1o adecuado (u8, u16, u32, u64, u128). Si se requiere un valor de hash de 256 bits, ink! tiene una primitiva de ",(0,r.kt)("inlineCode",{parentName:"p"},"Hash")," disponible. En el caso que un valor necesite ser de 256 bits, se recomienda utilizar un array (ejemplo: ",(0,r.kt)("inlineCode",{parentName:"p"},"[u64; 4]"),")."),(0,r.kt)("h3",{id:"payable"},(0,r.kt)("inlineCode",{parentName:"h3"},"payable")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},"// solidity\nfunction myFunction() payable returns (uint64) {}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[ink(message, payable)]\npub fn my_function() -> (u64) {}\n")),(0,r.kt)("h3",{id:"dep\xf3sito-recibido--pago"},(0,r.kt)("inlineCode",{parentName:"h3"},"dep\xf3sito recibido / pago")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-C++"},"// solidity\nmsg.value\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// ink!\nself.env().transferred_value()\n")),(0,r.kt)("h3",{id:"balance-del-contrato"},(0,r.kt)("inlineCode",{parentName:"h3"},"balance del contrato")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},"// solidity\nthis.balance\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// ink!\nself.env().balance()\n")),(0,r.kt)("h3",{id:"transferir-tokens-desde-el-contrato"},(0,r.kt)("inlineCode",{parentName:"h3"},"transferir tokens desde el contrato")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},"// solidity\nrecipient.send(amount)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// ink!\nif self.env().transfer(recipient, amount).is_err() {\n    panic!("error transferring")\n}\n')),(0,r.kt)("h3",{id:"eventos-e-indexado"},(0,r.kt)("inlineCode",{parentName:"h3"},"eventos e indexado")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},"// solidity\n\nevent MyCoolEvent(\n    u128 indexed indexedValue,\n    u128 notIndexedValue,\n);\n\n// emitir evento\nMyCoolEvent (someValue, someOtherValue)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// ink!\n\n#[ink(event)]\npub struct MyCoolEvent {\n    #[ink(topic)]\n    indexed_value: u128,\n\n    not_indexed_value: u128,\n}\n\n// emitir evento\nself.env().emit_event(MyCoolEvent {\n    indexed_value: some_value,\n    not_indexed_value: some_other_value\n});\n")),(0,r.kt)("h3",{id:"errores-y-returns"},(0,r.kt)("inlineCode",{parentName:"h3"},"errores y returns")),(0,r.kt)("p",null,"Solidity tiene varios mecanismos de manejo de errores: ",(0,r.kt)("inlineCode",{parentName:"p"},"assert"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"require"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"revert"),", y ",(0,r.kt)("inlineCode",{parentName:"p"},"throw"),". Cada uno de los cuales revertir\xe1 el estado modificado cuando sea solicitado. Ver ",(0,r.kt)("a",{parentName:"p",href:"https://medium.com/blockchannel/the-use-of-revert-assert-and-require-in-solidity-and-the-new-revert-opcode-in-the-evm-1a3a7990e06e"},"este art\xedculo")," para detalles sobre esto. "),(0,r.kt)("p",null,"ink! usa un enum ",(0,r.kt)("inlineCode",{parentName:"p"},"Result")," (",(0,r.kt)("inlineCode",{parentName:"p"},"Ok(T)"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Err(E)"),"), ",(0,r.kt)("inlineCode",{parentName:"p"},"assert!")," y ",(0,r.kt)("inlineCode",{parentName:"p"},"panic!"),". ",(0,r.kt)("a",{parentName:"p",href:"https://substrate.stackexchange.com/questions/2391/panic-in-ink-smart-contracts"},"Esta respuesta de Stack Exchange")," y ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/paritytech/ink/issues/641"},"discusi\xf3n de GitHub")," brindan m\xe1s detalles sobre esto."),(0,r.kt)("h4",{id:"throw"},(0,r.kt)("inlineCode",{parentName:"h4"},"throw")),(0,r.kt)("p",null,"Throw est\xe1 deprecado en Solidity y dar\xeda un error de invalid opcode (sin detalles) y revertir\xeda el estado. Como una alternativa para el patr\xf3n ",(0,r.kt)("inlineCode",{parentName:"p"},"if...{throw;}")," en Solidity, un ",(0,r.kt)("inlineCode",{parentName:"p"},"Result::Err")," deber\xeda ser devuelto para errores esperados, y un ",(0,r.kt)("inlineCode",{parentName:"p"},"assert!")," deber\xeda ser usado para errores que no deber\xedan ocurrir."),(0,r.kt)("h4",{id:"assert"},(0,r.kt)("inlineCode",{parentName:"h4"},"assert")),(0,r.kt)("p",null,"En Solidity, ",(0,r.kt)("inlineCode",{parentName:"p"},"assert")," se utiliza como un protector interno contra errores en el ",(0,r.kt)("em",{parentName:"p"},"c\xf3digo"),". En general, un c\xf3digo que est\xe9 funcionando correctamente nunca deber\xeda tener un assert fallido. ",(0,r.kt)("inlineCode",{parentName:"p"},"assert")," en Solidity no tiene strings de error. En ink!, usar ",(0,r.kt)("inlineCode",{parentName:"p"},"assert!"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"assert!")," dar\xe1 como resultado ",(0,r.kt)("inlineCode",{parentName:"p"},"panic!")," si se eval\xfaa como ",(0,r.kt)("em",{parentName:"p"},"falso"),". El estado se revertir\xe1, y se devolver\xe1 un ",(0,r.kt)("inlineCode",{parentName:"p"},"CalleeTrapped"),". El string de error (opcional) se imprimir\xe1 en el b\xfafer de depuraci\xf3n."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// ink!\nassert!(caller == owner, "caller is not owner")\n')),(0,r.kt)("h4",{id:"require-y-revert"},(0,r.kt)("inlineCode",{parentName:"h4"},"require y revert")),(0,r.kt)("p",null,"En Solidity, ",(0,r.kt)("inlineCode",{parentName:"p"},"require")," se usa para errores generales (normales) -- por ejemplo errores que ocurren basados en el input del usuario. ",(0,r.kt)("inlineCode",{parentName:"p"},"require")," no tiene la opci\xf3n para un string de error. ",(0,r.kt)("inlineCode",{parentName:"p"},"revert")," es muy similar a ",(0,r.kt)("inlineCode",{parentName:"p"},"require")," excepto que ",(0,r.kt)("inlineCode",{parentName:"p"},"revert")," ser\xe1 llamado en cadenas ",(0,r.kt)("inlineCode",{parentName:"p"},"if ... else"),". Ambos ",(0,r.kt)("inlineCode",{parentName:"p"},"require")," y ",(0,r.kt)("inlineCode",{parentName:"p"},"revert")," revertir\xe1n el estado de la chain. En ink!, ",(0,r.kt)("inlineCode",{parentName:"p"},"if ... { return Err(Error::SomeError) }")," deber\xeda usarse para ",(0,r.kt)("inlineCode",{parentName:"p"},"require")," o ",(0,r.kt)("inlineCode",{parentName:"p"},"revert"),". Cuando un ",(0,r.kt)("inlineCode",{parentName:"p"},"Result::Err")," se devuelve en ink! todo el estado se revierte."),(0,r.kt)("p",null,"En general, ",(0,r.kt)("inlineCode",{parentName:"p"},"Result::Err")," deber\xeda usarse cuando un ",(0,r.kt)("em",{parentName:"p"},"calling contract")," necesita saber ",(0,r.kt)("em",{parentName:"p"},"por qu\xe9")," una funci\xf3n fall\xf3. De otro modo, ",(0,r.kt)("inlineCode",{parentName:"p"},"assert!")," deber\xeda usarse ya que tiene menos sobrecarga que un ",(0,r.kt)("inlineCode",{parentName:"p"},"Result"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},'// Solidity\nfunction myFunction(bool returnError) public {\n    require(!returnError, "my error here");\n\n    // o\n\n    if returnError {\n        revert("my error here");\n    }\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// ink!\n\n#[derive(Debug, PartialEq, Eq, scale::Encode, scale::Decode)]\n#[cfg_attr(feature = "std", derive(scale_info::TypeInfo))]\npub enum Error {\n    /// Proveer un comentario detallado sobre el error\n    MyError,\n}\n\n// tipo Result\npub type Result<T> = core::result::Result<T, Error>;\n\n// ...\n\n#[ink(message)]\npub fn my_function(&self, return_error: bool) -> Result<()> {\n    if return_error{\n        return Err(Error::MyError)\n    }\n    Ok(())\n}\n')),(0,r.kt)("h3",{id:"mappings-anidados--estructuras-custom--avanzadas"},(0,r.kt)("inlineCode",{parentName:"h3"},"mappings anidados + estructuras custom / avanzadas")),(0,r.kt)("p",null,"En Solidity, es f\xe1cil crear mappings anidados. En ink! no es tan sencillo."),(0,r.kt)("p",null,"imaginemos el siguiente escenario "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},"// solidity\ncontract Dao {\n    struct Proposal {\n        mapping (address => bool) votedYes\n    }\n\n    mapping (address => bool) public isWhitelisted;\n    Proposal[] public proposals;\n}\n")),(0,r.kt)("p",null,"en ink! esto ",(0,r.kt)("em",{parentName:"p"},"parece")," como si se pudiera representar as\xed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[ink::contract]\nmod dao {\n\n    #[derive(SpreadAllocate)]\n    pub struct Proposal {\n        voted_yes: Mapping<AccountId, bool>,\n    }\n\n    #[ink(storage)]\n    #[derive(SpreadAllocate)]\n    pub struct Dao {\n        proposals: Vec<Proposal>,\n        is_whitelisted: Mapping<AccountId, bool>,\n    }\n\n    impl Dao{\n        #[ink(constructor)]\n        pub fn new(/*...*/) -> Self {\n            //requerido para mappings\n            ink_lang::utils::initialize_contract(|contract| {/*...*/})\n        }\n    }\n}\n")),(0,r.kt)("p",null,"Sin embargo, esto originar\xe1 un error debido al mapping anidado.",(0,r.kt)("a",{parentName:"p",href:"https://substrate.stackexchange.com/questions/1659/how-to-have-a-mapping-in-a-custom-structure-inside-an-ink-contract"},"Esta respuesta")," explica en detalle por qu\xe9 no se permiten los mappings anidados."),(0,r.kt)("p",null,"Por lo tanto desde ahora ser\xe1 necesaria una estructura de datos alternativa para solucionar este problema. Una estructura de datos que puede ser intercambiable con la sintaxis de ",(0,r.kt)("inlineCode",{parentName:"p"},"Mapping")," y con las implementaciones m\xednimas adicionales es el ",(0,r.kt)("inlineCode",{parentName:"p"},"BTreeMap"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"BTreeMap")," es menos eficiente que ",(0,r.kt)("inlineCode",{parentName:"p"},"Mapping"),", pero es una soluci\xf3n simple hasta que se permitan los mappings anidados. Esto se utilizar\xe1 en el struct anidado. ",(0,r.kt)("inlineCode",{parentName:"p"},"derive"),"s adicionales deber\xe1n usarse para que sean compatibles con el struct #","[ink(storage)]"," (ver abajo)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[ink::contract]\nmod dao {\n\n    use ink_prelude::collections::BTreeMap;\n\n    #[derive(\n        scale::Encode,\n        scale::Decode,\n        SpreadLayout,\n        PackedLayout,\n        SpreadAllocate,\n    )]\n    #[cfg_attr(\n        feature = "std",\n        derive(scale_info::TypeInfo, ink_storage::traits::StorageLayout)\n    )]\n    pub struct Proposal {\n        voted_yes: BTreeMap<AccountId, bool>,\n    }\n\n    #[ink(storage)]\n    #[derive(SpreadAllocate)]\n    pub struct Dao {\n        proposals: Vec<Proposal>,\n        is_whitelisted: Mapping<AccountId, bool>,\n    }\n\n    impl Dao{\n        #[ink(constructor)]\n        pub fn new(/*...*/) -> Self {\n            //requerido para mappings\n            ink_lang::utils::initialize_contract(|contract| {/*...*/})\n        }\n    }\n}\n')),(0,r.kt)("p",null,"Esto funciona casi como ser\xeda de esperar. Sin embargo a\xfan existe un problema. ",(0,r.kt)("inlineCode",{parentName:"p"},"SpreadAllocate")," (usado con ",(0,r.kt)("inlineCode",{parentName:"p"},"Mapping"),") requiere que ",(0,r.kt)("inlineCode",{parentName:"p"},"Vec<Proposal>")," implemente ",(0,r.kt)("inlineCode",{parentName:"p"},"PackedAllocate"),". Para solucionarlo, ",(0,r.kt)("inlineCode",{parentName:"p"},"Proposal")," necesita implementar ",(0,r.kt)("inlineCode",{parentName:"p"},"PackedAllocate"),". Ver ",(0,r.kt)("a",{parentName:"p",href:"https://docs.rs/ink_storage/3.3.1/ink_storage/traits/trait.PackedAllocate.html"},"aqu\xed")," para detalles + ejemplos. Ver lo siguiente para este ejemplo:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"use ink_primitives::Key;\n\npub struct Proposal {\n    voted_yes: BTreeMap<AccountId, bool>,\n}\n\nimpl ink_storage::traits::PackedAllocate for Proposal {\n    fn allocate_packed(&mut self, at: &Key){\n        PackedAllocate::allocate_packed(&mut *self, at)\n    }\n}\n")),(0,r.kt)("h3",{id:"llamadas-entre-contratos"},(0,r.kt)("inlineCode",{parentName:"h3"},"llamadas entre contratos")),(0,r.kt)("p",null,"En ink!, para hacer ",(0,r.kt)("a",{parentName:"p",href:"https://use.ink/basics/cross-contract-calling"},"llamadas entre contratos"),", se necesitar\xe1 que el contrato sea agregado al proyecto. Asegurarse que el contrato est\xe9 exportando adecuadamente sus Structs. Ver el ejemplo de contrato ",(0,r.kt)("inlineCode",{parentName:"p"},"erc20"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#![cfg_attr(not(feature = "std"), no_std)]\n\nuse ink_lang as ink;\n\n// hacer visibles los structs\npub use self::erc20::{\n    Erc20,\n    // esto es necesario\n    Erc20Ref,\n};\n\n#[ink::contract]\npub mod erc20 {}\n')),(0,r.kt)("p",null,"En el Cargo.toml del nuevo contrato llamado, agregar (o editar) lo siguiente:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'[lib]\nname = "erc20"\npath = "lib.rs"\ncrate-type = [\n    # Usado para blobs Wasm de contrato normal.\n    "cdylib",\n    # Usado para generaci\xf3n de ABI. Necesario para importar como dependencia\n    "rlib",\n]\n\n[features]\nink-as-dependency = []\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ink-as-dependency"),' "le dice al generador de c\xf3digo ink! que siempre o nunca compile el smart contract como si fuera usado como dependencia de otro smart contract de ink!" (',(0,r.kt)("a",{parentName:"p",href:"https://use.ink/basics/cross-contract-calling"},"fuente"),")."),(0,r.kt)("p",null,"Entonces, en el Cargo.toml del contrato principal, importar el contrato al que se llamar\xe1."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'erc20 = { path = "erc20", default-features = false, features = ["ink-as-dependency"] }\n')),(0,r.kt)("p",null,"Y asegurarse de agregarlo al campo ",(0,r.kt)("inlineCode",{parentName:"p"},"std")," del archivo .toml."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'[features]\ndefault = ["std"]\nstd = [\n    # ...\n\n    "erc20/std",\n]\n')),(0,r.kt)("p",null,"Ahora, importar el contrato llamado al contrato principal:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// ejemplo\nuse erc20::Erc20Ref;\n")),(0,r.kt)("p",null,"Hay dos m\xe9todos para configurar el otro contrato."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Instanciar el contrato llamado en el constructor del contrato principal.",(0,r.kt)("br",{parentName:"p"}),"\n","Ver ",(0,r.kt)("a",{parentName:"p",href:"https://use.ink/basics/cross-contract-calling/"},"aqu\xed")," para un tutorial, y ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/paritytech/ink-examples/tree/main/delegator"},"aqu\xed")," para un ejemplo.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"O agregar el ",(0,r.kt)("inlineCode",{parentName:"p"},"AccountId")," de un contrato ya deployado.\nAqu\xed hay un ejemplo de constructor para configurar esto:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"use my_other_contract::MyOtherContractRef;\n// ...\nfn new(contract_id: AccountId) -> Self {\n     // para un contrato ya deployado\n     let contract_ref: MyOtherContractRef =\n         ink_env::call::FromAccountId::from_account_id(contract_id);\n     Self {contract_ref}\n}\n")))),(0,r.kt)("p",null,"Ahora para realizar la llamada de contratos:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"{\n    self.contract_ref.some_external_function(a_param);\n}\n")),(0,r.kt)("p",null,"Nota: a partir de ahora (ink! v3.3.1), cuando se est\xe1 haciendo llamadas entre contratos, emitir eventos no funcionar\xe1 y ocurrir\xe1n errores de compilaci\xf3n. Ver ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/paritytech/ink/issues/1000"},"issue #1000"),". Adem\xe1s el compilador dar\xe1 error diciendo (por ejemplo) Erc20Ref no implementa ",(0,r.kt)("inlineCode",{parentName:"p"},"SpreadAllocate"),". Este ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/paritytech/ink/issues/1149"},"issue #1149")," explica m\xe1s y tiene una soluci\xf3n. Estos problemas ser\xe1n resueltos en ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/paritytech/ink/issues/1134"},"issue #1134"),"."),(0,r.kt)("h3",{id:"enviar-transacci\xf3n-gen\xe9rica--llamadas-din\xe1micas-entre-contratos"},(0,r.kt)("inlineCode",{parentName:"h3"},"enviar transacci\xf3n gen\xe9rica / llamadas din\xe1micas entre contratos")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},"// solidity\n\n// invoca una funci\xf3n encontrada en `addr`, env\xeda el `_amount` al `addr` y el payload de la `_transactionData`.\naddr.call.value(_amount)(_transactionData)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// ink!\n\n// ...\n\nuse ink_env::call::{\n    build_call,\n    Call,\n    ExecutionInput,\n    Selector,\n};\n\n/// Un wrapper que nos permite codificar un blob de bytes.\n///\n/// Usamos esto para pasar el conjunto de par\xe1metros no tipados (bytes) al `CallBuilder`.\nstruct CallInput<'a>(&'a [u8]);\n\nimpl<'a> scale::Encode for CallInput<'a> {\n    fn encode_to<T: Output + ?Sized>(&self, dest: &mut T) {\n        dest.write(self.0);\n    }\n}\n\n// ...\n\n// ver: https://github.com/paritytech/ink-examples/blob/main/multisig/lib.rs#L535\nfn invoke_transaction(\n    &mut self,\n    callee: AccountId,\n    transfer_amount: u128,\n    function_selector: [u8; 4],\n    transaction_data: Vec<u8>,\n    gas_limit: u64) -> Result<()> {\n\n    let result = build_call::<<Self as ::ink_lang::reflect::ContractEnv>::Env>()\n        .call_type(\n            Call::new()\n                .callee(callee) // contrato a llamar\n                .gas_limit(*gas_limit)\n                .transferred_value(transfer_amount), // valor a transferir con la llamada\n        )\n        .exec_input(\n            ExecutionInput::new(Selector::from(*function_selector))\n                    .push_arg(CallInput(transaction_data)), // par\xe1metros SCALE-encoded\n        )\n        .returns::<()>()\n        .fire()\n        .map_err(|_| Error::TransactionFailed);\n    result\n}\n\n")),(0,r.kt)("p",null,"Nota: los bytes de ",(0,r.kt)("inlineCode",{parentName:"p"},"function_selector")," pueden encontrarse en el ",(0,r.kt)("inlineCode",{parentName:"p"},"target/ink/<contract-name>.json")," generado."),(0,r.kt)("h2",{id:"limitaciones-de-ink-v3"},"Limitaciones de ink! v3"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Los proyectos multi archivo no son soportados con ink! puro.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"implementar traits / interfaces no funcionar\xe1 "),(0,r.kt)("li",{parentName:"ul"},"Hay alternativas que agregar\xe1n esta funcionalidad tal como OpenBrush "))),(0,r.kt)("li",{parentName:"ul"},"Structs anidados y estructuras de datos ser\xe1n dif\xedciles de usar."),(0,r.kt)("li",{parentName:"ul"},"Las llamadas entre contratos evitar\xe1n que los eventos sean emitidos. Ver ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/paritytech/ink/issues/1000"},"aqu\xed")," para detalles. "),(0,r.kt)("li",{parentName:"ul"},"Las llamadas entre contratos no pueden ser testeadas off-chain con tests unitarios.\nSe necesitar\xe1 utilizar tests de integraci\xf3n On-chain.")),(0,r.kt)("h2",{id:"soluci\xf3n-de-problemas-y-errores"},"Soluci\xf3n de problemas y errores"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ERROR: Validation of the Wasm failed."))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"ERROR: Validation of the Wasm failed.\n\nERROR: An unexpected panic function import was found in the contract Wasm.\nThis typically goes back to a known bug in the Rust compiler:\nhttps://github.com/rust-lang/rust/issues/78744\n\nAs a workaround try to insert `overflow-checks = false` into your `Cargo.toml`.\nThis will disable safe math operations, but unfortunately we are currently not\naware of a better workaround until the bug in the compiler is fixed.\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Soluci\xf3n"),(0,r.kt)("br",{parentName:"p"}),"\n","Agregar lo siguiente al Cargo.toml del contrato:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"[profile.release]\noverflow-checks = false\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"\"failed to load bitcode of module '...' \""))),(0,r.kt)("p",null,"Esto sucede cuando se est\xe1 intentando importar un contrato para llamadas entre contratos."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Soluci\xf3n"),(0,r.kt)("br",{parentName:"p"}),"\n","Asegurarse que lo siguiente se agregue a la importaci\xf3n del Cargo.toml del contrato:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'features = ["ink-as-dependency"]\n')),(0,r.kt)("p",null,"por lo tanto la importaci\xf3n se ver\xeda as\xed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'mycontract = { path = "mycontract/", default-features = false, features = ["ink-as-dependency"]}\n')),(0,r.kt)("h2",{id:"unit-testing-off-chain"},"unit testing (off-chain)"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Los unit tests son una parte integral del desarrollo de un smart contract y garantizan que el c\xf3digo funciona off-chain antes de testearlo on-chain. "),(0,r.kt)("li",{parentName:"ul"},"Para ejecutar tests de ink!, ",(0,r.kt)("em",{parentName:"li"},"no")," usar ",(0,r.kt)("inlineCode",{parentName:"li"},"cargo +nightly contract test"),". Usar ",(0,r.kt)("inlineCode",{parentName:"li"},"cargo +nightly test"),". Agregar el indicador ",(0,r.kt)("inlineCode",{parentName:"li"},"--nocapture")," para mostrar los prints de debug. Ver ",(0,r.kt)("a",{parentName:"li",href:"https://substrate.stackexchange.com/questions/3197/how-to-understand-which-test-failed-in-ink"},"aqu\xed")," para m\xe1s informaci\xf3n sobre las razones."),(0,r.kt)("li",{parentName:"ul"},"Desde el m\xf3dulo del contrato, asegurarse que se hace p\xfablico el struct del contrato y cualquier otra cosa que se use en el test de unidad.\nPor ejemplo:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// tope del archivo\n#![cfg_attr(not(feature = "std"), no_std)]\n\nuse ink_lang as ink;\n\npub use self::mycontract::{\n    MyContract\n};\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Los unit tests Off-chain no funcionar\xe1n con las llamadas entre contratos.\nUna soluci\xf3n para asegurarse que los unit tests est\xe1n pasando es proveer datos simulados.")),(0,r.kt)("p",null,"Un enfoque sencillo es usar una compilaci\xf3n condicional con ",(0,r.kt)("inlineCode",{parentName:"p"},"#[cfg(test)]")," y ",(0,r.kt)("inlineCode",{parentName:"p"},"#[cfg(not(test))]"),"."),(0,r.kt)("p",null,"Nota: Esta soluci\xf3n no es ideal. ink! v4.0 proveer\xe1 soluciones mucho mejores."),(0,r.kt)("p",null,"Por ejemplo, aqu\xed hay una llamada entre contratos ERC20 s\xf3lo modo lectura:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// s\xf3lo compila cuando no est\xe1 ejecutando tests\n#[cfg(not(test))]\nfn get_token_balance(&self, caller: &AccountId) -> Balance {\n    // llama al contrato externo ERC-20 \n    self.token.balance_of(*caller)\n}\n\n// s\xf3lo compila cuando est\xe1 ejecutando tests\n#[cfg(test)]\nfn get_token_balance(&self, _: &AccountId) -> Balance {\n    // valor arbitrario\n    1\n}\n")),(0,r.kt)("p",null,"Y si la llamada entre contratos ",(0,r.kt)("em",{parentName:"p"},"escribe")," en el storage, un campo simulado puede agregase al struct del contrato. Por ejemplo:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[ink(storage)]\npub struct MyContract {\n    #[cfg(test)]\n    mock_field: SomeStruct, // servir\xe1 como un storage falso\n}\n\n...\n\n// on-chain, ejecuta llamadas entre contratos \n#[cfg(not(test))]\nfn do_some_write(&mut self) {\n    self.external_contract.write_to_field(0xDEADBEEF);\n}\n\n\n// s\xf3lo para ambiente de testing\n#[cfg(test)]\nfn do_some_write(&mut self) {\n    self.mock_field.my_fake_storage_item = 0xDEADBEEF;\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"c\xf3digo \xfatil para interactuar y modificar el ambiente del contrato para testing")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://paritytech.github.io/ink/ink_env/test/index.html"},"ink_env docs")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// obtener las cuentas default (alice, bob, ...)\nlet accounts = ink_env::test::default_accounts::<ink_env::DefaultEnvironment>();\naccounts.alice //ejemplo de uso\n\n// establecer cu\xe1l cuenta llama al contrato\nink_env::test::set_caller::<ink_env::DefaultEnvironment>(accounts.bob);\n\n// obtener la direcci\xf3n del contrato\nlet callee = ink_env::account_id::<ink_env::DefaultEnvironment>();\n\n// establecer la direcci\xf3n del contrato\n// por default, \xe9sta es la cuenta de alice\nink_env::test::set_callee::<ink_env::DefaultEnvironment>(callee);\n\n// transferir la moneda nativa al contrato \nink_env::test::set_value_transferred::<ink_env::DefaultEnvironment>(2);\n\n// aumentar el n\xfamero de bloque (y el timestamp del bloque).\n// esto puede ser colocado en un bucle para adelantar el bloque varias veces\nink_env::test::advance_block::<ink_env::DefaultEnvironment>();\n\n// generar un AccountId arbitrario\nAccountId::from([0x01; 32]);\n\n// generar un Hash arbitrario \nHash::from([0x01; 32])\n\n// macro para tests que se espera que entren en panic.\n#[should_panic]\n")))}u.isMDXComponent=!0}}]);