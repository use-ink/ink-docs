"use strict";(self.webpackChunkink_docs=self.webpackChunkink_docs||[]).push([[219],{3905:(e,a,t)=>{t.d(a,{Zo:()=>d,kt:()=>g});var n=t(7294);function r(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function o(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function s(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?o(Object(t),!0).forEach((function(a){r(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function i(e,a){if(null==e)return{};var t,n,r=function(e,a){if(null==e)return{};var t,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)t=o[n],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)t=o[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=n.createContext({}),l=function(e){var a=n.useContext(c),t=a;return e&&(t="function"==typeof e?e(a):s(s({},a),e)),t},d=function(e){var a=l(e.components);return n.createElement(c.Provider,{value:a},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},m=n.forwardRef((function(e,a){var t=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),u=l(t),m=r,g=u["".concat(c,".").concat(m)]||u[m]||p[m]||o;return t?n.createElement(g,s(s({ref:a},d),{},{components:t})):n.createElement(g,s({ref:a},d))}));function g(e,a){var t=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var o=t.length,s=new Array(o);s[0]=m;var i={};for(var c in a)hasOwnProperty.call(a,c)&&(i[c]=a[c]);i.originalType=e,i[u]="string"==typeof e?e:r,s[1]=i;for(var l=2;l<o;l++)s[l]=t[l];return n.createElement.apply(null,s)}return n.createElement.apply(null,t)}m.displayName="MDXCreateElement"},4242:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var n=t(7462),r=(t(7294),t(3905));const o={title:"Estructura del storage",slug:"/datastructures/storage-layout",hide_title:!0},s=void 0,i={unversionedId:"datastructures/storage-layout",id:"datastructures/storage-layout",title:"Estructura del storage",description:"A los autores de smart contracts se les da cierta flexibilidad respecto a c\xf3mo ellos quieren organizar la estructura de storage de sus smart contracts.",source:"@site/i18n/es/docusaurus-plugin-content-docs/current/datastructures/storage-layout.md",sourceDirName:"datastructures",slug:"/datastructures/storage-layout",permalink:"/es/datastructures/storage-layout",draft:!1,editUrl:"https://github.com/paritytech/ink-docs/edit/master/docs/datastructures/storage-layout.md",tags:[],version:"current",frontMatter:{title:"Estructura del storage",slug:"/datastructures/storage-layout",hide_title:!0},sidebar:"reference",previous:{title:"Trabajando con Mapping",permalink:"/es/datastructures/mapping"},next:{title:"Estructuras de Datos Personalizadas",permalink:"/es/datastructures/custom-datastructure"}},c={},l=[{value:"Organizaci\xf3n del storage",id:"organizaci\xf3n-del-storage",level:2},{value:"Estructura Packed vs Non-Packed",id:"estructura-packed-vs-non-packed",level:2},{value:"Eager Loading vs. Lazy Loading",id:"eager-loading-vs-lazy-loading",level:2},{value:"Generaci\xf3n de key Manual vs. Autom\xe1tica",id:"generaci\xf3n-de-key-manual-vs-autom\xe1tica",level:2},{value:"Consideraciones",id:"consideraciones",level:2}],d={toc:l},u="wrapper";function p(e){let{components:a,...t}=e;return(0,r.kt)(u,(0,n.Z)({},d,t,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("img",{src:"/img/title/storage.svg",className:"titlePic"}),(0,r.kt)("h1",{id:"estructura-del-storage"},"Estructura del storage"),(0,r.kt)("p",null,"A los autores de smart contracts se les da cierta flexibilidad respecto a c\xf3mo ellos quieren organizar la estructura de storage de sus smart contracts.\nProfundicemos sobre los conceptos detr\xe1s del storage de ink! para comprender mejor algunas de sus implicaciones y limitaciones."),(0,r.kt)("h2",{id:"organizaci\xf3n-del-storage"},"Organizaci\xf3n del storage"),(0,r.kt)("p",null,"El siguiente esquema representa el storage que es expuesto a ink! por el contract pallet:"),(0,r.kt)("div",{class:"schema"},(0,r.kt)("img",{src:"/img/kv.svg",alt:"Organizaci\xf3n del storage: estructura"})),(0,r.kt)("p",null,"Los datos de storage siempre se codifican con el codec\n",(0,r.kt)("a",{parentName:"p",href:"https://docs.substrate.io/reference/scale-codec/"},(0,r.kt)("inlineCode",{parentName:"a"},"SCALE")),".\nLa API de storage funciona guardando y cargando registros en y desde celdas de storage \xfanicas, donde se accede a cada celda de storage con su propia storage key. Hasta cierto punto, la API del storage funciona de manera similar a una base de datos key-value tradicional."),(0,r.kt)("h2",{id:"estructura-packed-vs-non-packed"},"Estructura Packed vs Non-Packed"),(0,r.kt)("p",null,"Los tipos que se pueden guardar completamente en una sola celda de storage se consideran ",(0,r.kt)("a",{parentName:"p",href:"https://docs.rs/ink_storage_traits/4.0.0/ink_storage_traits/trait.Packed.html"},(0,r.kt)("inlineCode",{parentName:"a"},"Packed")),".\nPor default, ink! intenta guardar todos los campos de struct de storage en una \xfanica celda de storage.\nEn consecuencia, con una estructura de storage ",(0,r.kt)("inlineCode",{parentName:"p"},"Packed"),", cualquier mensaje que interact\xfae con el storage del contrato siempre necesitar\xe1 operar en todo el struct de storage del contrato."),(0,r.kt)("p",null,"Por ejemplo, si tenemos un struct de storage relativamente peque\xf1o que consiste de unos pocos campos diminutos, obtener todo desde el storage en cada mensaje no es problem\xe1tico. Quiz\xe1s hasta sea favorable - especialmente si esperamos que la mayor\xeda de los mensajes interact\xfaen con la mayor\xeda de los campos del storage."),(0,r.kt)("p",null,"Por otro lado, esto puede ser problem\xe1tico si estamos guardando un gran ",(0,r.kt)("inlineCode",{parentName:"p"},"ink::prelude::vec::Vec")," en el storage del contrato pero provee mensajes que no necesitan ser le\xeddos y escritos de este ",(0,r.kt)("inlineCode",{parentName:"p"},"Vec"),". En ese escenario, todos y cada uno de los mensajes del contrato sufre de un overhead de ejecuci\xf3n al tratar con ese ",(0,r.kt)("inlineCode",{parentName:"p"},"Vec"),", independientemente de si acceden a \xe9l o no. Esto resulta en costos de gas extra. Para resolver este problema necesitamos transformar nuestro storage en una estructura non-packed de alg\xfan modo."),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Si alg\xfan tipo que muestra estructura ",(0,r.kt)("inlineCode",{parentName:"p"},"Packed")," se hace lo suficientemente grande (un ",(0,r.kt)("inlineCode",{parentName:"p"},"Vec")," en crecimiento constante podr\xeda ser un candidato perfecto para esto), romper\xe1 el contrato. Esto sucede porque para codificar y decodificar elementos del storage, hay un buffer con solamente capacidad limitada (alrededor de 16KB en la configuraci\xf3n por default) disponible. Esto significa que cada contrato que intente decodificar m\xe1s que eso lanzar\xe1 un error. Si uno no est\xe1 seguro del tama\xf1o potencial que pueda adquirir una estructura de datos, se deber\xeda considerar usar un ink! ",(0,r.kt)("inlineCode",{parentName:"p"},"Mapping"),", que puede guardar un n\xfamero arbitrario de elementos en cambio.")),(0,r.kt)("h2",{id:"eager-loading-vs-lazy-loading"},"Eager Loading vs. Lazy Loading"),(0,r.kt)("p",null,"ink! provee medios para dividir el storage en partes m\xe1s peque\xf1as, que pueden ser cargadas a demanda, con la primitiva ",(0,r.kt)("a",{parentName:"p",href:"https://paritytech.github.io/ink/ink/storage/struct.Lazy.html"},(0,r.kt)("inlineCode",{parentName:"a"},"Lazy")),". Envolver cualquier campo dentro de un struct ",(0,r.kt)("inlineCode",{parentName:"p"},"Lazy")," hace que el struct de storage en el cual ese campo aparezca tambi\xe9n sea non-",(0,r.kt)("inlineCode",{parentName:"p"},"Packed"),", evitando que sea cargado anticipadamente durante operaciones de storage arbitrarias:"),(0,r.kt)("div",{class:"schema"},(0,r.kt)("img",{src:"/img/storage-layout.svg",alt:"Organizaci\xf3n del storage: estructura con un campo lazy"})),(0,r.kt)("p",null,"Tener en cuenta que en la ilustraci\xf3n de arriba, la key ",(0,r.kt)("inlineCode",{parentName:"p"},"0x12345678")," s\xf3lo sirve como ejemplo, aprenderemos m\xe1s sobre c\xe1lculo de storage key\n",(0,r.kt)("a",{parentName:"p",href:"/datastructures/storage-layout#generaci%C3%B3n-de-key-manual-vs-autom%C3%A1tica"},"en este cap\xedtulo"),"."),(0,r.kt)("p",null,"El siguiente ejemplo demuestra c\xf3mo podemos resolver el problema presentado en la secci\xf3n anterior. Se ver\xe1 que para el campo de storage cargado de manera lazy, ahora trabajamos con getters y setters para tener acceso y modificar el valor de storage interno:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#![cfg_attr(not(feature = "std"), no_std)]\n\n#[ink::contract]\nmod mycontract {\n    use ink::prelude::vec::Vec;\n    use ink::storage::Lazy;\n\n    #[derive(Default)]\n    #[ink(storage)]\n    pub struct MyContract {\n        tiny_value: Balance,\n        /// Este vector puede volverse grande y caro para utilizarlo.\n        /// Queremos forzar una estructura de storage non-`Packed`\n        large_vec: Lazy<Vec<Balance>>,\n    }\n\n    impl MyContract {\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        /// Este mensaje siempre es barato ya que `large_vec` es cargado de forma lazy.\n        #[ink(message)]\n        pub fn get_balance(&self) -> Balance {\n            self.tiny_value\n        }\n\n        /// Los campos lazy como `large_vec` proveen los operadores de storage `get()` y `set()`. \n        #[ink(message)]\n        pub fn add_balance(&mut self, value: Balance) {\n            let mut balances = self.large_vec.get_or_default();\n            balances.push(value);\n            self.large_vec.set(&balances);\n        }\n    }\n}\n')),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Los ",(0,r.kt)("inlineCode",{parentName:"p"},"ink::prelude::vec::Vec")," son siempre cargados en su totalidad. Esto sucede porque todos los elementos del ",(0,r.kt)("inlineCode",{parentName:"p"},"ink::prelude::vec::Vec")," existen en una sola storage key. Si se envuelve el ",(0,r.kt)("inlineCode",{parentName:"p"},"ink::prelude::vec::Vec")," dentro del ",(0,r.kt)("inlineCode",{parentName:"p"},"Lazy"),", como muestra el ejemplo de arriba, no tiene influencia en su estructura interior. Si se est\xe1 tratando con arrays grandes o dispersos en storage de contratos, se deber\xeda considerar usar un ",(0,r.kt)("inlineCode",{parentName:"p"},"Mapping")," en cambio.")),(0,r.kt)("h2",{id:"generaci\xf3n-de-key-manual-vs-autom\xe1tica"},"Generaci\xf3n de key Manual vs. Autom\xe1tica"),(0,r.kt)("p",null,"Por defecto, las keys son calculadas autom\xe1ticamente, gracias a la primitiva ",(0,r.kt)("a",{parentName:"p",href:"https://docs.rs/ink_storage_traits/4.0.0/ink_storage_traits/struct.AutoKey.html"},(0,r.kt)("inlineCode",{parentName:"a"},"AutoKey")),". Estas ser\xe1n generadas en tiempo de compilaci\xf3n y descartadas de conflictos.\nSin embargo, para tipos non-",(0,r.kt)("inlineCode",{parentName:"p"},"Packed")," como ",(0,r.kt)("inlineCode",{parentName:"p"},"Lazy")," o ",(0,r.kt)("inlineCode",{parentName:"p"},"Mapping"),", la primitiva ",(0,r.kt)("a",{parentName:"p",href:"https://docs.rs/ink_storage_traits/4.0.0/ink_storage_traits/struct.ManualKey.html"},(0,r.kt)("inlineCode",{parentName:"a"},"ManualKey"))," permite un control manual sobre la storage key de un campo, as\xed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[ink(storage)]\npub struct MyContract {\n    /// La storage key para este campo siempre es `0x0000007f`\n    inner: Lazy<bool, ManualKey<127>>,\n}\n")),(0,r.kt)("p",null,"Esto puede ser ventajoso: Su key de storage ser\xe1 siempre la misma, independientemente de la versi\xf3n de su contrato o de ink! en s\xed mismo (Tenga en cuenta que el algoritmo de c\xe1lculo de la key puede cambiar con futuras versiones de ink!)."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"El uso de una ",(0,r.kt)("inlineCode",{parentName:"p"},"ManualKey")," en vez de una ",(0,r.kt)("inlineCode",{parentName:"p"},"AutoKey")," puede ser espec\xedficamente deseable para contratos actualizables, ya que usar ",(0,r.kt)("inlineCode",{parentName:"p"},"AutoKey")," puede resultar en una storage key diferente para el mismo campo en una nueva versi\xf3n de contrato. Esto puede romper su contrato luego de una actualizaci\xf3n \ud83d\ude31!")),(0,r.kt)("p",null,"La key del storage de la struct del storage ra\xedz del contrato tiene como valor default ",(0,r.kt)("inlineCode",{parentName:"p"},"0x00000000"),". Sin embargo, los desarrolladores pueden definir la key como un valor arbitrario de 4 bytes al proveer una ",(0,r.kt)("inlineCode",{parentName:"p"},"ManualKey")," as\xed: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"/// Definici\xf3n manual de la root storage key de `MyContract` para que sea `0xcafebabe`.\n#[ink(storage)]\npub struct MyContract<KEY: StorageKey = ManualKey<0xcafebabe>> {\n    value: bool,\n}\n")),(0,r.kt)("h2",{id:"consideraciones"},"Consideraciones"),(0,r.kt)("p",null,"Ser\xeda conveniente pensar cual es la estructura de storage deseada para un contrato. Si usamos una estructura ",(0,r.kt)("inlineCode",{parentName:"p"},"Packed")," se mantendr\xe1 el tama\xf1o del c\xf3digo general del contrato m\xe1s peque\xf1o lo cual puede ocasionar altos costos de gas innecesarios. Por lo tanto, consideramos una buena pr\xe1ctica dividir estructuras de storage grandes o complejas en distintas celdas de storage de tama\xf1o razonable."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Los ",(0,r.kt)("inlineCode",{parentName:"p"},"Mapping")," de ink! son siempre non-",(0,r.kt)("inlineCode",{parentName:"p"},"Packed")," y cargados de manera lazy, un par key-value por vez.")))}p.isMDXComponent=!0}}]);