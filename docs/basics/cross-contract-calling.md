---
title: Cross-Contract Calling
slug: /basics/cross-contract-calling
hide_title: true
---

![Cross Contract Title Picture](/img/title/cross-contract.svg)

# Cross-Contract Calls

In ink! contracts it is possible to call messages and constructors of other
on-chain contracts.

There are a few approaches to performing these cross-contract calls in ink!:
1. Contract references (i.e `ContractRef`)
2. Builders (i.e `CreateBuilder` and `CallBuilder`)

:::note
In general, contract references should be preferred over builders 
because they provide higher-level type-safe interfaces.
Only use builders if you need to manipulate low-level call parameters.
:::

## Contract References

Contract references are wrapper types that can be used for interacting with an on-chain/"callee" contract
using a high-level type-safe interface.

They are either statically generated by the ink! code generation (for contract dependencies),
or they can be manually defined as dynamic interfaces using the [`#[ink::contract_ref]` attribute][contract-ref-attr].

[contract-ref-attr]: ../reference/macros-attributes/contract_ref.md

### Statically generated contract references

To use statically generated contract references, you need to import the contract
you want to call as a dependency of your own contract.

:::note
This means that this approach cannot be used if you want to interact with a contract
that is either built in another language (e.g. Solidity), or has no publicly available package/crate.

For [calling Solidity Contracts][call-sol] you will need to use either [manually defined contract references][manual-contract-ref] using the [`#[ink::contract_ref]` attribute][contract-ref-attr] (recommended),
or the [`Builders`](#builders) approach instead.
:::

[call-sol]: ../solidity-interop/calling-solidity-contracts.md
[manual-contract-ref]: #manually-defined-contract-references

#### **BasicContractRef walkthrough**

This walkthrough uses the [`cross-contract-calls`][example] example to illustrate 
how contract references enable cross-contract calls.

The general workflow will be:
1. Import `OtherContract` into `BasicContractRef`
2. Call `OtherContract` using `BasicContractRef`

[example]: https://github.com/use-ink/ink-examples/tree/master/cross-contract-calls

#### **Importing `OtherContract`**

We need to import `OtherContract` to our `BasicContractRef` contract.

First, we add the following lines to our `Cargo.toml` file:

```toml
# In `basic_contract_ref/Cargo.toml`

other_contract = { path = "other_contract", default-features = false, features = ["ink-as-dependency"] }

# -- snip --

[features]
default = ["std"]
std = [
    "ink/std",
    # -- snip --
    "other_contract/std",
]
```

Two things to note here:
1. If we don't specify the `ink-as-dependency` feature we will end up with linking
   errors.
2. If we don't enable the `std` feature for `std` builds we will not be able to generate
   our contract's metadata.

#### **Wiring `BasicContractRef`**

First, we will import the contract reference of `OtherContract`, and declare the
reference to be part of our storage struct.

```rust
// In `basic_contract_ref/lib.rs`

use other_contract::OtherContractRef;

#[ink(storage)]
pub struct BasicContractRef {
    other_contract: OtherContractRef,
}
```

Next, we will store the address of an instance of `OtherContract`. 
We do this from the constructor of our of contract.

```rust
// In `basic_contract_ref/lib.rs`

#[ink(constructor)]
pub fn new(other_contract_address: ink::Address) -> Self {
    let other_contract = OtherContractRef::from(other_contract_address);
    Self { other_contract }
}
```

Once we have a contract reference to `OtherContract` we can call its messages just
like normal Rust methods!

```rust
// In `basic_contract_ref/lib.rs`

#[ink(message)]
pub fn flip_and_get(&mut self) -> bool {
    self.other_contract.flip();
    self.other_contract.get()
}
```

#### **Instantiating `BasicContractRef` with an address for `OtherContract`**

We will first need to instantiate `BasicContractRef`.
We will need an address to an instance of `OtherContract` that is already on-chain
(i.e. a `20` bytes [`pallet-revive` address][address] like `0xd051d56ffc5077e006d1fdb14a2311276873aa86`).

[address]: https://use-ink.github.io/ink/ink/type.Address.html

:::note
For the next steps, you will either need the [`ink-node`][ink-node] running in the background, 
otherwise you'll need to provide the url of your target node.
For the latter, see the instructions for [deploying to `Passet Hub Testnet`][passet-hub-deploy] as an example.
:::

[ink-node]: https://github.com/use-ink/ink-node
[passet-hub-deploy]: ../getting-started/deploying.md#deploying-to-passet-hub-testnet

```
# In the `basic_contract_ref` directory
cargo contract build --release
cargo contract instantiate \
    --constructor new \
    --args 0xd051d56ffc5077e006d1fdb14a2311276873aa86 \
    --suri //Alice --salt $(date +%s) \
    -x
```

If successful, this will output in a contract address for `BasicContractRef` similar to:

```
Contract 0x427b4c31ce5cdc19ec19bc9d2fb0e22ba69c84c3
```

#### **Calling `OtherContract` through `BasicContractRef`**

Finally, we can call the `OtherContract` methods through `BasicContractRef` as follows:

```
cargo contract call --contract 0x427b4c31ce5cdc19ec19bc9d2fb0e22ba69c84c3 \
    --message flip_and_get --suri //Alice --dry-run
```

Which will result in something like:

```
Result Ok(true)
Reverted false
```

### Manually defined contract references

See our section on using the [`#[ink::contract_ref]` attribute][contract-ref-attr]
for a detailed description and examples of how to manually define the dynamic interface
for an on-chain/"callee" contract, and use the generated contract reference
for calling the on-chain/"callee" contract in a type-safe manner.

:::caution
A downside to manually defined contract references is that mistakes
in the interface definition are not caught at compile-time.

It's therefore important to make sure such interfaces are properly tested
using [end-to-end testing][e2e-test] before contracts are deployed on-chain.
:::

[e2e-test]: ../development/testing/e2e.md

## Builders
The [`CreateBuilder`][create-builder] and [`CallBuilder`][call-builder]
offer low-level, flexible interfaces for performing cross-contract calls. 
The `CreateBuilder` allows you to instantiate already uploaded contracts, 
and the `CallBuilder` allows you to call messages on instantiated contracts.

[create-builder]: https://use-ink.github.io/ink/ink_env/call/struct.CreateBuilder.html
[call-builder]: https://use-ink.github.io/ink/ink_env/call/struct.CallBuilder.html

:::caution
A downside to low-level `CreateBuilder`s and `CallBuilder`s is that mistakes 
in the generated calls (e.g. wrong selectors, wrong order and/or types of arguments e.t.c) 
are not caught at compile-time.

It's therefore important to make sure such calls are properly tested
using [end-to-end testing][e2e-test] before contracts are deployed on-chain.
:::

### CreateBuilder
The `CreateBuilder` offers an easy way for you to **instantiate** a contract. 
Note that you'll still need this contract to have been previously uploaded.

:::note
For a refresher on the difference between `upload` and `instantiate`
[see here](../getting-started/deploying.md).
:::

In order to instantiate a contract you need a reference to your contract, just like in
[the previous section](#contract-references).

Below is an example of how to instantiate a contract using the `CreateBuilder`. We will:
- instantiate the uploaded contract with a `code_hash` of `0x4242...`
- with no gas limit specified (`0` means unlimited)
- sending `10` units of transferred value to the contract instance
- instantiating with the `new` constructor
- with the following arguments
    - a `u8` with value `42`
    - a `bool` with value `true`
    - an array of 32 `u8` with value `0x10`
- generate the address (`AccountId`) using the specified `salt_bytes`
- and we expect it to return a value of type `MyContractRef`

```rust
use contract::MyContractRef;
let my_contract: MyContractRef = build_create::<MyContractRef>()
    .code_hash(Hash::from([0x42; 32]))
    .ref_time_limit(0)
    .endowment(10)
    .exec_input(
        ExecutionInput::new(Selector::new(ink::selector_bytes!("new")))
            .push_arg(42)
            .push_arg(true)
            .push_arg(&[0x10u8; 32])
    )
    .salt_bytes(&[0xDE, 0xAD, 0xBE, 0xEF])
    .returns::<MyContractRef>()
    .instantiate();
```

Since `CreateBuilder::instantiate()` returns a contract reference, we can use this
contract reference to call messages just like in the
[previous section](#contract-references).

:::note
To instantiate a Solidity ABI contract, see [Calling Solidity Contracts](../solidity-interop/calling-solidity-contracts.md).
:::

### CallBuilder
The `CallBuilder` gives you a couple of ways to call messages from other contracts. There
are two main approaches to this: `Call`s and `DelegateCall`s. We will briefly cover both
here.

#### **CallBuilder: Call**
When using `Call`s the `CallBuilder` requires an already instantiated contract.

We saw an example of how to use the `CreateBuilder` to instantiate contracts in the
[previous section](#contract-references).

Below is an example of how to call a contract using the `CallBuilder`. We will:
- make a regular `Call`
- to a contract at the address `0x4242...`
- with no gas limit specified (`0` means unlimited)
- sending `10` units of transferred value to the contract instance
- calling the `flip` message
- with the following arguments
    - a `u8` with value `42`
    - a `bool` with value `true`
    - an array of 32 `u8` with value `0x10`
- and we expect it to return a value of type `bool`

```rust
let my_return_value = build_call::<DefaultEnvironment>()
    .call(H160::from([0x42; 20]))
    .ref_time_limit(0)
    .transferred_value(10)
    .exec_input(
        ExecutionInput::new(Selector::new(ink::selector_bytes!("flip")))
            .push_arg(42u8)
            .push_arg(true)
            .push_arg(&[0x10u8; 32])
    )
    .returns::<bool>()
    .invoke();
```

:::caution
Message arguments will be encoded in the order in which they are provided to the `CallBuilder`.
This means that they should match the order (and type) they appear in the function
signature.

You will not get any feedback about this at compile-time, 
so it's important to make sure such calls are properly tested
with [end-to-end testing][e2e-test] before contracts are deployed on-chain.
:::

:::note
To call Solidity ABI-encoded contracts, see [Calling Solidity Contracts](../solidity-interop/calling-solidity-contracts.md).
:::

#### **CallBuilder: Delegate Call**
You can also use the `CallBuilder` to craft calls using `DelegateCall` mechanics.
If you need a refresher on what delegate calls are,
[see this article](https://medium.com/coinmonks/delegatecall-calling-another-contract-function-in-solidity-b579f804178c).

In the case of `DelegateCall`s, we don't require an already instantiated contract.
We only need the `code_hash` of an uploaded contract.

Below is an example of how to delegate call a contract using the `CallBuilder`. We will:
- make a `DelegateCall`
- to a contract with a `code_hash` (not contract address!) of `0x4242...`
- calling the `flip` message
- with the following arguments
    - a `u8` with value `42`
    - a `bool` with value `true`
    - an array of 32 `u8` with value `0x10`
- and we expect it to return an `i32`

```rust
let my_return_value = build_call::<DefaultEnvironment>()
    .delegate(H160::from([0x42; 20]))
    .exec_input(
        ExecutionInput::new(Selector::new(ink::selector_bytes!("flip")))
            .push_arg(42u8)
            .push_arg(true)
            .push_arg(&[0x10u8; 32])
    )
    .returns::<i32>()
    .invoke();
```

### Builder Error Handling
The `CreateBuilder` and the `CallBuilder` both offer error handling with the
`try_instantiate()` and `try_invoke()` methods respectively.

These allow contract developers to handle two types of errors:
1. Errors from the underlying execution environment (e.g the Contracts pallet)
2. Error from the programming language (e.g `LangError`s)

See the documentation for
[`try_instantiate`](https://use-ink.github.io/ink/ink_env/call/struct.CreateBuilder.html#method.try_instantiate),
[`try_invoke`](https://use-ink.github.io/ink/ink_env/call/struct.CallBuilder.html#method.try_invoke-2),
[`ink::env::Error`](https://use-ink.github.io/ink/ink_env/enum.Error.html)
and
[`ink::LangError`](https://use-ink.github.io/ink/ink/enum.LangError.html)
for more details on proper error handling.