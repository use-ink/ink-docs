"use strict";(self.webpackChunkink_docs=self.webpackChunkink_docs||[]).push([[3484],{40831:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>l});var r=n(74848),s=n(28453);const a={title:"Upgradeable Contracts",slug:"/basics/upgradeable-contracts"},o=void 0,i={id:"basics/upgradeability",title:"Upgradeable Contracts",description:"Even though smart contracts are intended to be immutable by design,",source:"@site/versioned_docs/version-3.x/basics/upgradeability.md",sourceDirName:"basics",slug:"/basics/upgradeable-contracts",permalink:"/3.x/basics/upgradeable-contracts",draft:!1,unlisted:!1,editUrl:"https://github.com/paritytech/ink-docs/edit/master/versioned_docs/version-3.x/basics/upgradeability.md",tags:[],version:"3.x",frontMatter:{title:"Upgradeable Contracts",slug:"/basics/upgradeable-contracts"},sidebar:"reference",previous:{title:"Cross-Contract Calling",permalink:"/3.x/basics/cross-contract-calling"},next:{title:"Contract Testing",permalink:"/3.x/basics/contract-testing"}},c={},l=[{value:"Proxy Forwarding",id:"proxy-forwarding",level:2},{value:"Properties",id:"properties",level:3},{value:"Replacing Contract Code with <code>set_code_hash()</code>",id:"replacing-contract-code-with-set_code_hash",level:2},{value:"Properties",id:"properties-1",level:3},{value:"Storage Compatibility",id:"storage-compatibility",level:3},{value:"A little note on the determinism of contract addresses",id:"a-little-note-on-the-determinism-of-contract-addresses",level:3},{value:"Examples",id:"examples",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:"Even though smart contracts are intended to be immutable by design,\nit is often necessary to perform an upgrade of a smart contract."}),"\n",(0,r.jsx)(t.p,{children:"The developer may need to fix a critical bug or introduce a new feature."}),"\n",(0,r.jsx)(t.p,{children:"For this type of scenario, ink! has different upgrade strategies."}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"#proxy-forwarding",children:"Proxy Forwarding"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#properties",children:"Properties"})}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsxs)(t.a,{href:"#replacing-contract-code-with-set_code_hash",children:["Replacing Contract Code with ",(0,r.jsx)(t.code,{children:"set_code_hash()"})]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#properties-1",children:"Properties"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#storage-compatibility",children:"Storage Compatibility"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#a-little-note-on-the-determinism-of-contract-addresses",children:"A little note on the determinism of contract addresses"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#examples",children:"Examples"})}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"proxy-forwarding",children:"Proxy Forwarding"}),"\n",(0,r.jsx)(t.p,{children:"This method relies on the ability of contracts to proxy calls to other contracts."}),"\n",(0,r.jsx)(t.h3,{id:"properties",children:"Properties"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Forwards any call that does not match a selector of itself to another contract."}),"\n",(0,r.jsx)(t.li,{children:"The other contract needs to be deployed on-chain."}),"\n",(0,r.jsx)(t.li,{children:"State is stored in the storage of the contract to which calls are forwarded."}),"\n"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"User ---- tx ---\x3e Proxy ----------\x3e Implementation_v0\n                     |\n                      ------------\x3e Implementation_v1\n                     |\n                      ------------\x3e Implementation_v2\n"})}),"\n",(0,r.jsx)(t.p,{children:"Our proxy contract will have these 2 storage fields:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"#[ink(storage)]\npub struct Proxy {\n    /// The `AccountId` of a contract where any call that does not match a\n    /// selector of this contract is forwarded to.\n    forward_to: AccountId,\n    /// The `AccountId` of a privileged account that can update the\n    /// forwarding address. This address is set to the account that\n    /// instantiated this contract.\n    admin: AccountId,\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"We then need a way to change the address of a contract to which we forward calls to\nand the actual message selector to proxy the call:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:'impl Proxy {\n    /// Changes the `AccountId` of the contract where any call that does\n    /// not match a selector of this contract is forwarded to.\n    #[ink(message)]\n    pub fn change_forward_address(&mut self, new_address: AccountId) {\n        assert_eq!(\n            self.env().caller(),\n            self.admin,\n            "caller {:?} does not have sufficient permissions, only {:?} does",\n            self.env().caller(),\n            self.admin,\n        );\n        self.forward_to = new_address;\n    }\n\n    /// Fallback message for a contract call that doesn\'t match any\n    /// of the other message selectors.\n    ///\n    /// # Note:\n    ///\n    /// - We allow payable messages here and would forward any optionally supplied\n    ///   value as well.\n    /// - If the self receiver were `forward(&mut self)` here, this would not\n    ///   have any effect whatsoever on the contract we forward to.\n    #[ink(message, payable, selector = _)]\n    pub fn forward(&self) -> u32 {\n        ink_env::call::build_call::<ink_env::DefaultEnvironment>()\n            .call_type(\n                Call::new()\n                    .callee(self.forward_to)\n                    .transferred_value(self.env().transferred_value())\n                    .gas_limit(0),\n            )\n            .call_flags(\n                ink_env::CallFlags::default()\n                    .set_forward_input(true)\n                    .set_tail_call(true),\n            )\n            .fire()\n            .unwrap_or_else(|err| {\n                panic!(\n                    "cross-contract call to {:?} failed due to {:?}",\n                    self.forward_to, err\n                )\n            });\n        unreachable!(\n            "the forwarded call will never return since `tail_call` was set"\n        );\n    }\n}\n'})}),"\n",(0,r.jsx)(t.admonition,{type:"tip",children:(0,r.jsxs)(t.p,{children:["Take a look at the selector pattern in the attribute macro: by declaring ",(0,r.jsx)(t.code,{children:"selector = _"}),"\nwe specify that all other messages should be handled by this message selector."]})}),"\n",(0,r.jsx)(t.p,{children:"Using this pattern, you can introduce other message to your proxy contract.\nAny messages that are not matched in the proxy contract\nwill be forwarded to the specified contract address."}),"\n",(0,r.jsxs)(t.h2,{id:"replacing-contract-code-with-set_code_hash",children:["Replacing Contract Code with ",(0,r.jsx)(t.code,{children:"set_code_hash()"})]}),"\n",(0,r.jsxs)(t.p,{children:["Following ",(0,r.jsx)(t.a,{href:"https://docs.substrate.io/maintain/runtime-upgrades/",children:"Substrate's runtime upgradeability"}),"\nphilosophy, ink! also supports an easy way to update your contract code via the special function\n",(0,r.jsx)(t.a,{href:"https://paritytech.github.io/ink/ink_env/fn.set_code_hash.html",children:(0,r.jsx)(t.code,{children:"set_code_hash()"})}),"."]}),"\n",(0,r.jsx)(t.h3,{id:"properties-1",children:"Properties"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Updates the contract code using ",(0,r.jsx)(t.code,{children:"set_code_hash()"}),".\nThis effectively replaces the code which is executed for the contract address."]}),"\n",(0,r.jsx)(t.li,{children:"The other contract needs to be deployed on-chain."}),"\n",(0,r.jsx)(t.li,{children:"State is stored in the storage of the originally instantiated contract."}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Just add the following function to the contract you want to upgrade in the future."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:'/// Modifies the code which is used to execute calls to this contract address (`AccountId`).\n///\n/// We use this to upgrade the contract logic. We don\'t do any authorization here, any caller\n/// can execute this method. In a production contract you would do some authorization here.\n#[ink(message)]\npub fn set_code(&mut self, code_hash: [u8; 32]) {\n    ink_env::set_code_hash(&code_hash).unwrap_or_else(|err| {\n        panic!(\n            "Failed to `set_code_hash` to {:?} due to {:?}",\n            code_hash, err\n        )\n    });\n    ink_env::debug_println!("Switched code hash to {:?}.", code_hash);\n}\n'})}),"\n",(0,r.jsx)(t.h3,{id:"storage-compatibility",children:"Storage Compatibility"}),"\n",(0,r.jsx)(t.p,{children:"It is the developer's responsibility to ensure\nthat the new contract's storage is compatible with the storage of the contract that is replaced."}),"\n",(0,r.jsxs)(t.admonition,{title:"Beware",type:"danger",children:[(0,r.jsx)(t.p,{children:"You should not change the order in which the contract state variables are declared, nor their type!"}),(0,r.jsxs)(t.p,{children:["Violating the restriction will not prevent a successful compilation,\nbut will result in ",(0,r.jsx)(t.strong,{children:"the mix-up of values"})," or ",(0,r.jsx)(t.strong,{children:"failure to read the storage correctly"}),".\nThis can be a result of severe errors in the application utilizing the contract."]})]}),"\n",(0,r.jsx)(t.p,{children:"If the storage of your contract looks like this:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"#[ink(storage)]\npub struct YourContract {\n    x: u32,\n    y: bool,\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["The procedures listed below will make it ",(0,r.jsx)(t.em,{children:(0,r.jsx)(t.strong,{children:"invalid"})})]}),"\n",(0,r.jsx)(t.p,{children:"Changing the order of variables:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"#[ink(storage)]\npub struct YourContract {\n    y: bool,\n    x: u32,\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"Removing an existing variable:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"#[ink(storage)]\npub struct YourContract {\n    x: u32,\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"Changing the type of a variable:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"#[ink(storage)]\npub struct YourContract {\n    x: u64,\n    y: bool,\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"Introducing a new variable before any of the existing ones:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"#[ink(storage)]\npub struct YourContract {\n    z: Vec<u32>,\n    x: u32,\n    y: bool,\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"a-little-note-on-the-determinism-of-contract-addresses",children:"A little note on the determinism of contract addresses"}),"\n",(0,r.jsx)(t.admonition,{type:"note",children:(0,r.jsxs)(t.p,{children:["If your contract utilizes this approach, it no-longer holds a deterministic address assumption.\nYou can no longer assume that a contract address identifies a specific code hash.\nPlease refer to ",(0,r.jsx)(t.a,{href:"https://github.com/paritytech/substrate/pull/10690#issuecomment-1025702389",children:"the issue"}),"\nfor more details."]})}),"\n",(0,r.jsx)(t.h2,{id:"examples",children:"Examples"}),"\n",(0,r.jsxs)(t.p,{children:["Examples of upgradable contracts can be found in the\n",(0,r.jsx)(t.a,{href:"https://github.com/paritytech/ink-examples/tree/main/upgradeable-contracts",children:"ink! repository"})]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>i});var r=n(96540);const s={},a=r.createContext(s);function o(e){const t=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(a.Provider,{value:t},e.children)}}}]);