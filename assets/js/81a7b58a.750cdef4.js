"use strict";(self.webpackChunkink_docs=self.webpackChunkink_docs||[]).push([[6607],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>g});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=n.createContext({}),c=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(r),g=a,m=d["".concat(l,".").concat(g)]||d[g]||u[g]||i;return r?n.createElement(m,o(o({ref:t},p),{},{components:r})):n.createElement(m,o({ref:t},p))}));function g(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=r.length,o=new Array(i);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var c=2;c<i;c++)o[c]=r[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},7786:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var n=r(7462),a=(r(7294),r(3905));const i={title:"Overview",slug:"/datastructures/overview"},o=void 0,s={unversionedId:"datastructures/overview",id:"version-4.0.0-alpha.1/datastructures/overview",title:"Overview",description:"The ink_storage crate acts as the standard storage library for ink! smart contracts. At",source:"@site/versioned_docs/version-4.0.0-alpha.1/datastructures/overview.md",sourceDirName:"datastructures",slug:"/datastructures/overview",permalink:"/4.0.0-alpha.1/datastructures/overview",draft:!1,editUrl:"https://github.com/paritytech/ink-docs/edit/master/versioned_docs/version-4.0.0-alpha.1/datastructures/overview.md",tags:[],version:"4.0.0-alpha.1",frontMatter:{title:"Overview",slug:"/datastructures/overview"},sidebar:"reference",previous:{title:"#[ink::chain_extension]",permalink:"/4.0.0-alpha.1/macros-attributes/chain-extension"},next:{title:"Working with Mapping",permalink:"/4.0.0-alpha.1/datastructures/mapping"}},l={},c=[{value:"Eager Loading",id:"eager-loading",level:2}],p={toc:c};function u(e){let{components:t,...r}=e;return(0,a.kt)("wrapper",(0,n.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"ink_storage")," crate acts as the standard storage library for ink! smart contracts. At\nthe moment it only provides a single low-level primitive for interacting with storage,\nthe ",(0,a.kt)("a",{parentName:"p",href:"https://docs.rs/ink_storage/3.3.1/ink_storage/struct.Mapping.html"},(0,a.kt)("inlineCode",{parentName:"a"},"Mapping")),"."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"Mapping")," is a mapping of key-value pairs directly to the contract storage. Its main advantage\nis to be simple and lightweight. As such, it does not provide any high-level\nfunctionality, such as iteration or automatic clean-up. Smart contract authors will need\nto implement any high level functionality themselves."),(0,a.kt)("h2",{id:"eager-loading"},"Eager Loading"),(0,a.kt)("p",null,"When executing a contract, all the fields of the ",(0,a.kt)("inlineCode",{parentName:"p"},"#[ink(storage)]")," struct will be pulled\nfrom storage, regardless of whether or not they are used during the message execution."),(0,a.kt)("p",null,"Smart contract authors should be aware of this behaviour since it could potentially\naffect their contract performance. For example, consider the following storage struct:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"#[ink(storage)]\npub struct EagerLoading {\n    a: i32,\n    b: ink_prelude::vec::Vec<i32>,\n}\n\nimpl EagerLoading {\n    #[ink(message)]\n    pub fn read_a(&self) {\n        let a = self.a;\n    }\n}\n")),(0,a.kt)("p",null,"In ",(0,a.kt)("inlineCode",{parentName:"p"},"EagerLoading::read_a()")," we only read the ",(0,a.kt)("inlineCode",{parentName:"p"},"a")," storage item. However, the ",(0,a.kt)("inlineCode",{parentName:"p"},"b")," storage\nitem will still be loaded from storage. As a reminder, this means accessing the\nunderlying database and SCALE decoding the value. This can incur high costs, especially\nas the number of elements in ",(0,a.kt)("inlineCode",{parentName:"p"},"b")," grows."),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"Eager loading does ",(0,a.kt)("strong",{parentName:"p"},"not")," apply to ",(0,a.kt)("inlineCode",{parentName:"p"},"Mapping")," fields, though, as key lookups in mappings\nare done directly from contract storage.")))}u.isMDXComponent=!0}}]);