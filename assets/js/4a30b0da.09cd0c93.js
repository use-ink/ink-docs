"use strict";(self.webpackChunkink_docs=self.webpackChunkink_docs||[]).push([[6664],{31924:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"background/lang-comparison","title":"Low-level Rust contracts vs. ink!","description":"Polkadot SDK Precompiles Title Picture","source":"@site/docs/background/lang-comparison.md","sourceDirName":"background","slug":"/background/pallet-revive-low-level-rust-contracts","permalink":"/docs/v6/background/pallet-revive-low-level-rust-contracts","draft":false,"unlisted":false,"editUrl":"https://github.com/use-ink/ink-docs/edit/master/docs/background/lang-comparison.md","tags":[],"version":"current","frontMatter":{"title":"Low-level Rust contracts vs. ink!","hide_title":true,"slug":"/background/pallet-revive-low-level-rust-contracts"},"sidebar":"reference","previous":{"title":"Why RISC-V and PolkaVM for Smart Contracts?","permalink":"/docs/v6/background/why-riscv-and-polkavm-for-smart-contracts"},"next":{"title":"Precompiles","permalink":"/docs/v6/background/precompiles"}}');var r=n(23420),i=n(65404);const o={title:"Low-level Rust contracts vs. ink!",hide_title:!0,slug:"/background/pallet-revive-low-level-rust-contracts"},a="Rust contracts on pallet-revive",l={},c=[{value:"Low-level Rust interface",id:"low-level-rust-interface",level:2},{value:"ink! vs. low-level Rust",id:"ink-vs-low-level-rust",level:2},{value:"ABI Support",id:"abi-support",level:3},{value:"Types",id:"types",level:3},{value:"Developer Ergonomics",id:"developer-ergonomics",level:3},{value:"Datastructures &amp; Storage",id:"datastructures--storage",level:3},{value:"Tooling, Documentation, Support",id:"tooling-documentation-support",level:3},{value:"Build Complexity",id:"build-complexity",level:3},{value:"Allocator &amp; Panic Handling",id:"allocator--panic-handling",level:3},{value:"UI Frameworks",id:"ui-frameworks",level:3},{value:"Testing",id:"testing",level:3},{value:"Cross-contract calls",id:"cross-contract-calls",level:3},{value:"Comparison Table",id:"comparison-table",level:2}];function d(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components},{Head:s}=t;return s||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Head",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(s,{children:[(0,r.jsx)("meta",{name:"description",content:"Comparison of Rust contracts for `pallet-revive`: low-level vs. ink!."}),(0,r.jsx)("meta",{name:"keywords",content:"Rust, ink!, Polkadot SDK, pallet-revive, Smart Contracts"}),(0,r.jsx)("meta",{property:"og:title",content:"Low-level Rust contracts vs. ink!"}),(0,r.jsx)("meta",{property:"og:description",content:"Comparison of Rust contracts for `pallet-revive`: low-level vs. ink!."})]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"Polkadot SDK Precompiles Title Picture",src:n(92184).A+"",width:"1600",height:"500"})}),"\n",(0,r.jsx)(t.header,{children:(0,r.jsxs)(t.h1,{id:"rust-contracts-on-pallet-revive",children:["Rust contracts on ",(0,r.jsx)(t.code,{children:"pallet-revive"})]})}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"pallet-revive"})," supports contracts written in Rust and Solidity. For the PolkaVM (PVM) part of the pallet, Solidity is supported by compiling the source code with Parity's ",(0,r.jsx)(t.a,{href:"https://github.com/paritytech/revive",children:(0,r.jsx)(t.code,{children:"revive"})})," compiler.\nRust is supported by providing a low-level FFI interface and compiling for ",(0,r.jsx)(t.a,{href:"https://github.com/paritytech/polkavm",children:"PolkaVM"}),".\nYou can view the low-level interface ",(0,r.jsx)(t.a,{href:"https://docs.rs/pallet-revive-uapi/latest/pallet_revive_uapi/",children:"here"}),".\nSee ",(0,r.jsxs)(t.a,{href:"https://docs.rs/pallet-revive-uapi/latest/pallet_revive_uapi/trait.HostFn.html",children:["the ",(0,r.jsx)(t.code,{children:"HostFn"})," trait"]})," for\nfunctions exposed to smart contracts."]}),"\n",(0,r.jsx)(t.h2,{id:"low-level-rust-interface",children:"Low-level Rust interface"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"pallet-revive"}),"'s low-level Rust interface can be used to write contracts, those\nwill be very low-level though with developers having to take care\nof everything by themselves. In this section we'll explain what \"everything\" implies."]}),"\n",(0,r.jsx)(t.p,{children:"We believe a fitting comparison is the analogy of writing a web application in something\nlike Ruby on Rails vs  C, crafting your own HTTP responses\nand doing byte-level manipulation."}),"\n",(0,r.jsx)(t.p,{children:'There are certainly niches where "going low" makes sense, but due to the complexity,\nthe overwhelming majority of developers will neither want nor need to use it.\nIt\'s certainly not a way that can be recommended to newcomers\nor as a general approach.\nFor Polkadot SDK natives: this would be similar to developing a parachain\nwithout FRAME.'}),"\n",(0,r.jsxs)(t.p,{children:["Nevertheless, it's interesting and examples of such low-level contracts\ncan be found in ",(0,r.jsxs)(t.a,{href:"https://github.com/paritytech/polkadot-sdk/tree/master/substrate/frame/revive/fixtures/contracts",children:["the ",(0,r.jsx)(t.code,{children:"pallet-revive"})," fixtures directory"]}),".\nAnother cool example is the ",(0,r.jsx)(t.a,{href:"https://github.com/lovelaced/nightmarket/tree/master",children:(0,r.jsx)(t.code,{children:"nightmarket"})}),"\nproject, written entirely in low-level Rust for ",(0,r.jsx)(t.code,{children:"pallet-revive"}),"."]}),"\n",(0,r.jsx)(t.h2,{id:"ink-vs-low-level-rust",children:"ink! vs. low-level Rust"}),"\n",(0,r.jsxs)(t.p,{children:["ink! is a toolkit to make the development of Rust smart contracts for ",(0,r.jsx)(t.code,{children:"pallet-revive"}),'\neasy and efficient.\nTo highlight some key abstractions that make smart contract development much easier\nthan with "plain" Rust:']}),"\n",(0,r.jsx)(t.h3,{id:"abi-support",children:"ABI Support"}),"\n",(0,r.jsxs)(t.p,{children:["ink! supports two ABIs: ",(0,r.jsx)(t.a,{href:"/docs/v6/solidity-interop/use-ink-with-solidity-abi",children:"Solidity"})," and\n",(0,r.jsx)(t.a,{href:"/docs/v6/basics/metadata",children:"our own ABI format"}),", which uses SCALE."]}),"\n",(0,r.jsx)(t.p,{children:"Support for the Solidity ABI means you can interact with ink! contracts as if\nthey were Solidity contracts. You can cross-contract call them or use them with\nMetaMask or Hardhat."}),"\n",(0,r.jsx)(t.p,{children:"Our custom ABI uses the Polkadot native SCALE encoding, which makes it highly efficient.\nThe Solidity ABI encoding is bloated and not Polkadot native. By using SCALE,\nink! contracts play well with Polkadot-native tooling and libraries (PAPI, polkadot-js, \u2026)."}),"\n",(0,r.jsx)(t.p,{children:"If you write low-level Rust contracts, you will not have any ABI support or dispatching\nlogic whatsoever. This means, you'll have to handcraft on your own how your contract\nis called and how it reacts to that. Building a frontend for your contract will require\nyou to build the logic for calling the contract by yourself."}),"\n",(0,r.jsx)(t.h3,{id:"types",children:"Types"}),"\n",(0,r.jsxs)(t.p,{children:["We've baked the classic Polkadot SDK types for ",(0,r.jsx)(t.code,{children:"Balance"}),", ",(0,r.jsx)(t.code,{children:"AccountId"}),", etc. into ink!\n(",(0,r.jsx)(t.a,{href:"/docs/v6/basics/chain-environment-types",children:"see here for how"}),").\nFor developers coming from parachain development, ink! will feel natural and they'll\nrecognize the same guiding principles."]}),"\n",(0,r.jsxs)(t.p,{children:["ink! provides a high-level type system built directly on top of Rust\u2019s own type system.\nThis means you can use enums, structs, generics, traits, associated types, iterators, ",(0,r.jsx)(t.code,{children:"Result"}),",\npattern matching, and all other expressive features that Rust offers in a smart contract context.\nYou can use any struct, tuple, etc. that supports SCALE encoding in events, storage, as function arguments,\nas return types, etc."]}),"\n",(0,r.jsx)(t.p,{children:"ink! automatically derives the logic for encoding, decoding, allocating, storing, and\nloading these types from contract storage."}),"\n",(0,r.jsxs)(t.p,{children:["In contrast, low-level Rust contracts using the raw ",(0,r.jsx)(t.code,{children:"pallet-revive"})," FFI have ",(0,r.jsx)(t.em,{children:"no type support at all"}),".\nAll values (arguments, return values, storage items) must be manually serialized and\ndeserialized. It is entirely up to you to ensure that your types remain consistent over time.\nYou also need to design your own storage layout and perform manual byte-level manipulation."]}),"\n",(0,r.jsx)(t.p,{children:"This leads to a large surface area for subtle bugs, broken upgrades, and ABI mismatches."}),"\n",(0,r.jsx)(t.h3,{id:"developer-ergonomics",children:"Developer Ergonomics"}),"\n",(0,r.jsx)(t.p,{children:"ink! focuses on reducing boilerplate: macros generate dispatch code, storage bindings,\nevents, constructors, metadata, error handling, and typed interfaces for cross-contract calls.\nYou write Rust code while ink! expands the complex parts for you."}),"\n",(0,r.jsx)(t.p,{children:"This starts with simple things like constructors"}),"\n",(0,r.jsx)(t.p,{children:"Pure Rust contracts must implement all of these things manually:\nYou must define your own entrypoints, argument parsers, dispatch tables, error codes, and\nmetadata. Even simple tasks such as emitting events or reading a storage value become\ncomplex and require multiple lines of low-level code."}),"\n",(0,r.jsx)(t.p,{children:"This slows down development dramatically and increases the likelihood of bugs."}),"\n",(0,r.jsx)(t.h3,{id:"datastructures--storage",children:"Datastructures & Storage"}),"\n",(0,r.jsxs)(t.p,{children:["ink! provides high-level, contract-optimized datastructures such as\n",(0,r.jsx)(t.a,{href:"../datastructures/mapping/",children:(0,r.jsx)(t.code,{children:"Mapping"})}),",\n",(0,r.jsx)(t.a,{href:"../datastructures/storage-layout/#eager-loading-vs-lazy-loading",children:(0,r.jsx)(t.code,{children:"Lazy"})}),",\n",(0,r.jsx)(t.a,{href:"../datastructures/storagevec/",children:(0,r.jsx)(t.code,{children:"StorageVec"})}),", and others built specifically for smart-contract workloads.\nThey automatically handle storage layout, lazy loading, SCALE encoding, hashing, and key derivation."]}),"\n",(0,r.jsxs)(t.p,{children:["These data structures expose an idiomatic Rust interface, mimicking the APIs\nfound in Rust's ",(0,r.jsx)(t.code,{children:"std::collections"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["Low-level Rust contracts provide ",(0,r.jsx)(t.strong,{children:"no datastructures whatsoever"}),".\nYou must define your own storage layout and manually read and write byte slices to storage.\nBread and butter data structures (like maps) require full custom implementations, including\nall serialization concerns."]}),"\n",(0,r.jsx)(t.h3,{id:"tooling-documentation-support",children:"Tooling, Documentation, Support"}),"\n",(0,r.jsx)(t.p,{children:"ink! comes with comprehensive documentation:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"This developer portal"}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://github.com/use-ink/ink-examples",children:"Contract example collection"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://docs.rs/ink_storage/6.0.0-beta.1/ink_storage/",children:"API references"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"/tutorials/guide",children:"Tutorials"})}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["For low-level Rust on ",(0,r.jsx)(t.code,{children:"pallet-revive"})," there is ",(0,r.jsx)(t.strong,{children:"no dedicated documentation, guides, or tooling"}),"\nbeyond the raw FFI functions.\nDevelopers must construct their own workflows for compilation, deployment, metadata definition,\ndebugging, and verification. There is no support group for any of that, whereas for ink! there\nis ",(0,r.jsx)(t.a,{href:"https://t.me/inkathon",children:"an active Telegram channel"})," with over 370 members and\n",(0,r.jsx)(t.a,{href:"https://substrate.stackexchange.com/",children:"Substrate Stack Exchange"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["ink! is supported by sophisticated tooling such as ",(0,r.jsx)(t.code,{children:"cargo-contract"})," and ",(0,r.jsx)(t.code,{children:"pop-cli"}),",\nthe ink! analyzer, phink! (a ",(0,r.jsx)(t.a,{href:"https://github.com/srlabs/phink",children:"fuzzer by SRLabs"}),"),\ntype bindings for polkadot-js, PAPI, dedot, and other established libraries."]}),"\n",(0,r.jsx)(t.h3,{id:"build-complexity",children:"Build Complexity"}),"\n",(0,r.jsxs)(t.p,{children:["For low-level Rust, developers must use nightly Rust (or ",(0,r.jsx)(t.code,{children:"RUSTC_BOOTSTRAP"}),") and ",(0,r.jsx)(t.code,{children:"cargo"}),"'s\nunstable ",(0,r.jsx)(t.code,{children:"build-std"})," features to build for the custom PolkaVM target.\nThere's a lot of complexity there that ink!'s ",(0,r.jsx)(t.code,{children:"cargo-contract"})," takes care of, including\nsetting sensible defaults for release builds for our smart contract context."]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"rustc"})," for example defaults to silent overflows for release builds, while ",(0,r.jsx)(t.code,{children:"cargo-contract"}),"\nchanges that behavior to panicking on overflow.\nIn fact, the history of providing overflow safety in ink! is a good example of this complexity:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://github.com/use-ink/cargo-contract/issues/2115",children:"https://github.com/use-ink/cargo-contract/issues/2115"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://github.com/use-ink/cargo-contract/pull/2116",children:"https://github.com/use-ink/cargo-contract/pull/2116"})}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"allocator--panic-handling",children:"Allocator & Panic Handling"}),"\n",(0,r.jsxs)(t.p,{children:["When developers are not using ink! for writing Rust smart contracts on ",(0,r.jsx)(t.code,{children:"pallet-revive"}),",\nthey are expected to bring their own low-level components, like the panic handler and allocator.\nink! provides sensible defaults for a smart contract context for those.\nThe panic handling is tied into the way how debugging works in ",(0,r.jsx)(t.code,{children:"pallet-revive"}),".\nThe ink! allocator is a bump allocator that never frees up space, as that would be unnecessary\noverhead for smart contracts."]}),"\n",(0,r.jsx)(t.h3,{id:"ui-frameworks",children:"UI Frameworks"}),"\n",(0,r.jsx)(t.p,{children:"ink! contracts can be used directly with existing Polkadot UI stacks such as polkadot-js, PAPI,\ndedot, Substrate Connect, or custom TypeScript frameworks that rely on SCALE metadata."}),"\n",(0,r.jsxs)(t.p,{children:["Furthermore, there are custom tools around ink!, like ",(0,r.jsx)(t.a,{href:"https://inkathon.xyz/",children:"inkathon.xyz"}),",\nwhich has become the go-to tool for rapid prototyping and hackathons."]}),"\n",(0,r.jsx)(t.p,{children:"Because ink! generates complete metadata, frontends can introspect message signatures, events,\nstorage items, and types without any manual work."}),"\n",(0,r.jsxs)(t.p,{children:["Pure Rust contracts expose ",(0,r.jsx)(t.strong,{children:"no metadata"}),", so no UI framework can interact with them by default.\nBuilding a frontend requires hand-crafted encoding/decoding logic, manual ABI definitions, and\ncustom integration layers. No automatic type generation is possible."]}),"\n",(0,r.jsx)(t.h3,{id:"testing",children:"Testing"}),"\n",(0,r.jsx)(t.p,{children:"ink! provides an E2E testing environment, entirely in Rust. This means you\ncan test interactions with your contract and make assertions for the resulting\nstate, events, balances, etc.\nThe E2E testing framework can even be used to fuzz-test your contract!"}),"\n",(0,r.jsxs)(t.p,{children:["Low-level Rust contracts have ",(0,r.jsx)(t.strong,{children:"no testing framework"}),".\nYou must implement your own simulated environment or write integration tests that call into\ncompiled RISC-V bytecode manually. This means substantially more work and minimal safety guarantees."]}),"\n",(0,r.jsx)(t.h3,{id:"cross-contract-calls",children:"Cross-contract calls"}),"\n",(0,r.jsx)(t.p,{children:"ink! offers a type-safe cross-contract calling system where Rust traits can be used to specify\ncontract interface to either Solidity or ink! contracts.\nink! automatically generates the bindings, ABI selectors, SCALE encoding logic, error types,\nand call wrappers based on those traits. Through that you get strong typing: if you are trying\nto use the wrong type during cross-contract calls, the compiler will catch it."}),"\n",(0,r.jsx)(t.p,{children:"Pure Rust contracts must build cross-contract calls manually: encoding arguments, constructing\nselectors, decoding return values, and performing error handling. None of this is type-checked,\nand a single mismatched byte can cause the call to fail silently."}),"\n",(0,r.jsx)(t.h2,{id:"comparison-table",children:"Comparison Table"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{}),(0,r.jsx)(t.th,{children:"ink!"}),(0,r.jsx)(t.th,{children:"Pure Rust"}),(0,r.jsx)(t.th,{children:"Solidity"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"Language"})}),(0,r.jsx)(t.td,{children:"Rust (safe, statically typed) with ink! macros for higher-level abstractions"}),(0,r.jsx)(t.td,{children:"Rust (no macros or framework)"}),(0,r.jsx)(t.td,{children:"Solidity (purpose-built for smart contracts)"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"Safety Model"})}),(0,r.jsx)(t.td,{children:"Rust guarantees (ownership, no nulls, memory safety, \u2026)"}),(0,r.jsx)(t.td,{children:"Rust safety, but high bug risk due to DIY framework (e.g. for storage interactions)"}),(0,r.jsx)(t.td,{children:"Manual safety patterns; reentrancy common"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"Tooling"})}),(0,r.jsxs)(t.td,{children:[(0,r.jsx)(t.code,{children:"cargo-contract"}),", ",(0,r.jsx)(t.a,{href:"https://marketplace.visualstudio.com/items?itemName=ink-analyzer.ink-analyzer",children:"ink! analyzer"}),", ",(0,r.jsx)(t.a,{href:"https://github.com/r0gue-io/pop-cli",children:(0,r.jsx)(t.code,{children:"pop-cli"})}),", ",(0,r.jsx)(t.a,{href:"https://github.com/srlabs/phink",children:"phink!"}),", \u2026"]}),(0,r.jsx)(t.td,{children:"None"}),(0,r.jsx)(t.td,{children:"Hardhat, Foundry, Truffle, Remix"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"UI frameworks"})}),(0,r.jsxs)(t.td,{children:[(0,r.jsx)(t.a,{href:"https://inkathon.xyz/",children:"ink!athon"}),", dedot, PAPI, ",(0,r.jsx)(t.a,{href:"/tutorials/frontend-development/typink-erc20",children:"Typink"}),", polkadot-js, \u2026"]}),(0,r.jsx)(t.td,{children:"None"}),(0,r.jsx)(t.td,{children:"Very mature Web3 ecosystem: ethers.js, wagmi, web3.js"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"Documentation"})}),(0,r.jsxs)(t.td,{children:["Extensive, verbose docs on ",(0,r.jsx)(t.a,{href:"https://use.ink/docs",children:"use.ink/docs"}),", crate-level docs for all crates (",(0,r.jsx)(t.a,{href:"https://docs.rs/ink_env/6.0.0-beta.1/ink_env/",children:(0,r.jsx)(t.code,{children:"ink_env"})}),", ",(0,r.jsx)(t.a,{href:"https://docs.rs/ink_env/6.0.0-beta.1/ink_storage/",children:(0,r.jsx)(t.code,{children:"ink_storage"})}),", \u2026)"]}),(0,r.jsx)(t.td,{children:"None"}),(0,r.jsx)(t.td,{children:"Widely available"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"Polkadot SDK Integration"})}),(0,r.jsxs)(t.td,{children:["Native support for typical ",(0,r.jsx)(t.code,{children:"polkadot-sdk"})," types (",(0,r.jsx)(t.code,{children:"Balance"}),", ",(0,r.jsx)(t.code,{children:"AccountId"}),", ",(0,r.jsx)(t.code,{children:"VersionedXcm"}),", etc.)"]}),(0,r.jsx)(t.td,{children:"None"}),(0,r.jsx)(t.td,{children:"None"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"Developer Ergonomics"})}),(0,r.jsx)(t.td,{children:"High: macros for storage, events, traits, testing"}),(0,r.jsx)(t.td,{children:"Very low: everything must be implemented manually"}),(0,r.jsx)(t.td,{children:"Extensive tooling & IDE support"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"Testing Environments"})}),(0,r.jsx)(t.td,{children:"Elaborate End-to-End testing framework"}),(0,r.jsx)(t.td,{children:"Must implement your own test harness"}),(0,r.jsx)(t.td,{children:"Foundry/Hardhat; very mature"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"Contract Model"})}),(0,r.jsx)(t.td,{children:"Function-based message/constructor model"}),(0,r.jsx)(t.td,{children:"No model provided; must implement dispatch & ABI"}),(0,r.jsx)(t.td,{children:"Function-based ABI, msg.sender model"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"Datastructures"})}),(0,r.jsx)(t.td,{children:"High-level datastructures, optimized for smart contracts (small footprint, lazy loading)"}),(0,r.jsx)(t.td,{children:"None"}),(0,r.jsx)(t.td,{children:"Basic mappings, arrays, structs"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"Storage Handling"})}),(0,r.jsxs)(t.td,{children:[(0,r.jsx)(t.a,{href:"https://docs.rs/ink_storage/6.0.0-beta.1/ink_storage/",children:(0,r.jsx)(t.code,{children:"ink::storage"})}),", ",(0,r.jsx)(t.a,{href:"../datastructures/mapping/",children:(0,r.jsx)(t.code,{children:"Mapping"})}),"`, derive macros for layout and codecs"]}),(0,r.jsx)(t.td,{children:"Manual storage layout + serialization"}),(0,r.jsx)(t.td,{children:"Solidity storage keywords & slot model"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"ABI / Metadata"})}),(0,r.jsx)(t.td,{children:"Supports ink! metadata (SCALE-based) + Solidity ABI"}),(0,r.jsx)(t.td,{children:"Fully manual ABI definitions"}),(0,r.jsx)(t.td,{children:"Native ABI; industry standard"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"Cross-Contract Calls"})}),(0,r.jsx)(t.td,{children:"Rust traits as type-safe interfaces for calling Solidity or ink! contracts"}),(0,r.jsx)(t.td,{children:"Manual SCALE (or other) encoding/decoding, not type-safe"}),(0,r.jsx)(t.td,{children:"Built into EVM"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"Contract Verification"})}),(0,r.jsx)(t.td,{children:"Supported through ink! metadata and tooling; verifiable via Docker container"}),(0,r.jsx)(t.td,{children:"No support, must build verification tooling manually"}),(0,r.jsx)(t.td,{children:"Etherscan-style source verification"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"Zero Knowledge"})}),(0,r.jsxs)(t.td,{children:["Can integrate with Polkadot-native ZK primitives at the Rust level (",(0,r.jsx)(t.a,{href:"https://github.com/use-ink/ink-examples/tree/main/zk-cross-contract-calls-solidity-verifiers",children:"example"}),")"]}),(0,r.jsx)(t.td,{children:"Possible, but fully manual"}),(0,r.jsx)(t.td,{children:"Growing zkEVM ecosystem"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"Productivity"})}),(0,r.jsx)(t.td,{children:"High"}),(0,r.jsx)(t.td,{children:"Highest flexibility, lowest productivity"}),(0,r.jsx)(t.td,{children:"High"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"Recommended Use Case"})}),(0,r.jsx)(t.td,{children:"Polkadot smart contracts"}),(0,r.jsx)(t.td,{children:"Highly efficient low-level contracts (e.g. for isolated business logic parts)"}),(0,r.jsx)(t.td,{children:"EVM-chain smart contracts, L1/L2 ecosystems"})]})]})]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},65404:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var s=n(36672);const r={},i=s.createContext(r);function o(e){const t=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:t},e.children)}},92184:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/rust-750c42dda186793e9d8ecd0aa09f3d45.svg"}}]);