"use strict";(self.webpackChunkink_docs=self.webpackChunkink_docs||[]).push([[4479],{34283:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"datastructures/mapping","title":"Working with Mapping","description":"In this section we want to demonstrate how to work with ink! Mapping.","source":"@site/versioned_docs/version-v3/datastructures/mapping.md","sourceDirName":"datastructures","slug":"/datastructures/mapping","permalink":"/docs/v3/datastructures/mapping","draft":false,"unlisted":false,"editUrl":"https://github.com/use-ink/ink-docs/edit/master/versioned_docs/version-v3/datastructures/mapping.md","tags":[],"version":"v3","frontMatter":{"title":"Working with Mapping","slug":"/datastructures/mapping"},"sidebar":"reference","previous":{"title":"Overview","permalink":"/docs/v3/datastructures/overview"},"next":{"title":"Spread Storage Layout","permalink":"/docs/v3/datastructures/spread-storage-layout"}}');var a=e(23420),r=e(65404);const s={title:"Working with Mapping",slug:"/datastructures/mapping"},o=void 0,c={},l=[{value:"Initializing a Mapping",id:"initializing-a-mapping",level:2}];function p(n){const t={a:"a",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",...(0,r.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:["In this section we want to demonstrate how to work with ink! ",(0,a.jsx)(t.a,{href:"https://docs.rs/ink_storage/3.3.1/ink_storage/struct.Mapping.html",children:(0,a.jsx)(t.code,{children:"Mapping"})}),"."]}),"\n",(0,a.jsx)(t.p,{children:"Here is an example of a mapping from a user to a number:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"#[ink(storage)]\n#[derive(SpreadAllocate)]\npub struct MyContract {\n    // Store a mapping from AccountIds to a u32\n    map: ink_storage::Mapping<AccountId, u32>,\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:'This means that for a given key, you can store a unique instance of a value type. In this\ncase, each "user" gets their own number.'}),"\n",(0,a.jsx)(t.h2,{id:"initializing-a-mapping",children:"Initializing a Mapping"}),"\n",(0,a.jsxs)(t.p,{children:["In order to correctly initialize a ",(0,a.jsx)(t.code,{children:"Mapping"})," we need two things:"]}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["An implementation of the ",(0,a.jsx)(t.a,{href:"https://docs.rs/ink_storage/3.3.1/ink_storage/traits/trait.SpreadAllocate.html",children:(0,a.jsx)(t.code,{children:"SpreadAllocate"})})," trait on our storage struct"]}),"\n",(0,a.jsxs)(t.li,{children:["The ",(0,a.jsx)(t.a,{href:"https://docs.rs/ink_lang/3.3.1/ink_lang/utils/fn.initialize_contract.html",children:(0,a.jsx)(t.code,{children:"ink_lang::utils::initialize_contract"})})," initializer"]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["Not initializing storage before you use it is a common mistake that can break your smart\ncontract. If you do not initialize your ",(0,a.jsx)(t.code,{children:"Mapping"}),"'s correctly you may end up with\ndifferent ",(0,a.jsx)(t.code,{children:"Mapping"}),"'s operating on the same set of storage entries \ud83d\ude31."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"\n#![cfg_attr(not(feature = \"std\"), no_std)]\n\nuse ink_lang as ink;\n\n#[ink::contract]\nmod mycontract {\n    use ink_storage::traits::SpreadAllocate;\n\n    #[ink(storage)]\n    #[derive(SpreadAllocate)]\n    pub struct MyContract {\n        // Store a mapping from AccountIds to a u32\n        map: ink_storage::Mapping<AccountId, u32>,\n    }\n\n    impl MyContract {\n        #[ink(constructor)]\n        pub fn new(count: u32) -> Self {\n            // This call is required in order to correctly initialize the\n            // `Mapping`s of our contract.\n            ink_lang::utils::initialize_contract(|contract: &mut Self| {\n                let caller = Self::env().caller();\n                contract.map.insert(&caller, &count);\n            })\n        }\n\n        #[ink(constructor)]\n        pub fn default() -> Self {\n            // Even though we're not explicitly initializing the `Mapping`,\n            // we still need to call this\n            ink_lang::utils::initialize_contract(|_| {})\n        }\n\n        // Grab the number at the caller's AccountID, if it exists\n        #[ink(message)]\n        pub fn get(&self) -> u32 {\n            let caller = Self::env().caller();\n            self.map.get(&caller).unwrap_or_default()\n        }\n    }\n}\n"})})]})}function u(n={}){const{wrapper:t}={...(0,r.R)(),...n.components};return t?(0,a.jsx)(t,{...n,children:(0,a.jsx)(p,{...n})}):p(n)}},65404:(n,t,e)=>{e.d(t,{R:()=>s,x:()=>o});var i=e(36672);const a={},r=i.createContext(a);function s(n){const t=i.useContext(r);return i.useMemo(function(){return"function"==typeof n?n(t):{...t,...n}},[t,n])}function o(n){let t;return t=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:s(n.components),i.createElement(r.Provider,{value:t},n.children)}}}]);