"use strict";(self.webpackChunkink_docs=self.webpackChunkink_docs||[]).push([[5078],{6604:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>a,toc:()=>h});var s=t(4848),c=t(8453);const i={title:"xcm",slug:"/basics/xcm",hide_title:!0},r="Cross-Consensus Message (XCM)",a={id:"basics/xcm",title:"xcm",description:"XCM allows for cross-chain communications, enabling ink! smart contract to interact with other chains.",source:"@site/docs/basics/xcm.md",sourceDirName:"basics",slug:"/basics/xcm",permalink:"/basics/xcm",draft:!1,unlisted:!1,editUrl:"https://github.com/use-ink/ink-docs/edit/master/docs/basics/xcm.md",tags:[],version:"current",frontMatter:{title:"xcm",slug:"/basics/xcm",hide_title:!0}},o={},h=[];function l(e){const n={a:"a",code:"code",h1:"h1",p:"p",pre:"pre",strong:"strong",...(0,c.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)("img",{src:"/img/title/xcm.svg",className:"titlePic"}),"\n",(0,s.jsx)(n.h1,{id:"cross-consensus-message-xcm",children:"Cross-Consensus Message (XCM)"}),"\n",(0,s.jsxs)(n.p,{children:["XCM allows for cross-chain communications, enabling ink! smart contract to interact with other chains.\nYou can learn more about XCM in the ",(0,s.jsx)(n.a,{href:"https://wiki.polkadot.network/docs/learn/xcm",children:"Polkadot Wiki"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["As of version 5.1.0, two new host functions, ",(0,s.jsx)(n.a,{href:"https://docs.rs/ink/latest/ink/struct.EnvAccess.html#method.xcm_execute",children:(0,s.jsx)(n.code,{children:"xcm_execute"})})," and ",(0,s.jsx)(n.a,{href:"https://docs.rs/ink/latest/ink/struct.EnvAccess.html#method.xcm_send",children:(0,s.jsx)(n.code,{children:"xcm_send"})}),", have been introduced.\nThese functions enable sending and executing XCM from within ink! contracts."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Note:"})}),"\n",(0,s.jsxs)(n.p,{children:["In versions of ink! prior to 5.1.0, the ",(0,s.jsx)(n.a,{href:"https://docs.rs/ink/latest/ink/struct.EnvAccess.html#method.call_runtime",children:"call_runtime"})," host function or a custom chain extension can be used to send or execute an XCM from ink! contracts."]}),"\n",(0,s.jsx)(n.h1,{id:"xcm_execute",children:"xcm_execute"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.a,{href:"https://docs.rs/ink/latest/ink/struct.EnvAccess.html#method.xcm_execute",children:(0,s.jsx)(n.code,{children:"xcm_execute"})})," function executes the XCM locally. It first checks the message to ensure that no barriers or filters will block the execution, and then executes it locally, using the contract's account as the origin."]}),"\n",(0,s.jsxs)(n.p,{children:["The following code snippet demonstrates how to use ",(0,s.jsx)(n.code,{children:"xcm_execute"})," to perform a ",(0,s.jsx)(n.a,{href:"https://wiki.polkadot.network/docs/learn/xcm/journey/transfers-reserve#1-initiatereservewithdraw",children:"reserve-backed transfer"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"#[ink(message)]\npub fn reserve_transfer(&mut self, value: Balance) -> Result<(), RuntimeError> {\n    // The beneficiary of the transfer.\n    // Here, the beneficiary is the caller's account on the relay chain.\n    let beneficiary: Location = AccountId32 {\n        network: None,\n        id: *self.env().caller().as_ref(),\n    }.into();\n\n    // Create an XCM message.\n    let message: Xcm<()> = Xcm::builder_unsafe()\n\n     // Withdraw the relay's native token derivative from the contract's account.\n     .withdraw_asset((Parent, amount))\n\n    // The initiate_reserve_withdraw instruction takes the derivative token from the holding register and burns it.\n    // It then send the nested XCM to the reserve in this example, the relay chain.\n    // Upon receiving the XCM, the reserve will withdraw the asset from our chain's sovereign account, and deposit on the caller's account.\n    .initiate_reserve_withdraw(\n        All,\n        Parent,\n        Xcm::builder_unsafe()\n            .buy_execution((Here, fee), Unlimited)\n            .deposit_asset(All, beneficiary)\n            .build(),\n    )\n    .build();\n\n    self.env().xcm_execute(&VersionedXcm::V4(message))?;\n    Ok(())\n}\n"})}),"\n",(0,s.jsx)(n.h1,{id:"xcm_send",children:"xcm_send"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.a,{href:"https://docs.rs/ink/latest/ink/struct.EnvAccess.html#method.xcm_execute",children:(0,s.jsx)(n.code,{children:"xcm_send"})})," function enables sending XCM to be executed by another chain.\nMessages sent originate from the contract's account. Consequently, the receiving chain will process the message using the contract's sovereign account as the origin."]}),"\n",(0,s.jsxs)(n.p,{children:["The following example demonstrates how to use ",(0,s.jsx)(n.code,{children:"xcm_send"}),". In this example, we send an XCM to the relay chain.\nThis XCM will execute using the contract's sovereign account as the origin of the call.\nIt will then transfer, some ",(0,s.jsx)(n.code,{children:"value"})," from this account to the caller's account."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"#[ink(message)]\npub fn send_funds(&mut self, value: Balance, fee: Balance) -> Result<(), RuntimeError> {\n    // The destination of the XCM message. Assuming we run the contract on a parachain, the parent will be the relay chain.\n    let destination: Location = Parent.into();\n\n    // the asset to be sent, since we are sending the XCM to the relay chain,\n    // this represents `value` amount of the relay chain's native asset.\n    let assets: Asset = (Here, value).into();\n\n    // The beneficiary of the asset.\n    // Here, the beneficiary is the caller's account on the relay chain.\n    let beneficiary: Location = AccountId32 {\n        network: None,\n        id: *self.env().caller().as_ref(),\n    }.into();\n\n    // Create an XCM message\n    let message: Xcm<()> = Xcm::builder()\n\n        // Withdraw the asset from the origin (the sovereign account of the contract on the relay chain)\n        .withdraw_asset(assets.clone().into())\n\n        // Buy execution to pay the fee on the relay chain\n        .buy_execution((Here, fee).into(), WeightLimit::Unlimited)\n\n        // Deposit the asset to the caller's account on the relay chain\n        .deposit_asset(assets.into(), beneficiary)\n        .build();\n\n    // Send the constructed XCM message to the relay chain, using the xcm_send host function.\n    self.env().xcm_send(\n        &VersionedLocation::V4(destination),\n        &VersionedXcm::V4(message),\n    )?;\n\n    Ok(())\n}\n"})})]})}function d(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var s=t(6540);const c={},i=s.createContext(c);function r(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:r(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);