"use strict";(self.webpackChunkink_docs=self.webpackChunkink_docs||[]).push([[6923],{29661:(e,t,r)=>{r.d(t,{A:()=>s});const s=r.p+"assets/images/storage-ee91ff72871e8fcb3e47049c3110f8bf.svg"},62566:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"advanced/datastructures/overview","title":"Overview","description":"Storage Title Picture","source":"@site/docs/advanced/datastructures/overview.md","sourceDirName":"advanced/datastructures","slug":"/datastructures/overview","permalink":"/docs/v6/datastructures/overview","draft":false,"unlisted":false,"editUrl":"https://github.com/use-ink/ink-docs/edit/master/docs/advanced/datastructures/overview.md","tags":[],"version":"current","frontMatter":{"title":"Overview","slug":"/datastructures/overview","hide_title":true},"sidebar":"reference","previous":{"title":"Precompiles","permalink":"/docs/v6/basics/precompiles"},"next":{"title":"Working with Mapping","permalink":"/docs/v6/datastructures/mapping"}}');var i=r(23420),n=r(65404);const a={title:"Overview",slug:"/datastructures/overview",hide_title:!0},o="Overview",c={},d=[];function l(e){const t={a:"a",code:"code",h1:"h1",header:"header",img:"img",p:"p",...(0,n.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Storage Title Picture",src:r(29661).A+"",width:"1600",height:"500"})}),"\n",(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"overview",children:"Overview"})}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"ink_storage"})," crate acts as the standard storage library for ink! smart contracts.\nAt the moment it provides three primitives for interacting with storage,\n",(0,i.jsx)(t.a,{href:"https://use-ink.github.io/ink/ink_storage/struct.Mapping.html",children:(0,i.jsx)(t.code,{children:"Mapping"})}),", ",(0,i.jsx)(t.a,{href:"https://use-ink.github.io/ink/ink_storage/struct.Lazy.html",children:(0,i.jsx)(t.code,{children:"Lazy"})})," and ",(0,i.jsx)(t.a,{href:"https://use-ink.github.io/ink/ink_storage/struct.StorageVec.html",children:(0,i.jsx)(t.code,{children:"StorageVec"})}),"."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"https://use-ink.github.io/ink/ink_storage/struct.Mapping.html",children:(0,i.jsx)(t.code,{children:"Mapping"})})," is a mapping of key-value pairs directly to the contract storage.\nIt is very similar to traditional hash tables and comparable to the ",(0,i.jsx)(t.code,{children:"mapping"})," type Solidity offers.\nAs a core ingredient to the ink! language, its main advantage is being simple and\nlightweight: It favors being efficient in terms of gas costs and code size\nover providing a lot of high-level functionality found in other implementations\nlike the ",(0,i.jsx)(t.code,{children:"ink::prelude::collections::HashMap"})," type.\nOverall, the ink! ",(0,i.jsx)(t.code,{children:"Mapping"})," will be a solid choice for most contracts.\nMoreover, smart contracts developers can implement advanced features themselves.\nYou can learn more about this in the ",(0,i.jsxs)(t.a,{href:"/docs/v6/datastructures/mapping",children:["dedicated ",(0,i.jsx)(t.code,{children:"Mapping"})," section"]}),"."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"https://use-ink.github.io/ink/ink_storage/struct.Lazy.html",children:(0,i.jsx)(t.code,{children:"Lazy"})})," is a wrapper type that can be used over any other storage compatible type.\nThis allows smart contract developers fine-grained manual control over the layout of\nthe contract storage by assigning a separate storage cell for the field. For example,\nit can be used to prevent the contract from eagerly loading large storage fields\nduring each contract call.\nConceivably, it may be desirable to change certain aspects on how your contract deals with\nits storage variables. You can find out more about this in the section about the ink!\n",(0,i.jsx)(t.a,{href:"/docs/v6/datastructures/storage-layout",children:"Storage Layout"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"https://use-ink.github.io/ink/ink_storage/struct.StorageVec.html",children:(0,i.jsx)(t.code,{children:"StorageVec"})})," is a vector of values/elements directly on contract storage.\nHowever, unlike ",(0,i.jsx)(t.code,{children:"Vec<T>"}),", which stores all of its elements in a single storage cell,\n",(0,i.jsx)(t.code,{children:"StorageVec"})," stores each of its elements in its own storage cell.\nThis layout is more gas efficient for reads and writes of single elements,\nand also allows higher maximum capacity for ",(0,i.jsx)(t.code,{children:"StorageVec"})," compared to ",(0,i.jsx)(t.code,{children:"Vec<T>"}),".\nYou can learn more about this in the ",(0,i.jsxs)(t.a,{href:"/docs/v6/datastructures/storagevec",children:["dedicated ",(0,i.jsx)(t.code,{children:"StorageVec"})," section"]}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},65404:(e,t,r)=>{r.d(t,{R:()=>a,x:()=>o});var s=r(36672);const i={},n=s.createContext(i);function a(e){const t=s.useContext(n);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(n.Provider,{value:t},e.children)}}}]);