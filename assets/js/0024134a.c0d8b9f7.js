"use strict";(self.webpackChunkink_docs=self.webpackChunkink_docs||[]).push([[5226],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>k});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=c(n),m=r,k=d["".concat(s,".").concat(m)]||d[m]||u[m]||i;return n?a.createElement(k,l(l({ref:t},p),{},{components:n})):a.createElement(k,l({ref:t},p))}));function k(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[d]="string"==typeof e?e:r,l[1]=o;for(var c=2;c<i;c++)l[c]=n[c];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1641:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var a=n(7462),r=(n(7294),n(3905));const i={title:"ink! vs. Solidity",hide_title:!0,slug:"/ink-vs-solidity"},l=void 0,o={unversionedId:"intro/ink-vs-solidity",id:"intro/ink-vs-solidity",title:"ink! vs. Solidity",description:"The following table gives a brief comparison of features between ink! and Solidity:",source:"@site/docs/intro/ink-vs-solidity.md",sourceDirName:"intro",slug:"/ink-vs-solidity",permalink:"/ink-vs-solidity",draft:!1,editUrl:"https://github.com/paritytech/ink-docs/edit/master/docs/intro/ink-vs-solidity.md",tags:[],version:"current",frontMatter:{title:"ink! vs. Solidity",hide_title:!0,slug:"/ink-vs-solidity"},sidebar:"reference",previous:{title:"How it Works \u2013 Substrate",permalink:"/how-it-works"},next:{title:"ink! vs. CosmWasm",permalink:"/ink-vs-cosmwasm"}},s={},c=[{value:"Solidity to ink! Guide",id:"solidity-to-ink-guide",level:2},{value:"Table of Contents",id:"table-of-contents",level:3},{value:"Converting a Solidity Contract to ink!",id:"converting-a-solidity-contract-to-ink",level:2},{value:"1. Generate a new ink! contract",id:"1-generate-a-new-ink-contract",level:3},{value:"2. Build the contract",id:"2-build-the-contract",level:3},{value:"3. Convert Solidity class fields to Rust struct",id:"3-convert-solidity-class-fields-to-rust-struct",level:3},{value:"4. Convert each function",id:"4-convert-each-function",level:3},{value:"Best Practices + Tips",id:"best-practices--tips",level:2},{value:"Syntax Equivalencies",id:"syntax-equivalencies",level:2},{value:"<code>public function</code>",id:"public-function",level:3},{value:"<code>mapping declaration</code>",id:"mapping-declaration",level:3},{value:"<code>mapping usage</code>",id:"mapping-usage",level:3},{value:"<code>struct</code>",id:"struct",level:3},{value:"<code>assertions / requires</code>",id:"assertions--requires",level:3},{value:"<code>timestamp</code>",id:"timestamp",level:3},{value:"<code>contract caller</code>",id:"contract-caller",level:3},{value:"<code>contract&#39;s address</code>",id:"contracts-address",level:3},{value:"<code>bytes</code>",id:"bytes",level:3},{value:"<code>uint256</code>",id:"uint256",level:3},{value:"<code>payable</code>",id:"payable",level:3},{value:"<code>received deposit / payment</code>",id:"received-deposit--payment",level:3},{value:"<code>contract balance</code>",id:"contract-balance",level:3},{value:"<code>transfer tokens from contract</code>",id:"transfer-tokens-from-contract",level:3},{value:"<code>events &amp; indexed</code>",id:"events--indexed",level:3},{value:"<code>errors and returning</code>",id:"errors-and-returning",level:3},{value:"<code>throw</code>",id:"throw",level:4},{value:"<code>assert</code>",id:"assert",level:4},{value:"<code>require and revert</code>",id:"require-and-revert",level:4},{value:"<code>nested mappings + custom / advanced structures</code>",id:"nested-mappings--custom--advanced-structures",level:3},{value:"<code>cross-contract calling</code>",id:"cross-contract-calling",level:3},{value:"<code>submit generic transaction / dynamic cross-contract calling</code>",id:"submit-generic-transaction--dynamic-cross-contract-calling",level:3},{value:"Limitations of ink! v3",id:"limitations-of-ink-v3",level:2},{value:"Troubleshooting Errors",id:"troubleshooting-errors",level:2},{value:"unit testing (off-chain)",id:"unit-testing-off-chain",level:2}],p={toc:c},d="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("img",{src:"/img/title/solidity.svg",className:"titlePic"}),(0,r.kt)("h1",{id:"ink-vs-solidity"},"ink! vs. Solidity"),(0,r.kt)("p",null,"The following table gives a brief comparison of features between ink! and Solidity:"),(0,r.kt)("div",{class:"comparison"},(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"left"}),(0,r.kt)("th",{parentName:"tr",align:"left"},"ink!"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Solidity"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Virtual Machine"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Any Wasm VM"),(0,r.kt)("td",{parentName:"tr",align:"left"},"EVM")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Encoding"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Wasm"),(0,r.kt)("td",{parentName:"tr",align:"left"},"EVM Byte Code")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Language"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Rust"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Standalone")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Overflow Protection"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Enabled by default"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Yes")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Constructor Functions"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Multiple"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Single")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Tooling"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Anything that supports Rust"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Custom")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Versioning"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Semantic"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Semantic")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Has Metadata?"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Yes"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Yes")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Multi-File Project"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Planned"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Yes")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Storage Entries"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Variable"),(0,r.kt)("td",{parentName:"tr",align:"left"},"256 bits")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Supported Types"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Docs"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Docs")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Has Interfaces?"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Yes (Rust Traits)"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Yes"))))),(0,r.kt)("h2",{id:"solidity-to-ink-guide"},"Solidity to ink! Guide"),(0,r.kt)("h3",{id:"table-of-contents"},"Table of Contents"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#solidity-to-ink-guide"},"Solidity to ink! Guide")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#table-of-contents"},"Table of Contents")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#converting-a-solidity-contract-to-ink"},"Converting a Solidity contract to ink!"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#1-generate-a-new-ink-contract"},"1. Generate a new ink! contract")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#2-build-the-contract"},"2. Build the contract")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#3-convert-solidity-class-fields-to-rust-struct"},"3. Convert Solidity class fields to Rust struct")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#4-convert-each-function"},"4. Convert each function")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#best-practices--tips"},"Best Practices + Tips")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#syntax-equivalencies"},"Syntax Equivalencies"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#public-function"},(0,r.kt)("inlineCode",{parentName:"a"},"public function"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#mapping-declaration"},(0,r.kt)("inlineCode",{parentName:"a"},"mapping declaration"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#mapping-usage"},(0,r.kt)("inlineCode",{parentName:"a"},"mapping usage"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#struct"},(0,r.kt)("inlineCode",{parentName:"a"},"struct"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#assertions--requires"},(0,r.kt)("inlineCode",{parentName:"a"},"assertions / requires"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#timestamp"},(0,r.kt)("inlineCode",{parentName:"a"},"timestamp"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#contract-caller"},(0,r.kt)("inlineCode",{parentName:"a"},"contract caller"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#contracts-address"},(0,r.kt)("inlineCode",{parentName:"a"},"contract's address"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#bytes"},(0,r.kt)("inlineCode",{parentName:"a"},"bytes"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#uint256"},(0,r.kt)("inlineCode",{parentName:"a"},"uint256"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#payable"},(0,r.kt)("inlineCode",{parentName:"a"},"payable"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#received-deposit--payment"},(0,r.kt)("inlineCode",{parentName:"a"},"received deposit / payment"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#contract-balance"},(0,r.kt)("inlineCode",{parentName:"a"},"contract balance"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#transfer-tokens-from-contract"},(0,r.kt)("inlineCode",{parentName:"a"},"transfer tokens from contract"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#events--indexed"},(0,r.kt)("inlineCode",{parentName:"a"},"events & indexed"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#errors-and-returning"},(0,r.kt)("inlineCode",{parentName:"a"},"errors and returning")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#throw"},(0,r.kt)("inlineCode",{parentName:"a"},"throw"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#assert"},(0,r.kt)("inlineCode",{parentName:"a"},"assert"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#require-and-revert"},(0,r.kt)("inlineCode",{parentName:"a"},"require and revert"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#nested-mappings--custom--advanced-structures"},(0,r.kt)("inlineCode",{parentName:"a"},"nested mappings + custom / advanced structures"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#cross-contract-calling"},(0,r.kt)("inlineCode",{parentName:"a"},"cross-contract calling"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#submit-generic-transaction--dynamic-cross-contract-calling"},(0,r.kt)("inlineCode",{parentName:"a"},"submit generic transaction / dynamic cross-contract calling"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#limitations-of-ink-v3"},"Limitations of ink! v3")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#troubleshooting-errors"},"Troubleshooting Errors")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#unit-testing-off-chain"},"unit testing (off-chain)"))),(0,r.kt)("h2",{id:"converting-a-solidity-contract-to-ink"},"Converting a Solidity Contract to ink!"),(0,r.kt)("h3",{id:"1-generate-a-new-ink-contract"},"1. Generate a new ink! contract"),(0,r.kt)("p",null,'Run the following command to generate the skeleton for an ink! contract.\nThe command will set up the boilerplate code for ink!\'s "Hello, World!"\n(the ',(0,r.kt)("a",{parentName:"p",href:"https://github.com/paritytech/ink-examples/tree/main/flipper"},(0,r.kt)("inlineCode",{parentName:"a"},"flipper"))," contract))."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"cargo contract new <contract-name>\n")),(0,r.kt)("h3",{id:"2-build-the-contract"},"2. Build the contract"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"cargo contract build\n")),(0,r.kt)("h3",{id:"3-convert-solidity-class-fields-to-rust-struct"},"3. Convert Solidity class fields to Rust struct"),(0,r.kt)("p",null,"Solidity is an object-oriented language, and uses classes. ink! (Rust) does not use classes."),(0,r.kt)("p",null,"An example Solidity class looks like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},'contract MyContract {\n    bool private _theBool;\n    event UpdatedBool(bool indexed _theBool);\n\n    constructor(bool theBool_) {\n        require(theBool_ == true, "theBool_ must start as true");\n\n        _theBool = theBool_;\n    }\n\n    function setBool(bool newBool) public returns (bool boolChanged) {\n        if _theBool == newBool {\n               boolChanged = false;\n        } else {\n            boolChanged = true;\n        }\n\n        _theBool = newBool;\n        // emit event\n        UpdatedBool(newBool);\n    }\n}\n')),(0,r.kt)("p",null,"And the equivalent contract in ink! looks like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#![cfg_attr(not(feature = "std"), no_std)]\n\nuse ink_lang as ink;\n\n#[ink::contract]\nmod mycontract {\n    #[ink(storage)]\n    pub struct MyContract {\n        the_bool: bool, // class members become struct fields\n    }\n\n    #[ink(event)]\n    pub struct UpdatedBool {\n        #[ink(topic)] // -> indexed\n        the_bool: bool,\n    }\n\n    impl MyContract {\n        #[ink(constructor)]\n        pub fn new(the_bool: bool) -> Self {\n            assert!(the_bool == true, "the_bool must start as true");\n            Self { the_bool }\n        }\n\n        #[ink(message)] // functions become struct implementations\n        pub fn set_bool(&mut self, new_bool: bool) -> bool {\n            let bool_changed = true;\n\n            if self.the_bool == new_bool{\n                bool_changed = false;\n            }else{\n                bool_changed = true;\n            }\n\n            self.the_bool = new_bool;\n\n            self.env().emit_event(UpdatedBool {\n                the_bool: new_bool\n            });\n\n            // return\n            bool_changed\n        }\n    }\n}\n')),(0,r.kt)("p",null,"A few key differences are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Solidity class variables / members will be placed in the contract struct in ink!"),(0,r.kt)("li",{parentName:"ul"},"All class methods in Solidity are ",(0,r.kt)("inlineCode",{parentName:"li"},"impl"),"emented for the contract struct in ink!"),(0,r.kt)("li",{parentName:"ul"},"Solidity frequently prefixes variables with an underscore (",(0,r.kt)("inlineCode",{parentName:"li"},"_name"),"). ink! / Rust only prefixes with an underscore for ",(0,r.kt)("em",{parentName:"li"},"unused")," variables."),(0,r.kt)("li",{parentName:"ul"},"Solidity uses camelCase. ink! uses snake_case."),(0,r.kt)("li",{parentName:"ul"},"In Solidity, the variable type comes before the variable name (e.g. bool myVar). While ink! specifies var type after the var name (e.g. my_var: bool)")),(0,r.kt)("h3",{id:"4-convert-each-function"},"4. Convert each function"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Start converting each function one by one."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"A recommended approach is to, if possible, skip cross-contract calls at first and use mock data instead"),(0,r.kt)("li",{parentName:"ul"},"This way off-chain unit tests can be written to test the core functionality",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"unit tests are off-chain and do not work with cross-contract calls"))),(0,r.kt)("li",{parentName:"ul"},"Once fully tested, start adding in cross-contract calls and perform on-chain manual + integration tests"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Ensure that function's visibility (public, private) are matched in ink!")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"In Solidity, if a function returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"bool success"),", ink! will use a ",(0,r.kt)("inlineCode",{parentName:"p"},"Result<()>")," instead (",(0,r.kt)("inlineCode",{parentName:"p"},"Result::Ok")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Result::Err"),")."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// ink!\n\n// result type\npub type Result<T> = core::result::Result<T, Error>;\n\n// ...\n\n// public function that returns a Result\n#[ink(message)]\npub fn my_function(&self) -> Result<()> {\n    Ok(())\n}\n")))),(0,r.kt)("h2",{id:"best-practices--tips"},"Best Practices + Tips"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If the Solidity contract uses a ",(0,r.kt)("inlineCode",{parentName:"li"},"string"),", it is recommended to use a ",(0,r.kt)("inlineCode",{parentName:"li"},"Vec<u8>")," to avoid the overhead of a ",(0,r.kt)("inlineCode",{parentName:"li"},"String"),". See ",(0,r.kt)("a",{parentName:"li",href:"https://substrate.stackexchange.com/questions/1174/why-is-it-a-bad-idea-to-use-string-in-an-ink-smart-contract"},"here")," for more details on why. The smart contract should only contain the information that strictly needs to be placed on the blockchain and go through consensus. The UI should be used for displaying strings."),(0,r.kt)("li",{parentName:"ul"},"Double check all ",(0,r.kt)("inlineCode",{parentName:"li"},".unwrap()"),"s performed. Solidity does not have as strict checking as ink! does. For example, a mapping field can be accessed as simple as ",(0,r.kt)("inlineCode",{parentName:"li"},"myMapping[someKey]"),". ink!, however, requires ",(0,r.kt)("inlineCode",{parentName:"li"},"self.my_mapping.get(some_key).unwrap()"),". A useful way to handle ",(0,r.kt)("inlineCode",{parentName:"li"},"None")," cases is to use ",(0,r.kt)("inlineCode",{parentName:"li"},".unwrap_or(some_val)"),"."),(0,r.kt)("li",{parentName:"ul"},"Run the contracts node with ",(0,r.kt)("inlineCode",{parentName:"li"},"substrate-contracts-node -lerror,runtime::contracts=debug")," for debug prints, and errors to be displayed in the nodes console."),(0,r.kt)("li",{parentName:"ul"},"When passing parameters to a helper, it is recommended to pass references (even for primitives) as Wasm is more efficient with references.\nFor example (see ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/paritytech/ink-examples/blob/main/erc20/lib.rs"},"erc20")," example):")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"/// Returns the account balance for the specified `owner`.\n///\n/// Returns `0` if the account is non-existent.\n#[ink(message)]\npub fn balance_of(&self, owner: AccountId) -> Balance {\n    self.balance_of_impl(&owner)\n}\n\n/// Returns the account balance for the specified `owner`.\n///\n/// Returns `0` if the account is non-existent.\n///\n/// # Note\n///\n/// Prefer to call this method over `balance_of` since this\n/// works using references which are more efficient in Wasm.\n#[inline]\nfn balance_of_impl(&self, owner: &AccountId) -> Balance {\n    self.balances.get(owner).unwrap_or_default()\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Just as in Solidity, ink! does not have floating point numbers due to the non-deterministic nature. Instead, the frontend should add decimal points as needed.")),(0,r.kt)("h2",{id:"syntax-equivalencies"},"Syntax Equivalencies"),(0,r.kt)("h3",{id:"public-function"},(0,r.kt)("inlineCode",{parentName:"h3"},"public function")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},"// solidity\nfunction fnName() public {}\n// or\n// by default, functions are public\nfunction fnName() {}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// ink!\n#[ink(message)]\npub fn fn_name(&self) {}\n")),(0,r.kt)("h3",{id:"mapping-declaration"},(0,r.kt)("inlineCode",{parentName:"h3"},"mapping declaration")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},"// solidity\nmapping(address => uint128) private mapName;\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"//ink!\nuse ink_storage::{\n    traits::SpreadAllocate,\n    Mapping,\n};\n\n#[ink(storage)]\n#[derive(SpreadAllocate)]\npub struct ContractName {\n    map_name: Mapping<AccountId, u128>,\n}\n")),(0,r.kt)("p",null,"When using a map in ink!, ",(0,r.kt)("inlineCode",{parentName:"p"},"ink_lang::utils::initialize_contract")," must be used in the constructor. See ",(0,r.kt)("a",{parentName:"p",href:"https://use.ink/datastructures/mapping"},"here")," for more details."),(0,r.kt)("h3",{id:"mapping-usage"},(0,r.kt)("inlineCode",{parentName:"h3"},"mapping usage")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},"// solidity\n\n// insert / update\naMap[aKey] = aValue;\n\n// get\naMap[aKey]\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// ink!\n\n//insert / update\nself.a_map.insert(&a_key, &a_value);\n\n// get\nself.a_map.get(a_key).unwrap()\n")),(0,r.kt)("h3",{id:"struct"},(0,r.kt)("inlineCode",{parentName:"h3"},"struct")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},"// solidity\nstruct MyPerson{\n    address person;\n    u64 favNum;\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// ink!\nstruct MyPerson {\n    person: AccountId,\n    fav_num: u64,\n}\n")),(0,r.kt)("h3",{id:"assertions--requires"},(0,r.kt)("inlineCode",{parentName:"h3"},"assertions / requires")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},'// solidity\nrequire(someValue < 10, "someValue is not less than 10");\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// ink!\nassert!(some_value < 10, "some_value is not less than 10");\n')),(0,r.kt)("h3",{id:"timestamp"},(0,r.kt)("inlineCode",{parentName:"h3"},"timestamp")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},"// solidity\nblock.timestamp\n// or\nnow\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// ink!\nself.env().block_timestamp()\n")),(0,r.kt)("h3",{id:"contract-caller"},(0,r.kt)("inlineCode",{parentName:"h3"},"contract caller")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},"// solidity\naddress caller = msg.sender;\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// ink!\nlet caller: AccountId = self.env().caller();\n")),(0,r.kt)("h3",{id:"contracts-address"},(0,r.kt)("inlineCode",{parentName:"h3"},"contract's address")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},"// solidity\naddress(this)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// ink!\nself.env().account_id()\n")),(0,r.kt)("h3",{id:"bytes"},(0,r.kt)("inlineCode",{parentName:"h3"},"bytes")),(0,r.kt)("p",null,"Solidity has a type ",(0,r.kt)("inlineCode",{parentName:"p"},"bytes"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"bytes")," is (essentially) equivalent to an array of uint8. So, ",(0,r.kt)("inlineCode",{parentName:"p"},"bytes")," in Solidity => ",(0,r.kt)("inlineCode",{parentName:"p"},"Vec<u8>")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"[u8; ...]")," in ink!. See ",(0,r.kt)("a",{parentName:"p",href:"https://ethereum.stackexchange.com/questions/91119/difference-between-byte-and-uint8-datatypes-in-solidity"},"here")," for more details. If desired, a ",(0,r.kt)("inlineCode",{parentName:"p"},"bytes")," struct can be created in ink! to replicate the ",(0,r.kt)("inlineCode",{parentName:"p"},"bytes")," type in Solidity."),(0,r.kt)("h3",{id:"uint256"},(0,r.kt)("inlineCode",{parentName:"h3"},"uint256")),(0,r.kt)("p",null,"Solidity uses ",(0,r.kt)("inlineCode",{parentName:"p"},"uint256")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"uint")," to represent a 256-bit type."),(0,r.kt)("p",null,"Solidity is 256-bit / 32-byte word optimized. Meaning, using ",(0,r.kt)("inlineCode",{parentName:"p"},"uint256")," in Solidity contracts will reduce gas usage -- but increase storage usage. The largest size ink! has built in is a ",(0,r.kt)("inlineCode",{parentName:"p"},"u128"),". ink! compiles to Wasm. The largest primitive Wasm has is 64bit (due to most computers using 64bit). So, there is no benefit to using any larger primitive over a collection."),(0,r.kt)("p",null,"When porting a ",(0,r.kt)("inlineCode",{parentName:"p"},"uint256")," from Solidity to ink!, it is recommended to, with discretion, determine the range of the value, and choose the appropriate size (u8, u16, u32, u64, u128). If a 256-bit hash value is required, ink! has a ",(0,r.kt)("inlineCode",{parentName:"p"},"Hash")," primitive available. In the event a value needs to be 256-bit, it is recommended to use an array (e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},"[u64; 4]"),")."),(0,r.kt)("h3",{id:"payable"},(0,r.kt)("inlineCode",{parentName:"h3"},"payable")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},"// solidity\nfunction myFunction() payable returns (uint64) {}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[ink(message, payable)]\npub fn my_function() -> (u64) {}\n")),(0,r.kt)("h3",{id:"received-deposit--payment"},(0,r.kt)("inlineCode",{parentName:"h3"},"received deposit / payment")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-C++"},"// solidity\nmsg.value\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// ink!\nself.env().transferred_value()\n")),(0,r.kt)("h3",{id:"contract-balance"},(0,r.kt)("inlineCode",{parentName:"h3"},"contract balance")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},"// solidity\nthis.balance\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// ink!\nself.env().balance()\n")),(0,r.kt)("h3",{id:"transfer-tokens-from-contract"},(0,r.kt)("inlineCode",{parentName:"h3"},"transfer tokens from contract")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},"// solidity\nrecipient.send(amount)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// ink!\nif self.env().transfer(recipient, amount).is_err() {\n    panic!("error transferring")\n}\n')),(0,r.kt)("h3",{id:"events--indexed"},(0,r.kt)("inlineCode",{parentName:"h3"},"events & indexed")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},"// solidity\n\nevent MyCoolEvent(\n    u128 indexed indexedValue,\n    u128 notIndexedValue,\n);\n\n// emit event\nMyCoolEvent (someValue, someOtherValue)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// ink!\n\n#[ink(event)]\npub struct MyCoolEvent {\n    #[ink(topic)]\n    indexed_value: u128,\n\n    not_indexed_value: u128,\n}\n\n// emit event\nself.env().emit_event(MyCoolEvent {\n    indexed_value: some_value,\n    not_indexed_value: some_other_value\n});\n")),(0,r.kt)("h3",{id:"errors-and-returning"},(0,r.kt)("inlineCode",{parentName:"h3"},"errors and returning")),(0,r.kt)("p",null,"Solidity has several error handling mechanisms: ",(0,r.kt)("inlineCode",{parentName:"p"},"assert"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"require"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"revert"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"throw"),". Each of these will revert the changed state when called. See ",(0,r.kt)("a",{parentName:"p",href:"https://medium.com/blockchannel/the-use-of-revert-assert-and-require-in-solidity-and-the-new-revert-opcode-in-the-evm-1a3a7990e06e"},"this article")," for details on these."),(0,r.kt)("p",null,"ink! uses a ",(0,r.kt)("inlineCode",{parentName:"p"},"Result")," enum (",(0,r.kt)("inlineCode",{parentName:"p"},"Ok(T)"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Err(E)"),"), ",(0,r.kt)("inlineCode",{parentName:"p"},"assert!")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"panic!"),". ",(0,r.kt)("a",{parentName:"p",href:"https://substrate.stackexchange.com/questions/2391/panic-in-ink-smart-contracts"},"This Stack Exchange")," answer and ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/paritytech/ink/issues/641"},"GitHub discussion")," provide more details on these."),(0,r.kt)("h4",{id:"throw"},(0,r.kt)("inlineCode",{parentName:"h4"},"throw")),(0,r.kt)("p",null,"Throw is deprecated in Solidity and would throw an invalid opcode error (no details) and revert the state. As an alternative to the ",(0,r.kt)("inlineCode",{parentName:"p"},"if...{throw;}")," pattern in Solidity, a ",(0,r.kt)("inlineCode",{parentName:"p"},"Result::Err")," should be returned for expected errors, and an ",(0,r.kt)("inlineCode",{parentName:"p"},"assert!")," should be used for errors that should not occur."),(0,r.kt)("h4",{id:"assert"},(0,r.kt)("inlineCode",{parentName:"h4"},"assert")),(0,r.kt)("p",null,"In Solidity, ",(0,r.kt)("inlineCode",{parentName:"p"},"assert")," is used as internal guards against errors in the ",(0,r.kt)("em",{parentName:"p"},"code"),". In general, properly functioning code should never hit a failing assert. ",(0,r.kt)("inlineCode",{parentName:"p"},"assert")," in Solidity does not have error strings. In ink!, use ",(0,r.kt)("inlineCode",{parentName:"p"},"assert!"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"assert!")," will ",(0,r.kt)("inlineCode",{parentName:"p"},"panic!")," if it evaluates to ",(0,r.kt)("em",{parentName:"p"},"false"),". The state will be reverted, and a ",(0,r.kt)("inlineCode",{parentName:"p"},"CalleeTrapped")," will be returned. The (optional) error string will be printed to the debug buffer."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// ink!\nassert!(caller == owner, "caller is not owner")\n')),(0,r.kt)("h4",{id:"require-and-revert"},(0,r.kt)("inlineCode",{parentName:"h4"},"require and revert")),(0,r.kt)("p",null,"In Solidity, ",(0,r.kt)("inlineCode",{parentName:"p"},"require")," is used for general (normal) errors -- such as errors that occur based on user input. ",(0,r.kt)("inlineCode",{parentName:"p"},"require")," does have the option for an error string. ",(0,r.kt)("inlineCode",{parentName:"p"},"revert")," is very similar to ",(0,r.kt)("inlineCode",{parentName:"p"},"require")," except that ",(0,r.kt)("inlineCode",{parentName:"p"},"revert")," will be called in ",(0,r.kt)("inlineCode",{parentName:"p"},"if ... else")," chains. Both ",(0,r.kt)("inlineCode",{parentName:"p"},"require")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"revert")," will revert the chain state. In ink!, ",(0,r.kt)("inlineCode",{parentName:"p"},"if ... { return Err(Error::SomeError) }")," should be used for ",(0,r.kt)("inlineCode",{parentName:"p"},"require")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"revert"),". When a ",(0,r.kt)("inlineCode",{parentName:"p"},"Result::Err")," is returned in ink!, then all state is reverted."),(0,r.kt)("p",null,"In general, ",(0,r.kt)("inlineCode",{parentName:"p"},"Result::Err")," should be used when a ",(0,r.kt)("em",{parentName:"p"},"calling contract")," needs to know ",(0,r.kt)("em",{parentName:"p"},"why")," a function failed. Otherwise, ",(0,r.kt)("inlineCode",{parentName:"p"},"assert!")," should be used as it has less overhead than a ",(0,r.kt)("inlineCode",{parentName:"p"},"Result"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},'// Solidity\nfunction myFunction(bool returnError) public {\n    require(!returnError, "my error here");\n\n    // or\n\n    if returnError {\n        revert("my error here");\n    }\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// ink!\n\n#[derive(Debug, PartialEq, Eq, scale::Encode, scale::Decode)]\n#[cfg_attr(feature = "std", derive(scale_info::TypeInfo))]\npub enum Error {\n    /// Provide a detailed comment on the error\n    MyError,\n}\n\n// result type\npub type Result<T> = core::result::Result<T, Error>;\n\n// ...\n\n#[ink(message)]\npub fn my_function(&self, return_error: bool) -> Result<()> {\n    if return_error{\n        return Err(Error::MyError)\n    }\n    Ok(())\n}\n')),(0,r.kt)("h3",{id:"nested-mappings--custom--advanced-structures"},(0,r.kt)("inlineCode",{parentName:"h3"},"nested mappings + custom / advanced structures")),(0,r.kt)("p",null,"In Solidity, it is easy to do nested mappings. It is not as straightforward in ink!."),(0,r.kt)("p",null,"imagine the following scenario"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},"// solidity\ncontract Dao {\n    struct Proposal {\n        mapping (address => bool) votedYes\n    }\n\n    mapping (address => bool) public isWhitelisted;\n    Proposal[] public proposals;\n}\n")),(0,r.kt)("p",null,"in ink! this ",(0,r.kt)("em",{parentName:"p"},"seems")," like it could be represented like so:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[ink::contract]\nmod dao {\n\n    #[derive(SpreadAllocate)]\n    pub struct Proposal {\n        voted_yes: Mapping<AccountId, bool>,\n    }\n\n    #[ink(storage)]\n    #[derive(SpreadAllocate)]\n    pub struct Dao {\n        proposals: Vec<Proposal>,\n        is_whitelisted: Mapping<AccountId, bool>,\n    }\n\n    impl Dao{\n        #[ink(constructor)]\n        pub fn new(/*...*/) -> Self {\n            //required for mappings\n            ink_lang::utils::initialize_contract(|contract| {/*...*/})\n        }\n    }\n}\n")),(0,r.kt)("p",null,"However, this will cause an error due to the nested mapping. ",(0,r.kt)("a",{parentName:"p",href:"https://substrate.stackexchange.com/questions/1659/how-to-have-a-mapping-in-a-custom-structure-inside-an-ink-contract"},"This answer")," explains in detail why nested mappings are not allowed"),(0,r.kt)("p",null,"So, as of now, to get around this issue an alternate data structure will need to be used. A data-structure that can be interchanged with the ",(0,r.kt)("inlineCode",{parentName:"p"},"Mapping")," syntax and with minimal additional implementations is the ",(0,r.kt)("inlineCode",{parentName:"p"},"BTreeMap"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"BTreeMap")," is less efficient than ",(0,r.kt)("inlineCode",{parentName:"p"},"Mapping"),", but is an easy workaround until nested mappings are allowed. This will be used in the nested struct. Additional ",(0,r.kt)("inlineCode",{parentName:"p"},"derive"),"s will need to be added to be compatible with the #","[ink(storage)]"," struct (see below)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[ink::contract]\nmod dao {\n\n    use ink_prelude::collections::BTreeMap;\n\n    #[derive(\n        scale::Encode,\n        scale::Decode,\n        SpreadLayout,\n        PackedLayout,\n        SpreadAllocate,\n    )]\n    #[cfg_attr(\n        feature = "std",\n        derive(scale_info::TypeInfo, ink_storage::traits::StorageLayout)\n    )]\n    pub struct Proposal {\n        voted_yes: BTreeMap<AccountId, bool>,\n    }\n\n    #[ink(storage)]\n    #[derive(SpreadAllocate)]\n    pub struct Dao {\n        proposals: Vec<Proposal>,\n        is_whitelisted: Mapping<AccountId, bool>,\n    }\n\n    impl Dao{\n        #[ink(constructor)]\n        pub fn new(/*...*/) -> Self {\n            //required for mappings\n            ink_lang::utils::initialize_contract(|contract| {/*...*/})\n        }\n    }\n}\n')),(0,r.kt)("p",null,"This almost works as expected. However, there is still one issue. ",(0,r.kt)("inlineCode",{parentName:"p"},"SpreadAllocate")," (used with ",(0,r.kt)("inlineCode",{parentName:"p"},"Mapping"),") requires that ",(0,r.kt)("inlineCode",{parentName:"p"},"Vec<Proposal>")," implements ",(0,r.kt)("inlineCode",{parentName:"p"},"PackedAllocate"),". To fix this, ",(0,r.kt)("inlineCode",{parentName:"p"},"Proposal")," needs to implement ",(0,r.kt)("inlineCode",{parentName:"p"},"PackedAllocate"),". See ",(0,r.kt)("a",{parentName:"p",href:"https://docs.rs/ink_storage/3.3.1/ink_storage/traits/trait.PackedAllocate.html"},"here")," for details + examples. See the following for this example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"use ink_primitives::Key;\n\npub struct Proposal {\n    voted_yes: BTreeMap<AccountId, bool>,\n}\n\nimpl ink_storage::traits::PackedAllocate for Proposal {\n    fn allocate_packed(&mut self, at: &Key){\n        PackedAllocate::allocate_packed(&mut *self, at)\n    }\n}\n")),(0,r.kt)("h3",{id:"cross-contract-calling"},(0,r.kt)("inlineCode",{parentName:"h3"},"cross-contract calling")),(0,r.kt)("p",null,"In ink!, to do ",(0,r.kt)("a",{parentName:"p",href:"https://use.ink/basics/cross-contract-calling"},"cross-contract calling"),", the contract will need to be added to the project. Ensure the contract is properly exporting its Structs. See the ",(0,r.kt)("inlineCode",{parentName:"p"},"erc20")," contract example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#![cfg_attr(not(feature = "std"), no_std, no_main)]\n\n// make the structs visible\npub use self::erc20::{\n    Erc20,\n    // this is necessary\n    Erc20Ref,\n};\n\n#[ink::contract]\npub mod erc20 {}\n')),(0,r.kt)("p",null,"In the new cross-called contract's Cargo.toml, add (or edit) the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'[lib]\nname = "erc20"\npath = "lib.rs"\ncrate-type = [\n    # Used for normal contract Wasm blobs.\n    "cdylib",\n    # Used for ABI generation. Necessary for importing as a dependency\n    "rlib",\n]\n\n[features]\nink-as-dependency = []\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ink-as-dependency"),' "tells the ink! code generator to always or never compile the smart contract as if it was used as a dependency of another ink! smart contract" (',(0,r.kt)("a",{parentName:"p",href:"https://use.ink/basics/cross-contract-calling"},"source"),")."),(0,r.kt)("p",null,"Then, In the main contract's Cargo.toml, import the contract that will be cross-called."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'erc20 = { path = "erc20", default-features = false, features = ["ink-as-dependency"] }\n')),(0,r.kt)("p",null,"And make sure to add it to the ",(0,r.kt)("inlineCode",{parentName:"p"},"std")," field of the .toml file."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'[features]\ndefault = ["std"]\nstd = [\n    # ...\n\n    "erc20/std",\n]\n')),(0,r.kt)("p",null,"Now, import the cross-called-contract to the main contract:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// example\nuse erc20::Erc20Ref;\n")),(0,r.kt)("p",null,"There are two methods to setup the other contract."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Instantiate the cross-called-contract in the main contract's constructor.",(0,r.kt)("br",{parentName:"p"}),"\n","See ",(0,r.kt)("a",{parentName:"p",href:"https://use.ink/basics/cross-contract-calling/"},"here")," for a tutorial, and ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/paritytech/ink-examples/tree/main/delegator"},"here")," for an example.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Or, add the ",(0,r.kt)("inlineCode",{parentName:"p"},"AccountId")," of an already deployed contract.\nHere is an example constructor to set this up:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"use my_other_contract::MyOtherContractRef;\n// ...\nfn new(contract_id: AccountId) -> Self {\n     // for already deployed contract\n     let contract_ref: MyOtherContractRef =\n         ink_env::call::FromAccountId::from_account_id(contract_id);\n     Self {contract_ref}\n}\n")))),(0,r.kt)("p",null,"Now, to perform the cross-contract call:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"{\n    self.contract_ref.some_external_function(a_param);\n}\n")),(0,r.kt)("p",null,"Note: as of now (ink! v3.3.1), when using cross-contract calls, emitting events will not work and compile errors will occur. See ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/paritytech/ink/issues/1000"},"issue #1000"),". Furthermore, the compiler will throw an error saying that (for example) Erc20Ref does not implement ",(0,r.kt)("inlineCode",{parentName:"p"},"SpreadAllocate"),". This ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/paritytech/ink/issues/1149"},"issue #1149")," explains more and has a workaround. These issues will be fixed in ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/paritytech/ink/issues/1134"},"issue #1134"),"."),(0,r.kt)("h3",{id:"submit-generic-transaction--dynamic-cross-contract-calling"},(0,r.kt)("inlineCode",{parentName:"h3"},"submit generic transaction / dynamic cross-contract calling")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},"// solidity\n\n// invokes function found at`addr`, sends the `_amount` to the `addr`, and the `_transactionData` payload.\naddr.call.value(_amount)(_transactionData)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// ink!\n\n// ...\n\nuse ink_env::call::{\n    build_call,\n    Call,\n    ExecutionInput,\n    Selector,\n};\n\n/// A wrapper that allows us to encode a blob of bytes.\n///\n/// We use this to pass the set of untyped (bytes) parameters to the `CallBuilder`.\nstruct CallInput<'a>(&'a [u8]);\n\nimpl<'a> scale::Encode for CallInput<'a> {\n    fn encode_to<T: Output + ?Sized>(&self, dest: &mut T) {\n        dest.write(self.0);\n    }\n}\n\n// ...\n\n// see: https://github.com/paritytech/ink-examples/blob/main/multisig/lib.rs#L535\nfn invoke_transaction(\n    &mut self,\n    callee: AccountId,\n    transfer_amount: u128,\n    function_selector: [u8; 4],\n    transaction_data: Vec<u8>,\n    gas_limit: u64) -> Result<()> {\n\n    let result = build_call::<<Self as ::ink_lang::reflect::ContractEnv>::Env>()\n        .call_type(\n            Call::new()\n                .callee(callee) // contract to call\n                .gas_limit(*gas_limit)\n                .transferred_value(transfer_amount), // value to transfer with call\n        )\n        .exec_input(\n            ExecutionInput::new(Selector::from(*function_selector))\n                    .push_arg(CallInput(transaction_data)), // SCALE-encoded parameters\n        )\n        .returns::<()>()\n        .fire()\n        .map_err(|_| Error::TransactionFailed);\n    result\n}\n\n")),(0,r.kt)("p",null,"Note: the ",(0,r.kt)("inlineCode",{parentName:"p"},"function_selector")," bytes can be found in the generated ",(0,r.kt)("inlineCode",{parentName:"p"},"target/ink/<contract-name>.json"),"."),(0,r.kt)("h2",{id:"limitations-of-ink-v3"},"Limitations of ink! v3"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Multi-file projects are not supported with pure ink!",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"implementing traits / interfaces will not work"),(0,r.kt)("li",{parentName:"ul"},"There are alternatives that do add this functionality such as OpenBrush"))),(0,r.kt)("li",{parentName:"ul"},"Nested structs and data structures can be difficult to use"),(0,r.kt)("li",{parentName:"ul"},"Cross-contract calling prevents events from being emitted. See ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/paritytech/ink/issues/1000"},"here")," for details."),(0,r.kt)("li",{parentName:"ul"},"Cross-contract calling can not be tested off-chain with unit tests.\nOn-chain integration tests will need to be used.")),(0,r.kt)("h2",{id:"troubleshooting-errors"},"Troubleshooting Errors"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ERROR: Validation of the Wasm failed."))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"ERROR: Validation of the Wasm failed.\n\nERROR: An unexpected panic function import was found in the contract Wasm.\nThis typically goes back to a known bug in the Rust compiler:\nhttps://github.com/rust-lang/rust/issues/78744\n\nAs a workaround try to insert `overflow-checks = false` into your `Cargo.toml`.\nThis will disable safe math operations, but unfortunately we are currently not\naware of a better workaround until the bug in the compiler is fixed.\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Solution"),(0,r.kt)("br",{parentName:"p"}),"\n","Add the following to the contract Cargo.toml:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"[profile.release]\noverflow-checks = false\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"\"failed to load bitcode of module '...' \""))),(0,r.kt)("p",null,"This happens when trying to import a contract for cross-contract calling."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Solution"),(0,r.kt)("br",{parentName:"p"}),"\n","Ensure that the following is added to Cargo.toml contract import:`"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'features = ["ink-as-dependency"]\n')),(0,r.kt)("p",null,"so the import would look like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'mycontract = { path = "mycontract/", default-features = false, features = ["ink-as-dependency"]}\n')),(0,r.kt)("h2",{id:"unit-testing-off-chain"},"unit testing (off-chain)"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Unit tests are an integral part of smart-contract development and ensuring your code works off-chain before testing on-chain."),(0,r.kt)("li",{parentName:"ul"},"To run ink! tests, do ",(0,r.kt)("em",{parentName:"li"},"not")," use ",(0,r.kt)("inlineCode",{parentName:"li"},"cargo +nightly contract test"),". Use ",(0,r.kt)("inlineCode",{parentName:"li"},"cargo +nightly test"),". Add the ",(0,r.kt)("inlineCode",{parentName:"li"},"--nocapture")," flag for debug prints to show. See ",(0,r.kt)("a",{parentName:"li",href:"https://substrate.stackexchange.com/questions/3197/how-to-understand-which-test-failed-in-ink"},"here")," for more info on why."),(0,r.kt)("li",{parentName:"ul"},"From the contract module, make sure to make the contract struct and anything else that is going to be used in the unit tests public. For example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// top of file\n#![cfg_attr(not(feature = "std"), no_std)]\n\nuse ink_lang as ink;\n\npub use self::mycontract::{\n    MyContract\n};\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Off-chain unit tests will not work with cross-contract calls.\nOne workaround to ensure unit tests are still passing is to provide mock data.")),(0,r.kt)("p",null,"An easy approach is to use conditional compiling with ",(0,r.kt)("inlineCode",{parentName:"p"},"#[cfg(test)]")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"#[cfg(not(test))]"),"."),(0,r.kt)("p",null,"Note: this solution is not ideal. ink! v4.0 will provide much better solutions."),(0,r.kt)("p",null,"For example, here is a read-only ERC20 cross-contract call:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// only compiles when *not* running tests\n#[cfg(not(test))]\nfn get_token_balance(&self, caller: &AccountId) -> Balance {\n    // calls the external ERC-20 contract\n    self.token.balance_of(*caller)\n}\n\n// only compiles when running tests\n#[cfg(test)]\nfn get_token_balance(&self, _: &AccountId) -> Balance {\n    // arbitrary value\n    1\n}\n")),(0,r.kt)("p",null,"And if the cross-contract call ",(0,r.kt)("em",{parentName:"p"},"writes")," to storage, a mock field can be added to the contract struct. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[ink(storage)]\npub struct MyContract {\n    #[cfg(test)]\n    mock_field: SomeStruct, // will serve as a fake storage\n}\n\n...\n\n// on-chain, performs cross-contract call\n#[cfg(not(test))]\nfn do_some_write(&mut self) {\n    self.external_contract.write_to_field(0xDEADBEEF);\n}\n\n\n// testing environment only\n#[cfg(test)]\nfn do_some_write(&mut self) {\n    self.mock_field.my_fake_storage_item = 0xDEADBEEF;\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"useful code to interact and modify the contract environment for testing")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://paritytech.github.io/ink/ink_env/test/index.html"},"ink_env docs")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// get the default accounts (alice, bob, ...)\nlet accounts = ink_env::test::default_accounts::<ink_env::DefaultEnvironment>();\naccounts.alice //usage example\n\n// set which account calls the contract\nink_env::test::set_caller::<ink_env::DefaultEnvironment>(accounts.bob);\n\n// get the contract's address\nlet callee = ink_env::account_id::<ink_env::DefaultEnvironment>();\n\n// set the contracts address.\n// by default, this is alice's account\nink_env::test::set_callee::<ink_env::DefaultEnvironment>(callee);\n\n// transfer native currency to the contract\nink_env::test::set_value_transferred::<ink_env::DefaultEnvironment>(2);\n\n// increase block number (and block timestamp).\n// this can be placed in a loop to advance the block many times\nink_env::test::advance_block::<ink_env::DefaultEnvironment>();\n\n// generate arbitrary AccountId\nAccountId::from([0x01; 32]);\n\n// generate arbitrary Hash\nHash::from([0x01; 32])\n\n// macro for tests that are expected to panic.\n#[should_panic]\n")))}u.isMDXComponent=!0}}]);