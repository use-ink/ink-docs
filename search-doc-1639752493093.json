[{"title":"Cargo.toml","type":0,"sectionRef":"#","url":"basics/cargo-toml","content":"Cargo.toml TODO go through a typical Cargo.toml and explain what the dependencies mean","keywords":""},{"title":"Contract Template","type":0,"sectionRef":"#","url":"basics/contract-template","content":"Contract Template Change into your working directory and run: cargo contract new foobar Copy This will create a new project folder named foobar. cd foobar/ Copy In the lib.rs file you find initial scaffolded code, which you can use as a starting point. Quickly check that it compiles and the trivial tests pass with: cargo +nightly test Copy Also check that you can build the Wasm file by running: cargo +nightly contract build Copy If everything looks good, then we are ready to start programming!","keywords":""},{"title":"Cross-Contract Calling","type":0,"sectionRef":"#","url":"basics/cross-contract-calling","content":"","keywords":""},{"title":"How it Worksâ€‹","type":1,"pageTitle":"Cross-Contract Calling","url":"basics/cross-contract-calling#how-it-works","content":"In order to deploy the delegator smart contract we first have to manually put the code of the other contract, receive its code hash from the signalled event and put their code hash into our calling smart contract. The calling contract looks like this: use ink_storage::Lazy; use other_contract::OtherContract; //--snip-- #[ink(storage)] struct MyContract { /// The other contract. other_contract: Lazy&lt;OtherContract&gt;, } impl MyContract { /// Instantiate `MyContract with the given /// sub-contract codes and some initial value. #[ink(constructor)] pub fn new( other_contract_code_hash: Hash, ) -&gt; Self { let other_contract = OtherContract::new(1337) .endowment(total_balance / 4) .code_hash(other_contract_code_hash) .instantiate() .expect(&quot;failed at instantiating the `OtherContract` contract&quot;); Self { other_contract } } /// Calls the other contract. #[ink(message)] pub fn call_other_contract(&amp;self) -&gt; i32 { self.other_contract.get_value() } } //--snip-- Copy It's Cargo.toml contains other_contract = { path = &quot;other_contract&quot;, default-features = false, features = [&quot;ink-as-dependency&quot;] } Copy The other_contract/Cargo.toml contains this: [features] ink-as-dependency = [] Copy Tells the ink! code generator to always or nevercompile the smart contract as if it was used as a dependency of another ink! smart contract. The other_contract/lib.rs: #[ink::contract] pub mod other_contract { /// Storage for the other contract. #[ink(storage)] pub struct OtherContract { value: i32, } impl OtherContract { /// Initializes the contract. #[ink(constructor)] pub fn new(value: i32) -&gt; Self { Self { value } } /// Returns the current state. #[ink(message)] pub fn get_value(&amp;self) -&gt; i32 { self.value } } } Copy "},{"title":"Environment Functions","type":0,"sectionRef":"#","url":"basics/environment-functions","content":"Environment Functions ink! exposes a number of handy environment functions. A full overview is found here. In an #[ink(constructor)] use Self::env() to access those, in an #[ink(message)] use self.env(). So e.g. Self::env().caller() or self.env().caller(). Some handy functions include: caller(): Returns the address of the caller of the executed contract. An example of how to utilize this particular call is found here.account_id(): Returns the account ID of the executed contract.balance(): Returns the balance of the executed contract.block_number(): Returns the current block number.random(): Returns a random hash seed.emit_event(â€¦): Emits an event with the given event data.transfer(â€¦): Transfers value from the contract to the destination account ID.hash_bytes(â€¦): Conducts the crypto hash of the given input and stores the result in output.â€¦and many more.","keywords":""},{"title":"Contract Testing","type":0,"sectionRef":"#","url":"basics/contract-testing","content":"","keywords":""},{"title":"Unit Testsâ€‹","type":1,"pageTitle":"Contract Testing","url":"basics/contract-testing#unit-tests","content":"Testing contracts off-chain is done by cargo test and users can simply use the standard routines of creating unit test modules within the ink! project: #[cfg(test)] mod tests { use super::*; #[test] fn my_test() { ... } } Copy Test instances of contracts can be created with something like: let contract = MyContract::my_constructor(a, b); Copy Messages can simply be called on the returned instance as if MyContract::my_constructor returns aSelf instance. See the flipper example. "},{"title":"Off-chain Testingâ€‹","type":1,"pageTitle":"Contract Testing","url":"basics/contract-testing#off-chain-testing","content":"ink! smart contracts can compile in several different modes. There are two main compilation models using either on-chain mode: no_std + WebAssembly as targetoff-chain mode: std We generally use the on-chain mode for actual smart contract deployment whereas we use the off-chain mode for smart contract testing using the off-chain environment provided by the ink_env crate. The #[ink::test] proc. macro enables more elaborate off-chain testing. If you annotate a test with this attribute it will be executed in a simulated environment, similar to as it would be run on-chain. You then have fine-grained control over how a contract is called; for example you can influence the block advancement, the value transferred to it, by which account it is called, which storage it is run with, etc.. See the examples/erc20 contract on how to utilize those or the documentation for details. At the moment there are some known limitations to our off-chain environment and we are working on making it behave as close to the real chain environment as possible. Defines a unit test that makes use of ink!'s off-chain testing capabilities. If your unit test does not require the existence of an off-chain environment it is fine to not use this macro since it bears some overhead with the test. Note that this macro is not required to run unit tests that require ink!'s off-chain testing capabilities but merely improves code readability. "},{"title":"How do you find out if your test requires the off-chain environment?â€‹","type":1,"pageTitle":"Contract Testing","url":"basics/contract-testing#how-do-you-find-out-if-your-test-requires-the-off-chain-environment","content":"Normally if the test recursively uses or invokes some contract methods that call a method defined in self.env() or Self::env(). An examples is the following: let caller: AccountId = self.env().caller(); Copy "},{"title":"Exampleâ€‹","type":1,"pageTitle":"Contract Testing","url":"basics/contract-testing#example","content":"use ink_lang as ink; #[cfg(test)] mod tests { // Conventional unit test that works with assertions. #[ink::test] fn test1() { // test code comes here as usual } // Conventional unit test that returns some Result. // The test code can make use of operator-`?`. #[ink::test] fn test2() -&gt; Result&lt;(), ink_env::Error&gt; { // test code that returns a Rust Result type } } Copy "},{"title":"On-chain Testingâ€‹","type":1,"pageTitle":"Contract Testing","url":"basics/contract-testing#on-chain-testing","content":"The easiest way to do on-chain testing is torun a local substrate node, deploy your contract there and interact with it. use ink_lang as ink; #[ink::contract] mod greeter { #[ink(storage)] pub struct Greeter; impl Greeter { #[ink(constructor)] pub fn new() -&gt; Self { let caller = Self::env().caller(); let message = format!(&quot;thanks for instantiation {:?}&quot;, caller); ink_env::debug_println(&amp;message); Greeter {} } #[ink(message, payable)] pub fn fund(&amp;mut self) { let caller = self.env().caller(); let value = self.env().transferred_balance(); let message = format!(&quot;thanks for the funding of {:?} from {:?}&quot;, value, caller); ink_env::debug_println(&amp;message); } } } Copy "},{"title":"Events","type":0,"sectionRef":"#","url":"basics/events","content":"","keywords":""},{"title":"Event Definitionâ€‹","type":1,"pageTitle":"Events","url":"basics/events#event-definition","content":"This is how an event definition looks: #[ink(event)] pub struct Transferred { #[ink(topic)] from: Option&lt;AccountId&gt;, #[ink(topic)] to: Option&lt;AccountId&gt;, amount: Balance } Copy Add the #[ink(topic)] attribute tag to each item in your event that you want to have indexed. A good rule of thumb is to ask yourself if somebody might want to search for this topic. For this reason the amount in the exemplary event above was not made indexable â€’ there will most probably be a lot of different events with differing amounts each. The signature of the event is by default one of the topics of the event, except if you annotate the event with #[ink(anonymous)]. See here for details on this attribute. "},{"title":"Emitting Events in a Constructorâ€‹","type":1,"pageTitle":"Events","url":"basics/events#emitting-events-in-a-constructor","content":"In a constructor events are emitted via Self::env().emit_event(). See this example: #[ink(constructor)] pub fn new(initial_value: Balance) -&gt; Self { let caller = Self::env().caller(); let mut balances = HashMap::new(); balances.insert(caller, initial_supply); Self::env().emit_event(Transferred { from: None, to: Some(caller), amount: initial_supply }); Self { total_supply: initial_supply, balances } } Copy "},{"title":"Emitting Events from Messagesâ€‹","type":1,"pageTitle":"Events","url":"basics/events#emitting-events-from-messages","content":"In a message events are emitted via self.env().emit_event(): #[ink(message)] pub fn transfer(&amp;mut self, to: AccountId, amount: Balance) -&gt; Result { let from = self.env().caller(); // implementation hidden self.env().emit_event(Transferred { from: Some(from), to: Some(to), amount }); Ok(()) } Copy "},{"title":"Mutating Storage Values","type":0,"sectionRef":"#","url":"basics/mutating-values","content":"","keywords":""},{"title":"Mutable and Immutable Functionsâ€‹","type":1,"pageTitle":"Mutating Storage Values","url":"basics/mutating-values#mutable-and-immutable-functions","content":"You may have noticed that the function template included self as the first parameter of the contract functions. It is through self that you gain access to all your contract functions and storage items. If you are simply reading from the contract storage, you only need to pass &amp;self. But if you want to modify storage items, you will need to explicitly mark it as mutable, &amp;mut self. impl MyContract { #[ink(message)] pub fn my_getter(&amp;self) -&gt; u32 { self.my_number } #[ink(message)] pub fn my_setter(&amp;mut self, new_value: u32) { self.my_number = new_value; } } Copy "},{"title":"Lazy Storage Valuesâ€‹","type":1,"pageTitle":"Mutating Storage Values","url":"basics/mutating-values#lazy-storage-values","content":"There is a Lazy type that can be used for ink! storage values that do not need to be loaded in some or most cases. Many simple ink! examples do not require the use of Lazy values. Since there is some overhead associated with Lazy values, they should only be used where required. This is an example of using the Lazy type: #[ink(storage)] pub struct MyContract { // Store some number my_number: ink_storage::Lazy&lt;u32&gt;, } impl MyContract { #[ink(constructor)] pub fn new(init_value: i32) -&gt; Self { Self { my_number: ink_storage::Lazy::&lt;u32&gt;::new(init_value), } } #[ink(message)] pub fn my_setter(&amp;mut self, new_value: u32) { ink_storage::Lazy::&lt;u32&gt;::set(&amp;mut self.my_number, new_value); } #[ink(message)] pub fn my_adder(&amp;mut self, add_value: u32) { let my_number = &amp;mut self.my_number; let cur = ink_storage::Lazy::&lt;u32&gt;::get(my_number); ink_storage::Lazy::&lt;u32&gt;::set(my_number, cur + add_value); } } Copy "},{"title":"Reading Values from Storage","type":0,"sectionRef":"#","url":"basics/reading-values","content":"","keywords":""},{"title":"Contract Functionsâ€‹","type":1,"pageTitle":"Reading Values from Storage","url":"basics/reading-values#contract-functions","content":"As you can see in the contract template, all of your contract functions are part of your contract module. impl MyContract { // Public and Private functions can go here } Copy "},{"title":"Public and Private Functionsâ€‹","type":1,"pageTitle":"Reading Values from Storage","url":"basics/reading-values#public-and-private-functions","content":"In Rust, you can make as many implementations as you want. As a stylistic choice, we recommend breaking up your implementation definitions for your private and public functions: impl MyContract { /// Public function #[ink(message)] pub fn my_public_function(&amp;self) { /* --snip-- */ } /// Private function fn my_private_function(&amp;self) { /* --snip-- */ } /* --snip-- */ } Copy You can also choose to split things up however is most clear for your project. Note that all public functions must use the #[ink(message)] attribute. "},{"title":"Getting a Valueâ€‹","type":1,"pageTitle":"Reading Values from Storage","url":"basics/reading-values#getting-a-value","content":"We already showed you how to initialize a storage value in the chapter Storing Values. Getting the value is just as simple: impl MyContract { #[ink(message)] pub fn my_getter(&amp;self) -&gt; u32 { self.number } } Copy In Rust, if the last expression in a function does not have a semicolon, then it will be the return value. "},{"title":"Storing Values","type":0,"sectionRef":"#","url":"basics/storing-values","content":"","keywords":""},{"title":"Supported Typesâ€‹","type":1,"pageTitle":"Storing Values","url":"basics/storing-values#supported-types","content":"Substrate contracts may store types that are encodable and decodable withParity Codec which includes most Rust common data types such as bool, u{8,16,32,64,128}, i{8,16,32,64,128}, String, tuples, and arrays. ink! provides Substrate specific types like AccountId, Balance, and Hash to smart contracts as if they were primitive types. ink! also provides storage types for more elaborate storage interactions through the storage module: use ink_storage::collections::{Vec, HashMap, Stash, Bitvec}; Copy Here is an example of how you would store an AccountId and Balance: // We are importing the default ink! types use ink_lang as ink; #[ink::contract] mod MyContract { // Our struct will use those default ink! types #[ink(storage)] pub struct MyContract { // Store some AccountId my_account: AccountId, // Store some Balance my_balance: Balance, } /* --snip-- */ } Copy You can find all the supported Substrate types in the ink_storage crate. "},{"title":"Initializing Storage in Constructorsâ€‹","type":1,"pageTitle":"Storing Values","url":"basics/storing-values#initializing-storage-in-constructors","content":"Constructors are how values get initialized. Every ink! smart contract must have a constructor which is run once when a contract is created. ink! smart contracts can have multiple constructors: use ink_lang as ink; #[ink::contract] mod mycontract { #[ink(storage)] pub struct MyContract { number: u32, } impl MyContract { /// Constructor that initializes the `u32` value to the given `init_value`. #[ink(constructor)] pub fn new(init_value: u32) -&gt; Self { Self { number: init_value, } } /// Constructor that initializes the `u32` value to the `u32` default. #[ink(constructor)] pub fn default() -&gt; Self { Self { number: Default::default(), } } /* --snip-- */ } } Copy "},{"title":"Trait Definitions","type":0,"sectionRef":"#","url":"basics/trait-definitions","content":"","keywords":""},{"title":"Exampleâ€‹","type":1,"pageTitle":"Trait Definitions","url":"basics/trait-definitions#example","content":"Defined in the base_erc20.rs module. use ink_lang as ink; #[ink::trait_definition] pub trait BaseErc20 { /// Creates a new ERC-20 contract and initializes it with the initial supply for the instantiator. #[ink(constructor)] fn new(initial_supply: Balance) -&gt; Self; /// Returns the total supply. #[ink(message)] fn total_supply(&amp;self) -&gt; Balance; /// Transfers `amount` from caller to `to`. #[ink(message, payable)] fn transfer(&amp;mut self, to: AccountId, amount: Balance); } Copy An ink! smart contract definition can then implement this trait definition as follows: use ink_lang as ink; #[ink::contract] mod erc20 { use base_erc20::BaseErc20; #[ink(storage)] pub struct Erc20 { total_supply: Balance, // more fields ... } impl BaseErc20 for Erc20 { #[ink(constructor)] fn new(initial_supply: Balance) -&gt; Self { // implementation ... } #[ink(message)] fn total_supply(&amp;self) -&gt; Balance { // implementation ... } #[ink(message, payable)] fn transfer(&amp;mut self, to: AccountId, amount: Balance) { // implementation ... } } } Copy Calling the above Erc20 explicitely through its trait implementation can be done just as if it was normal Rust code: // --- Instantiating the ERC-20 contract: // let mut erc20 = &lt;Erc20 as BaseErc20&gt;::new(1000); // --- Is just the same as: use base_erc20::BaseErc20; let mut erc20 = Erc20::new(1000); // --- Retrieving the total supply: // assert_eq!(&lt;Erc20 as BaseErc20&gt;::total_supply(&amp;erc20), 1000); // --- Is just the same as: use base_erc20::BaseErc20; assert_eq!(erc20.total_supply(), 1000); Copy There are still many limitations to ink! trait definitions and trait implementations. For example it is not possible to define associated constants or types or have default implemented methods. These limitations exist because of technical intricacies, however, please expect that many of those will be tackled in future ink! releases. Marks trait definitions to ink! as special ink! trait definitions. There are some restrictions that apply to ink! trait definitions that this macro checks. Also ink! trait definitions are required to have specialized structure so that the main #[ink::contract] macro can properly generate code for its implementations. Example: Definition use ink_lang as ink; type Balance = &lt;ink_env::DefaultEnvironment as ink_env::Environment&gt;::Balance; #[ink::trait_definition] pub trait Erc20 { /// Constructs a new ERC-20 compliant smart contract using the initial supply. #[ink(constructor)] fn new(initial_supply: Balance) -&gt; Self; /// Returns the total supply of the ERC-20 smart contract. #[ink(message)] fn total_supply(&amp;self) -&gt; Balance; // etc. } Copy Example: Implementation Given the above trait definition you can implement it as shown below: use ink_lang as ink; #[ink::contract] mod base_erc20 { /// We somehow cannot put the trait in the doc-test crate root due to bugs. #[ink_lang::trait_definition] pub trait Erc20 { Constructors a new ERC-20 compliant smart contract using the initial supply. #[ink(constructor)] fn new(initial_supply: Balance) -&gt; Self; /// Returns the total supply of the ERC-20 smart contract. #[ink(message)] fn total_supply(&amp;self) -&gt; Balance; } #[ink(storage)] pub struct BaseErc20 { total_supply: Balance, // etc .. } impl Erc20 for BaseErc20 { #[ink(constructor)] fn new(initial_supply: Balance) -&gt; Self { Self { total_supply: initial_supply } } /// Returns the total supply of the ERC-20 smart contract. #[ink(message)] fn total_supply(&amp;self) -&gt; Balance { self.total_supply } // etc .. } } Copy "},{"title":"Overview","type":0,"sectionRef":"#","url":"cargo-contract-cli","content":"","keywords":""},{"title":"Installationâ€‹","type":1,"pageTitle":"Overview","url":"cargo-contract-cli#installation","content":"As a pre-requisite for the tool you need to install the binaryen package, which is used to optimize the WebAssembly bytecode of the contract. Many package managers have it available nowadays â€’ e.g. it's a package for Debian/Ubuntu,Homebrew and Arch Linux. After you've installed the package execute: cargo install cargo-contract --vers ^0.15 --force --locked Copy Use the --force to ensure you are updated to the most recent cargo-contract version. You can then use cargo contract --help to start exploring the commands made available to you. "},{"title":"Usageâ€‹","type":1,"pageTitle":"Overview","url":"cargo-contract-cli#usage","content":"In order to initialize a new ink! project you can use: cargo contract new flipper Copy This will create a folder flipper in your work directory. The folder contains a scaffold Cargo.toml and a lib.rs, which both contain the necessary building blocks for using ink!. The lib.rs contains our hello world contract â€’ the Flipper, which we explain in the next section. In order to build the contract just execute these commands in the flipper folder: cargo contract build Copy As a result you'll get the file target/flipper.contract. It's a JSON which bundles the contract's metadata and its Wasm blob. This file needs to be used when deploying the contract. You additionally get the individual target/flipper.wasm and target/metadata.json in the folder as well. "},{"title":"Call a Contract","type":0,"sectionRef":"#","url":"cargo-contract-cli/call","content":"Call a Contract TODO","keywords":""},{"title":"Instantiate a Contract","type":0,"sectionRef":"#","url":"cargo-contract-cli/instantiate","content":"Instantiate a Contract TODO I am trying to deploy and instantiate a contract using a custom-built cargo-contract with the extrinsics feature. The 'deploy' and 'instantiate' commands require a &quot;secret key uri&quot; and &quot;secret key password&quot; that I don't know how to find for my canvas devnet. Can somebody help me understand what these are and how to obtain them? You probably just need to the key for some account with enough funds to deploy and instantiate the contract...I don't think the key is specific to the node in any way If you're running the Canvas node in dev mode, these are the accounts that are pre-funded https://github.com/paritytech/canvas-node/blob/master/node/src/chain_spec.rs#L76People typically use Alice...her information is here https://docs.substrate.io/v3/tools/subkey/#well-known-keys I guess you'd just leave the password blank So the secret key URI will be bottom drive obey lake curtain smoke basket hold race lonely fit walk//Alice I think","keywords":""},{"title":"Deploy a Contract","type":0,"sectionRef":"#","url":"cargo-contract-cli/deploy","content":"Deploy a Contract TODO","keywords":""},{"title":"Custom Datastructures","type":0,"sectionRef":"#","url":"datastructures/custom-datastructure","content":"Custom Datastructures While the ink_storage crate provides tons of useful utilities and data structures to organize and manipulate the contract's storage contract authors are not limited by its capabilities. By implementing the core SpreadLayout/PackedLayout traits (and the StorageLayout trait for supporting the metadata generated for the .contract bundle) users are able to define their very own custom storage data structures with their own set of requirement and features that work along the ink_storage data structures as long as they fulfill the mere requirements stated by those two traits. In the future we plan on providing some more ink! workshops and tutorials guiding the approach to design and implement a custom storage data structure.","keywords":""},{"title":"Dynamic Storage Allocator","type":0,"sectionRef":"#","url":"datastructures/dynamic-allocation","content":"Dynamic Storage Allocator In the previous section we have seen how the default mode of operation is to spread information and how we can opt-in to pack information into single cells via ink_storage::Packed. However, what if we wanted to store a vector of a vector of i32 for example? Naturally a user would try to construct this as follows: use ink_storage::Vec as StorageVec; #[ink(storage)] pub struct Matrix { values: StorageVec&lt;StorageVec&lt;i32&gt;&gt;, } Copy However, this will fail compilation with an error indicating that StorageVec&lt;T&gt; requires for its T to be packed (T: PackedLayout) which StorageVec&lt;T&gt; itself does not since it always stores all of its elements into different cells. The same applies to many other storage data structures provided by ink_storage and is a trade-off the ink! team decided for the case of efficiency of the overall system. Instead what a user can do in order to get their vector-of-vector to be working is to make use of ink!'s dynamic storage allocator capabilities. For this the contract author has to first enable the feature via: use ink_lang as ink; #[ink::contract(dynamic_storage_allocator = true)] mod matrix { // contract code ... } Copy And then we can define our Matrix #[ink(storage)] as follows: use ink_storage::{ Vec as StorageVec, Box as StorageBox, }; #[ink(storage)] pub struct Matrix { values: StorageVec&lt;StorageBox&lt;StorageVec&lt;i32&gt;&gt;&gt;, } Copy With ink_storage::Box&lt;T&gt; we can use a T: SpreadLayout as if it was T: PackedLayout since the ink_storage::Box&lt;T&gt; itself suffices the requirements and can be put into a single contract storage cell. The whole concept works quite similar to how Rust's Box works: by an indirection - contract authors are therefore advised to make use of dynamic storage allocator capabilities only if other ways of dealing with ones problems are not applicable.","keywords":""},{"title":"Opt out of Storage","type":0,"sectionRef":"#","url":"datastructures/opting-out","content":"Opt out of Storage If you are in need of storing some temporary information across method and message boundaries ink! will have your back with the ink_storage::Memory abstraction. It allows you to simply opt-out of using the storage for the wrapped entity at all and thus is very similar to Solidity's very own memory annotation. An example below: #[ink(storage)] pub struct OptedOut { a: i32, b: ink_storage::Lazy&lt;i32&gt;, c: ink_storage::Memory&lt;i32&gt;, } Copy The the above example a and b are normal storage entities, however, c on the other hand side will never load from or store to contract storage and will always be reset to the default value of its i32 type for every contract call. It can be accessed from all ink! messages or methods via self.c, but will never manipulate the contract storage and thus acts wonderfully as some shared local information.","keywords":""},{"title":"Working with Datastructures","type":0,"sectionRef":"#","url":"datastructures/hashmap","content":"","keywords":""},{"title":"Storage HashMap APIâ€‹","type":1,"pageTitle":"Working with Datastructures","url":"datastructures/hashmap#storage-hashmap-api","content":"You can find the full HashMap API in the crate documentation part of ink!. Here are some of the most common functions you might use: /// Inserts a key-value pair into the map. /// Returns the previous value associated with the same key if any. /// If the map did not have this key present, `None` is returned. pub fn insert(&amp;mut self, key: K, new_value: V) -&gt; Option&lt;V&gt; {/* --snip-- */} /// Removes the key/value pair from the map associated with the given key. /// /// - Returns the removed value if any. pub fn take&lt;Q&gt;(&amp;mut self, key: &amp;Q) -&gt; Option&lt;V&gt; {/* --snip-- */} /// Returns a shared reference to the value corresponding to the key. /// /// The key may be any borrowed form of the map's key type, /// but `Hash` and `Eq` on the borrowed form must match those for the key type. pub fn get&lt;Q&gt;(&amp;self, key: &amp;Q) -&gt; Option&lt;&amp;V&gt; {/* --snip-- */} /// Returns a mutable reference to the value corresponding to the key. /// /// The key may be any borrowed form of the map's key type, /// but `Hash` and `Eq` on the borrowed form must match those for the key type. pub fn get_mut&lt;Q&gt;(&amp;mut self, key: &amp;Q) -&gt; Option&lt;&amp;mut V&gt; {/* --snip-- */} /// Returns `true` if there is an entry corresponding to the key in the map. pub fn contains_key&lt;Q&gt;(&amp;self, key: &amp;Q) -&gt; bool {/* --snip-- */} /// Converts the OccupiedEntry into a mutable reference to the value in the entry /// with a lifetime bound to the map itself. pub fn into_mut(self) -&gt; &amp;'a mut V {/* --snip-- */} /// Gets the given key's corresponding entry in the map for in-place manipulation. pub fn entry(&amp;mut self, key: K) -&gt; Entry&lt;K, V&gt; {/* --snip-- */} Copy "},{"title":"Initializing a HashMapâ€‹","type":1,"pageTitle":"Working with Datastructures","url":"datastructures/hashmap#initializing-a-hashmap","content":"Not initializing storage before you use it is a common error that can break your smart contract. For each key in a storage value, the value needs to be set before you can use it. To do this, we will create a private function which handles when the value is set and when it is not, and make sure we never work with uninitialized storage. So given my_number_map, imagine we wanted the default value for any given key to be 0. We can build a function like this:  #![cfg_attr(not(feature = &quot;std&quot;), no_std)] use ink_lang as ink; #[ink::contract] mod mycontract { #[ink(storage)] pub struct MyContract { // Store a mapping from AccountIds to a u32 my_number_map: ink_storage::collections::HashMap&lt;AccountId, u32&gt;, } impl MyContract { /// Public function. /// Default constructor. #[ink(constructor)] pub fn default() -&gt; Self { Self { my_number_map: Default::default(), } } /// Private function. /// Returns the number for an AccountId or 0 if it is not set. fn my_number_or_zero(&amp;self, of: &amp;AccountId) -&gt; u32 { let balance = self.my_number_map.get(of).unwrap_or(&amp;0); *balance } } } Copy Here we see that after we get the reference from my_number_map we call unwrap_or which will either unwrap the reference, or if there is no value, return some known reference. Then, when building functions that interact with this HashMap, you need to always remember to call this function rather than getting the value directly from storage. Here is an example:  #![cfg_attr(not(feature = &quot;std&quot;), no_std)] use ink_lang as ink; #[ink::contract] mod mycontract { #[ink(storage)] pub struct MyContract { // Store a mapping from AccountIds to a u32 my_number_map: ink_storage::collections::HashMap&lt;AccountId, u32&gt;, } impl MyContract { // Get the value for a given AccountId #[ink(message)] pub fn get(&amp;self, of: AccountId) -&gt; u32 { self.my_number_or_zero(&amp;of) } // Get the value for the calling AccountId #[ink(message)] pub fn get_my_number(&amp;self) -&gt; u32 { let caller = self.env().caller(); self.my_number_or_zero(&amp;caller) } // Returns the number for an AccountId or 0 if it is not set. fn my_number_or_zero(&amp;self, of: &amp;AccountId) -&gt; u32 { let value = self.my_number_map.get(of).unwrap_or(&amp;0); *value } } } Copy "},{"title":"Contract Callerâ€‹","type":1,"pageTitle":"Working with Datastructures","url":"datastructures/hashmap#contract-caller","content":"As you might have noticed in the example above, we use a special function called self.env().caller(). This function is available throughout the contract logic and will always return to you the contract caller. NOTE: The contract caller is not the same as the origin caller. If a user triggers a contract which then calls a subsequent contract, the self.env().caller() in the second contract will be the address of the first contract, not the original user. self.env().caller() can be used in a number of different ways. In the example above, we are basically creating an &quot;access control&quot; layer which only allows users to access their own values. You can also save the contract owner during contract deployment for future references:  #![cfg_attr(not(feature = &quot;std&quot;), no_std)] use ink_lang as ink; #[ink::contract] mod mycontract { #[ink(storage)] pub struct MyContract { // Store a contract owner owner: AccountId, } impl MyContract { #[ink(constructor)] pub fn new() -&gt; Self { Self { owner: Self::env().caller(); } } /* --snip-- */ } } Copy Then you can write permissioned functions which checks that the current caller is the owner of the contract. "},{"title":"Modifying a HashMapâ€‹","type":1,"pageTitle":"Working with Datastructures","url":"datastructures/hashmap#modifying-a-hashmap","content":"Making changes to the value of a HashMap is just as sensitive as getting the value. If you try to modify some value before it has been initialized, your contract will panic! But have no fear, we can continue to use the my_number_or_zero function we created to protect us from these situations! impl MyContract { /* --snip-- */ /// Set the value for the calling AccountId #[ink(message)] pub fn set_my_number(&amp;mut self, value: u32) { let caller = self.env().caller(); self.my_number_map.insert(caller, value); } /// Add a value to the existing value for the calling AccountId #[ink(message)] pub fn add_my_number(&amp;mut self, value: u32) { let caller = self.env().caller(); let my_number = self.my_number_or_zero(&amp;caller); self.my_number_map.insert(caller, my_number + value); } /// Returns the number for an AccountId or 0 if it is not set. fn my_number_or_zero(&amp;self, of: &amp;AccountId) -&gt; u32 { *self.my_number_map.get(of).unwrap_or(&amp;0) } } Copy Here we have written two kinds of functions which modify a HashMap. One simply inserts the value directly into storage, with no need to read the value first, and another one modifies the existing value. Note how we can always insert the value without worry, as that initialized the value in storage, but before you can get or modify anything, we need to call my_number_or_zero to make sure we are working with a real value. "},{"title":"Entry APIâ€‹","type":1,"pageTitle":"Working with Datastructures","url":"datastructures/hashmap#entry-api","content":"We will not always have an existing value on our contract's storage. We can take advantage of the Rust Option&lt;T&gt; type to help us. If there's no value on the contract storage we will insert a new one; on the contrary if there is an existing value we will only update it. ink! HashMaps expose the well-knownHashMap Entry APIthat we can use to achieve this type of &quot;upsert&quot; behavior: let caller = self.env().caller(); self.my_number_map .entry(caller) .and_modify(|old_value| *old_value += by) .or_insert(by); Copy "},{"title":"Overview","type":0,"sectionRef":"#","url":"datastructures/overview","content":"Overview The ink_storage crate acts as the standard storage library for ink! smart contracts. It provides all the necessary tools and data structures to organize and operate the contract's storage intuitively and efficiently. You can find the crates documentation for all ink! data structures here. At the moment we provide these data structures: BinaryHeap: A priority queue implemented with a binary heap.BitStash A stash for bits operating on the contract storage.Bitvec A storage bit vector.HashMap A hash map operating on the contract storage.SmallVec A contiguous growable array type.Stash A stash data structure operating on contract storage.Vec A contiguous growable array type, written Vec&lt;T&gt; but pronounced 'vector'. Data structures provided by the ink_storage crate are inherently lazy; they are either high-level lazy or low-level lazy data structures. The difference between high-level and low-level lies in the distinction in how these data structures are aware of the elements that they operate on. For high-level data structures they are fully aware about the elements they contain, do all the clean-up by themselves so the user can concentrate on the business logic. For low-level data structures the responsibility about the elements lies in the hands of the contract author. Also they operate on cells (Option&lt;T&gt;) instead of entities of type T. But what does that mean exactly? The ink_storage::Lazy type caches their entities and acts lazily on the storage. This means that a read or write operation is only performed when it really needs to in order to satisfy other inputs. Data types such as Rust primitives i32 or Rust's very own Vec or data structures can also be used to operate on the contract's storage, however, they will load their contents eagerly which is often not what you want. An example follows with the below contract storage and a message that operates on either of the two fields. #[ink(storage)] pub struct TwoValues { offset: i32, a: i32, b: i32, } impl TwoValues { #[ink(message)] pub fn set(&amp;mut self, which: bool, new_value: i32) { match which { true =&gt; { self.a = self.offset + new_value; }, false =&gt; { self.b = self.offset + new_value; }, } } } Copy Whenever we call TwoValues::set always both a and b are loaded despite the fact the we only operate on one of them at a time. This is very costly since storage accesses are in fact database look-ups. In order to prevent this eager loading of storage contents we can make use of ink_storage::Lazy or other lazy data structures defined in that crate: #[ink(storage)] pub struct TwoValues { offset: i32, a: ink_storage::Lazy&lt;i32&gt;, b: ink_storage::Lazy&lt;i32&gt;, } impl TwoValues { #[ink(message)] pub fn set(&amp;mut self, which: bool, new_value: i32) { match which { true =&gt; Lazy::set(&amp;self.a, self.offset + new_value), false =&gt; Lazy::set(&amp;self.b, self.offset + new_value), } } } Copy Now a and b are only loaded when the contract really needs their values. Note that offset remained i32 since it is always needed and could spare the minor overhead of the ink_storage::Lazy wrapper.","keywords":""},{"title":"Spread vs. Packed","type":0,"sectionRef":"#","url":"datastructures/spread-packed-layout","content":"","keywords":""},{"title":"Storage Organizationâ€‹","type":1,"pageTitle":"Spread vs. Packed","url":"datastructures/spread-packed-layout#storage-organization","content":"The following schema depicts the storage which is exposed to ink! by the contracts pallet:  Storing or loading complex data structures to and from contract storage can be done in many different ways. You could store all information into a single storage cell or you could try to store all information into as many different cells as possible. Both strategies have pros and cons under different conditions. For example it might be a very good idea to store all the information under the same cell if all the information is very compact. For example when we are dealing with a byte vector that is expected to never be larger than approx a thousand elements it would probably be more efficient if we store all those thousand bytes in the same cell and especially if we often access many of those (or all) in our contract messages. On the other hand spreading information across as many cells as possible might be much more efficient if we are dealing with big data structures, a lot of information that is not compact, or when messages that operate on the data always only need a small fraction of the whole data. An example for this use case is if you have a vector of user accounts where each account stores potentially a lot of information, e.g. a 32-byte hash etc and where our messages only every operate on only a few of those at a time. The ink_storage crate provides the user full control over the strategy or a mix of these two root strategies through some fundamental abstractions that we are briefly presenting to you. "},{"title":"Default: Spreading Modeâ€‹","type":1,"pageTitle":"Spread vs. Packed","url":"datastructures/spread-packed-layout#default-spreading-mode","content":"By default ink! spreads information to as many cells as possible. For example if you have the following #[ink(storage)] struct every field will live in its own single storage cell. Note that for c all 32 bytes will share the same cell! #[ink(storage)] pub struct Spreaded { a: i32, b: ink_storage::Lazy&lt;i32&gt;, c: [u8; 32], } Copy The following schema depicts the storage layout for a vector with three elements, persisted to storage in a spreaded layout.  "},{"title":"Packing Storageâ€‹","type":1,"pageTitle":"Spread vs. Packed","url":"datastructures/spread-packed-layout#packing-storage","content":"We can alter this behaviour by using the ink_storage::Pack abstraction: pub struct Spreaded { a: i32, b: ink_storage::Lazy&lt;i32&gt;, c: [u8; 32], } #[ink(storage)] pub struct Packed { packed: ink_storage::Pack&lt;Spreaded&gt;, } Copy Now all fields of Spreaded will share the same storage cell. This means whenever one of them is stored to or loaded from the contract storage, all of them are stored or loaded. A user has to choose wisely what mode of operation is more suitable for their contract. These abstractions can be combined in various ways, yielding full control to the users. For example, in the following only a and b share a common storage cell while c lives in its own: pub struct Spreaded { a: i32, b: ink_storage::Lazy&lt;i32&gt;, } #[ink(storage)] pub struct Packed { packed: ink_storage::Pack&lt;Spreaded&gt;, c: [u8; 32], } Copy The following schema depicts the spreaded vector from the previous section in a packed layout.  "},{"title":"Spreading Array Cellsâ€‹","type":1,"pageTitle":"Spread vs. Packed","url":"datastructures/spread-packed-layout#spreading-array-cells","content":"If we prefer to store all bytes of c into their own storage cell we can make use of the SmallVec data structure. The SmallVec is a high-level data structure that allows to efficiently organize a fixed number of elements similar to a Rust array. However, unlike a Rust array it acts lazily upon the storage and spreads its elements into different cells. use typenum::U32; pub struct Spreaded { a: i32, b: ink_storage::Lazy&lt;i32&gt;, } #[ink(storage)] pub struct Packed { packed: ink_storage::Pack&lt;Spreaded&gt;, c: SmallVec&lt;u8, U32&gt;, } Copy "},{"title":"Overview","type":0,"sectionRef":"#","url":"examples","content":"Overview In our examples folder you find a number of examples written in ink!. Some of the most interesting ones: delegator â€’ Implements cross-contract calling.trait-erc20 â€’ Defines a trait for Erc20 contracts and implements it.erc721 â€’ An exemplary implementation of Erc721 NFT tokens.dns â€’ A simple DomainNameService smart contract.â€¦and more, just rummage through the folder ðŸ™ƒ. To build a single example navigate to the root of the example and run: cargo contract build Copy As a result you'll get a file target/flipper.wasm file, a metadata.json file and a &lt;contract-name&gt;.contract file in the target/ folder of your contract. The .contract file combines the Wasm and metadata into one file and needs to be used when deploying the contract. For further information, please have a look at the Play with It section or our smart contracts workshop.","keywords":""},{"title":"Compile Your Contract","type":0,"sectionRef":"#","url":"getting-started/building-your-contract","content":"Compile Your Contract Run the following command in your flipper directory to compile your smart contract: cargo +nightly contract build Copy This command will build the following for your contract: a Wasm binary, a metadata file (which contains the contract's ABI) and a .contract file which bundles both. This .contract file can be used to deploy your contract to a chain. If all goes well, you should see a target folder which contains these files: target â””â”€ ink â””â”€ flipper.contract â””â”€ flipper.wasm â””â”€ metadata.json Copy Let's take a look at the structure of the metadata.json: { &quot;metadataVersion&quot;: &quot;0.1.0&quot;, &quot;source&quot;: {...}, &quot;contracts&quot;: {...}, &quot;spec&quot;: { &quot;constructors&quot;: [...], &quot;docs&quot;: [], &quot;events&quot;: [], &quot;messages&quot;: [...], }, &quot;storage&quot;: {...}, &quot;types&quot;: [...] } Copy This file describes all the interfaces that can be used to interact with your contract: types provides the custom data types used throughout the rest of the JSON.storage defines all the storage items managed by your contract and how to ultimately access them.spec stores information about the callable functions like constructors and messages a user can call to interact with the contract. It also has helpful information like the eventsthat are emitted by the contract or any docs. If you look closely at the constructors and messages, you will also notice a selector which contains a 4-byte hash of the function name and is used to route your contract calls to the correct functions. In the next section we will start a Substrate Smart Contracts nodeand configure the Canvas UI to interact with it.","keywords":""},{"title":"Call Your Contract","type":0,"sectionRef":"#","url":"getting-started/calling-your-contract","content":"","keywords":""},{"title":"get() functionâ€‹","type":1,"pageTitle":"Call Your Contract","url":"getting-started/calling-your-contract#get-function","content":"Take a look at our contract's default() function, we set the initial value of the Flipper contractvalue to No when we instantiated the contract. Let's check that this is the case. In the Message to Send section, select the &quot;get(): bool&quot; message and accept the default values for the other options. Press &quot;Call&quot; and confirm that it returns the value false:  NOTE: You might be wondering &quot;Why did we need to specify gas when reading a value from a contract?&quot; If you notice right above the &quot;Call&quot; button is a dropdown select box that allows you to &quot;Send as RPC call&quot; or &quot;Send as transaction&quot;. For a read-only request like this, we can simply use an RPC call which will simulate a transaction, but not actually storing anything on-chain. Thus, you will still need to specify the right amount of gas to cover your &quot;virtual fee&quot;. But don't worry, nothing will be charged when making a call this way. :) "},{"title":"flip() functionâ€‹","type":1,"pageTitle":"Call Your Contract","url":"getting-started/calling-your-contract#flip-function","content":"So let's make the value turn true now! The alternative message to send with the UI is flip(). Again, accept the default values for the other options. You will notice that the flip() message defaults to a transaction call.  If the transaction was successful, we should then be able to go back to the get() function and see our updated storage:  Woohoo! You deployed your first smart contract! "},{"title":"Moving Forwardâ€‹","type":1,"pageTitle":"Call Your Contract","url":"getting-started/calling-your-contract#moving-forward","content":"We will not go over these setup and deployment steps again, but you can use them throughout the tutorial to deploy certain contract on-chain. "},{"title":"Frequently Asked Questions","type":0,"sectionRef":"#","url":"faq","content":"","keywords":""},{"title":"Is it \"ink\" or \"ink!\"? What does the \"!\" stand for?â€‹","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#is-it-ink-or-ink-what-does-the--stand-for","content":"The DSL (domain specific language) is spelled &quot;ink!&quot; with small &quot;i&quot; and an exclamation mark at the end. The main purpose behind this spelling is to have as many dots in its name as possible. "},{"title":"Who is \"Squink\"?â€‹","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#who-is-squink","content":"This little cute purle squid is Squink. Squink is the mascot of ink! and guides new users and adventurers through our presentations workshops and tutorials. It also has a romance with Rust's mascot, Ferris. Generally it is very friendly and open to learning new Rustaceans but be aware to never upset it by taking away dots from the word ink! by spelling it incorrectly! It really is into dots. Stories tell that it demanded the spelling of ink! with as many dots as possible. "},{"title":"What's ink!'s relationship to Substrate/Polkadot?â€‹","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#whats-inks-relationship-to-substratepolkadot","content":"Substrate is a modular framework to build decentralized applications on top of blockchain technology.Polkadot is a layer-0 blockchain built using Substrate that allows to orchestrate an entire fleet of other blockchains to join forces and communicate with each other.Blockchains built with Substrate can include the so-called contracts-pallet module in order to allow instantiating and executing smart contracts. ink! was built to allow users to write smart contracts in Rust targeting blockchains built by Substrate that have the aforementioned contracts-pallet included. While ink! is currently the most advanced smart contract language targeting Substrate blockchains it is not the only possible choice for users. There is also a Solidity to Wasm compiler called Solang that also allows to target Substrate chains and there are other languages in plan and discovery phase for the same purpose. On the Substrate side the same is true for the contracts-pallet. It is just a module that defines the basic set of features required for executing smart contracts on the blockchain that includes it. However, it is not necessarily the only solution to do exactly that. There is also the evm-palletto run smart contracts targeting the EVM as well as the experimental actors-pallet that allows to execute smart contracts written in the actor style programming model. Over time the Substrate community might come up with yet other pallets for smart contracts execution. "},{"title":"How to call other smart contracts on the same blockchain?â€‹","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#how-to-call-other-smart-contracts-on-the-same-blockchain","content":"See the Cross-contract calling section. "},{"title":"How to call other smart contracts on another parachain?â€‹","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#how-to-call-other-smart-contracts-on-another-parachain","content":"This feature has not yet been implemented by the Substrate side. "},{"title":"What is a contract's ABI or Metadata?â€‹","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#what-is-a-contracts-abi-or-metadata","content":"In ink! a smart contract's metadata is retrieved by using the cargo-contract CLI tool and invoking cargo contract build which outputs a .contract file that includes both the compiled.wasm of the ink! smart contract as well as the so-called metadata information of the same smart contract. The metadata is especially important for third party tools such as Polkadot JS Apps or the Canvas UI and provides useful information about the contract's constructors, messages, events, function selectors, documentation and comments of the aforementioned structures as well as how inputs and outputs shall be encoded and decoded respectively etc. "},{"title":"Can a re-entrancy bug occur in ink! contracts?â€‹","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#can-a-re-entrancy-bug-occur-in-ink-contracts","content":"Yes. However, the Substrate team is well aware of the associated problems and already through about possible future additions to eliminate re-entrancy attacks. "},{"title":"How can my smart contract interact with the runtime?â€‹","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#how-can-my-smart-contract-interact-with-the-runtime","content":"See the Chain Extensions section for more information. "},{"title":"How can I use ink! with a Substrate chain with a custom chain config?â€‹","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#how-can-i-use-ink-with-a-substrate-chain-with-a-custom-chain-config","content":"Please see the env_types argumentfor the contract macro. It allows you to specify your environment a la#[ink::contract(env = MyEnvironment)]. "},{"title":"What does the #![cfg_attr(not(feature = \"std\"), no_std)] at the beginning of each contract mean?â€‹","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#what-does-the-cfg_attrnotfeature--std-no_std-at-the-beginning-of-each-contract-mean","content":"The #[cfg(..)] or #[cfg_attr(..)] annotations are how Rust does conditional compilation. ink! smart contracts can be compiled in two different modes. Through #![cfg_attr(not(feature = &quot;std&quot;), no_std)] an ink! smart contract tells the Rust compiler in which mode they are being compiled. This also plays a significant role in how ink! generates the smart contract code. The two modes are as follows: Wasm mode: This is the mode chosen when compiling an ink! smart contract for deployment on a blockchain. The resulting binary is a .wasm file and as such it is not possible to use certain parts of Rust's standard library.Off-chain mode: This is the mode chosen when trying to test an ink! smart contract using the off-chain environment. Off-chain environment testing is very useful to check if certain ink! constructors or messages are well behaving and allow for better debuggability than when trying to debug the same smart contract deployed on a chain. "},{"title":"Overflow Safety?â€‹","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#overflow-safety","content":"Being written in Rust, ink! can provide compile-time overflow/underflow safety. Using a Rust compiler configuration, you can specify whether you want to support overflowing math, or if you want contract execution to panic when overflows occur. No need to continually import &quot;Safe Math&quot; libraries, although Rust also provides integrated checked, wrapped, and saturated math functions. Note: There are some known issues regarding functionality of compiler level overflow checks and the resulting size of the Wasm blob. This feature may change or be iterated on in the future. "},{"title":"What is the difference between memory and storage?â€‹","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#what-is-the-difference-between-memory-and-storage","content":"In ink!, memory refers to computer memory, while storage refers to the on-chain storage used by a contract instance. Memory is temporary and only lasts until the contract execution is done, while storage is persistent and lasts over many contract executions. The contract storage is built on top of the runtime storage, and access is considered to be slow. "},{"title":"How do I print something to the console from the runtime?â€‹","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#how-do-i-print-something-to-the-console-from-the-runtime","content":"You can use those two macros: ink_env::debug_println!ink_env::debug_print! There are three things you have to do for the debug messages to show up on the console: Enable the feature pallet-contracts/unstable-interface in the target runtime. For substrate-contracts-node this is done by default here. Enable the feature ink-debug for the ink_env crate. cargo-contract does this automatically for you (for versions &gt;= 0.13.0), except if you compile a contract in --release mode. Set the log level of your node to runtime::contracts=debug. For example, to have only errors and debug output show up for the substrate-contracts-node: substrate-contracts-node --dev --tmp -lerror,runtime::contracts=debug Copy Important: Debug output is only printed for RPC calls or off-chain tests â€’ not for transactions! In your ink! message or constructor you can write the following: #[ink(constructor)] fn new() -&gt; Self { ink_env::debug_println!(&quot;created new instance at {}&quot;, Self::env().block_number()); Self { } } #[ink(message)] fn print(&amp;self) { let caller = self.env().caller(); let message = ink_prelude::format!(&quot;got a call from {:?}&quot;, caller); ink_env::debug_println!(&amp;message); } Copy "},{"title":"Why is Rust's standard library (stdlib) not available in ink!?â€‹","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#why-is-rusts-standard-library-stdlib-not-available-in-ink","content":"Rust's standard library consists of three different layers: core library which defines everything that has no dependencies outside of Rust itself. Included are types such as Option, Result as well as a whole variety of modules, functions and macro. ink! smart contracts allow authors to use Rust's core crate. alloc library which is depending on a global allocator and mainly defines collections that spill their elements on to the execution's heap memory. Examples for collections are Box, String, Vec, HashMap, LinkedList and modules such as fmt, rc (ref-counted pointers) or borrows. ink! smart contracts allow authors to use Rust's alloc crate. By default ink! authors use definitions from the alloc crate through ink_prelude crate. std library is what people generally call Rust's standard library. The Rust Standard Library is the foundation of portable Rust software, a set of minimal and battle-tested shared abstractions for the broader Rust ecosystem. It requires several operating system capabilities in order to work correctly such as input and output systems for files, networking etc. Since the Wasm (a.k.a. wasm32-unknown-unknown) compilation target does not support Rust's standard library ink! authors cannot use it either for their own purposes. Instead the contracts-pallettries to provide some common functionality that would otherwise be missing for common smart contract operations. "},{"title":"Why is nightly required for ink!?â€‹","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#why-is-nightly-required-for-ink","content":"ink! requires a nightly Rust compiler as of 2021-01 since it relies on a few unstable nightly features around allocation handlers for no_std (no standard library) code. As soon as the Rust team decides to stabilize these features ink! will be available for stable Rust. "},{"title":"How do I hash a value?â€‹","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#how-do-i-hash-a-value","content":"A number of crypto hashes are built into the contracts-pallet and therefore very efficient to use. We currently support a handful of those, you can view the complete list here. If you have the urgent need for another crypto hash you could introduce it throughChain Extensionsor make a proposal to include it into the default set of the contracts-pallet. Using one of the built-in crypto hashes can be done as explained here: self.env().hash_bytes()self.env().hash_encoded() "},{"title":"When to use Lazy<T> over just T for a contract field?â€‹","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#when-to-use-lazyt-over-just-t-for-a-contract-field","content":"The ink_storage::Lazy type caches their entities and acts lazily on the storage. This means that a read or write operation is only performed when it really needs to in order to satisfy other inputs. Data types such as Rust primitives i32 or Rust's very own Vec or data structures can also be used to operate on the contract's storage, however, they will load their contents eagerly which is often not what you want. See this chapter where we go into more details and provide examples. "},{"title":"Why is it not possible to use floating point data types in ink!? How do I implement returning a decimal number?â€‹","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#why-is-it-not-possible-to-use-floating-point-data-types-in-ink-how-do-i-implement-returning-a-decimal-number","content":"Floats are cool for all kinds of reasons, but they also have one important drawback. Floating point arithmetic is non-deterministic which means that different processors compute (slightly) different results for the same operation. Although there is an IEEE spec, non-determinism can come from specific libraries used, or even hardware. In order for the nodes in a blockchain network to reach agreement on the state of the chain, all operations must be completely deterministic. Hence we don't allow floating point data types in ink!. Consequently it's not possible to return a decimal number from an ink! message. What you should do instead is to have your user interface denominate the returned number to decimals. Note, that it's typical for blockchains to have the number of available tokens defined as a non-floating number and determine the denomination in the user interface. For example, 1 Bitcoin is equivalent to the smallest unit of 100,000,000 Satoshi and all Bitcoin implementations internally persist account balances in Satoshi, not as a decimal number of Bitcoin. "},{"title":"Why can't I just use the standard Rust data collections in ink!?â€‹","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#why-cant-i-just-use-the-standard-rust-data-collections-in-ink","content":"You can use them! They are exposed via the ink_prelude crate (e.g. ink_prelude::vec::Vec) and you can return them from ink! messages and also persist them to storage. However, the Rust stdlib collections are not optimized for smart contract usage! So for example, if you use them to persist your data on the chain they will always occupy a single storage cell and thus always be loaded eagerly, in their entirety. This can be very costly! Just think about a Vec or a HashMap where the smart contract might only need access to a few elements, rather than the entire data collection. Our ink_storage data structures on the other hand are optimized for storage and provide a differentiation between lazy and eager access. See this chapter where we go into more details and provide examples. "},{"title":"Why am I getting a ContractTrapped error when interacting with a contract?â€‹","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#why-am-i-getting-a-contracttrapped-error-when-interacting-with-a-contract","content":"When it does not constitute a deliberate assertion, like for example a permission check, it is most likely a bug in your contract or in ink!. A common source of ContractTrapped are Integer overflows, those can cause your contract to trap as well. There is a known bug in the Rust compilerwith respect to safe math operations. As a workaround for this particular bug try to insert overflow-checks = false into your Cargo.toml. This will disable safe math operations altogether, but unfortunately we are currently not aware of a better workaround until the bug in the compiler is fixed. If you don't find the issue you can also ask for help in our publicElement orDiscord channel. "},{"title":"What are the scale::Encode and scale::Decode traits?â€‹","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#what-are-the-scaleencode-and-scaledecode-traits","content":"Substrate-based blockchains use the SCALE codecto encode data. As a consequence the data for every interaction with Substrate needs to be SCALE-encodable â€’ i.e. it needs to implement either scale::Encode,scale::Decode, or both. This affects e.g. data you want to return to a caller, data that you want to take as input, or data you want to store on-chain. A common error you might get when a necessary SCALE trait is not implemented for a data structure could be along the lines of the trait &quot;WrapperTypeEncode&quot; is not implemented for &quot;Foo&quot;. For example, you might encounter this error if you try to store a custom data structure in the contract's storage. Or e.g. when attempting to return a custom error from an ink! message. Note: The error the trait &quot;WrapperTypeEncode&quot; is not implemented for â€¦ is also a common error when a mismatching version of parity-scale-codec is used in the contract opposed to the version used by ink!. The solution typically is to add a fitting implementation of the trait for your data structure: Encode is used for encoding a data structure when it is e.g. returned to a caller or when it is persisted to the contracts storage.Decode is used for the inverse, e.g. when reading from storage or taking an input from a user (or another contract). It's possible to derive those traits and oftentimes the simplest way is to just derive the missing trait for the object for which its implementation is missing: #[derive(scale::Encode, scale::Decode)] struct MyCustomDataStructure { â€¦ } Copy "},{"title":"How do I use String in my contract?â€‹","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#how-do-i-use-string-in-my-contract","content":"In general, you should think twice if you really need String. Smart contracts usually don't use strings; those are typically used for user interactions and should live in your UI and not on the chain. Minimizing storage usage of your contract is a best practice and you should only persist items which you need to derive state transitions in your contract. If you still, for some reason, need to use String, then you should use the String from the ink! prelude. "},{"title":"Creating an ink! Project","type":0,"sectionRef":"#","url":"getting-started/creating-an-ink-project","content":"","keywords":""},{"title":"Contract Source Codeâ€‹","type":1,"pageTitle":"Creating an ink! Project","url":"getting-started/creating-an-ink-project#contract-source-code","content":"The ink CLI automatically generates the source code for the &quot;Flipper&quot; contract, which is about the simplest &quot;smart&quot; contract you can build. You can take a sneak peak as to what will come by looking at the source code here: Flipper Example Source Code The Flipper contract is nothing more than a bool which gets flipped from true to false through the flip() function. "},{"title":"Testing Your Contractâ€‹","type":1,"pageTitle":"Creating an ink! Project","url":"getting-started/creating-an-ink-project#testing-your-contract","content":"You will see at the bottom of the source code there are simple test cases which verify the functionality of the contract. We can quickly test this code is functioning as expected using the off-chain test environment that ink! provides. In your project folder run: cargo +nightly test Copy To which you should see a successful test completion: $ cargo +nightly test running 2 tests test flipper::tests::it_works ... ok test flipper::tests::default_works ... ok test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out Copy Now that we are feeling confident things are working, we can actually compile this contract to Wasm in the next step. "},{"title":"Deploy Your Contract","type":0,"sectionRef":"#","url":"getting-started/deploy-your-contract","content":"","keywords":""},{"title":"Putting Your Code on the Blockchainâ€‹","type":1,"pageTitle":"Deploy Your Contract","url":"getting-started/deploy-your-contract#putting-your-code-on-the-blockchain","content":"Here we will upload the contract code and instantiate one copy of the contract on the blockchain: Click the Upload &amp; Instantiate Contract button.Choose an Instantiation account (e.g. ALICE).Give the contract a descriptive Name (e.g. Flipper Contract).Drag the flipper.contract file that contains the bundled Wasm blob and metadata into the drag &amp; drop area. You will see the UI parse the metadata and showing what functions the contract contains.Click the Constructor Details  Smart contracts exist as an extension of the account system on the blockchain. Thus creating an instance of this contract will create a new AccountId which will store any balance managed by the smart contract and allow us to interact with the contract. Now a screen displays the information that represents our smart contract. We are going to instantiate a copy of the smart contract: Give the contract instance a Contract Name (e.g. The First Flipper).Accept the default options for the contract Instantiation Constructor.Accept the default options Endowment of 1000 Units to pay the storage rent, and Max Gas Allowed of 200000.Click on Instantiate  Note: As mentioned earlier, contract creation involves creation of a new account. As such, you must be sure to give the contract account at least the existential deposit defined by your blockchain. If we consume all of this deposit, the contract will be evicted. We can always refill the contract's balance and keep it on chain. When you click Instantiate, and in the next confirmation screen Sign &amp; Submit, you should see the extrinsic contracts.instantiateWithCode is called, and a flurry of events appear including the creation of a new account (system.NewAccount) and the instantiation of the contract (contracts.Instantiated):  "},{"title":"Run a Substrate Node","type":0,"sectionRef":"#","url":"getting-started/running-substrate","content":"Run a Substrate Node The substrate-contracts-node is a simple Substrate blockchain which is configured to include the contracts module. It's a comfortable option if you want to get a quickstart. After successfully installing canvas, you can start a local development chain by running: substrate-contracts-node --dev --tmp Copy You should start to see blocks being produced by your node in your terminal. You can interact with your node using the Canvas UI: https://paritytech.github.io/canvas-ui Now configure the UI to connect to the locally running node: Click on the dropdown selector at bottom left corner.Choose the &quot;Local Node&quot;.","keywords":""},{"title":"Troubleshooting","type":0,"sectionRef":"#","url":"getting-started/troubleshooting","content":"","keywords":""},{"title":"Unexpected Epoch Changeâ€‹","type":1,"pageTitle":"Troubleshooting","url":"getting-started/troubleshooting#unexpected-epoch-change","content":"There is a known issue with the Substrate block production (BABE) on a running chain. If you stop your node for too long (closing the terminal, putting your computer to sleep, etc.), you will get the following error: ClientImport(&quot;Unexpected epoch change&quot;) Copy To solve this you will need to restart your node with: substrate-contracts-node --dev --tmp. At that point, you will need to re-deploy any contracts and re-do any steps that you may have done before on your node. As long as you keep your node running, you should face no issues. "},{"title":"Old Contracts in Local Storageâ€‹","type":1,"pageTitle":"Troubleshooting","url":"getting-started/troubleshooting#old-contracts-in-local-storage","content":"Canvas UI uses its own local storage to track the contracts that you have deployed. This means that if you deploy a contract using the UI, and then purge your Substrate node, you will be prompted to reset your local storage and please do so. And then re-deploy any contracts and re-do any steps that you may have done before on your node. "},{"title":"\"Send as Transaction\" vs. \"Send as RPC\"â€‹","type":1,"pageTitle":"Troubleshooting","url":"getting-started/troubleshooting#send-as-transaction-vs-send-as-rpc","content":"When interacting with contracts using the Canvas UI, you have the option to submit your call as a transaction or as a RPC:  When you send as a transaction, it should be exactly as you expect. A transaction is submitted to the contract, a fee is deducted from your account, and the state of your blockchain can change. In these situations, no value is returned from your contract call, only a &quot;Success&quot; or &quot;Failed&quot; extrinsic message along with any events it may emit. However, there may be some calls that you want to &quot;test&quot;, rather than actually submit a transaction, or you may want to peek at the value that would be returned if you called the contract function. For these scenarios, you submit an RPC call, which will run all of your contract logic, but not actually submit a transaction or update the chain state. However, you will still need to specify the right amount of gas to cover your &quot;virtual fee&quot;. But don't worry, nothing will be charged when making a call this way. :) "},{"title":"Other Issuesâ€‹","type":1,"pageTitle":"Troubleshooting","url":"getting-started/troubleshooting#other-issues","content":"If you run into any other issues during this tutorial, please report an issue! "},{"title":"How it Works â€’ Substrate","type":0,"sectionRef":"#","url":"how-it-works","content":"How it Works â€’ Substrate Substrate's Framework for Runtime Aggregation of Modularised Entities (FRAME) contains a module which implements an API for typical functions smart contracts need (storage, querying information about accounts, â€¦). This module is called the contracts pallet, you can find its repository here. The contracts pallet requires smart contracts to be uploaded to the blockchain as a Wasm blob. ink! is a smart contract language which targets the API exposed by contracts. Hence ink! contracts are compiled to Wasm. When executing cargo contract build an additional file metadata.json is created. It contains information about e.g. what methods the contract provides for others to call.","keywords":""},{"title":"Setup","type":0,"sectionRef":"#","url":"getting-started/setup","content":"","keywords":""},{"title":"Rust & Cargoâ€‹","type":1,"pageTitle":"Setup","url":"getting-started/setup#rust--cargo","content":"A pre-requisite for compiling smart contracts is to have Rust and Cargo installed. Here's an installation guide. "},{"title":"ink! CLIâ€‹","type":1,"pageTitle":"Setup","url":"getting-started/setup#ink-cli","content":"The first tool we will be installing is cargo-contract, a CLI tool for helping setting up and managing WebAssembly smart contracts written with ink!. As a pre-requisite for the tool you need to install the binaryen package, which is used to optimize the WebAssembly bytecode of the contract. Many package managers have it available nowadays â€’ e.g. there is a package for Debian/Ubuntu,Homebrew and Arch Linux. If there's only an old version in your distributions package manager you can also download a binary release directly. After you've installed the package execute: cargo install cargo-contract --vers ^0.15 --force --locked Copy Use the --force to ensure you are updated to the most recent cargo-contract version. You can then use cargo contract --help to start exploring the commands made available to you. "},{"title":"Substrate Framework Pre-requisitesâ€‹","type":1,"pageTitle":"Setup","url":"getting-started/setup#substrate-framework-pre-requisites","content":"With ink! you can write smart contracts for blockchains built on Substrate. Follow theofficial installation steps from the Substrate Developer Hub Knowledge Base to set up all Substrate pre-requisites. Once you have done this you will also need to run: rustup component add rust-src --toolchain nightly rustup target add wasm32-unknown-unknown --toolchain nightly Copy "},{"title":"Installing The Substrate Smart Contracts Nodeâ€‹","type":1,"pageTitle":"Setup","url":"getting-started/setup#installing-the-substrate-smart-contracts-node","content":"The substrate-contracts-node is a simple Substrate blockchain which is configured to include the Substrate module for smart contract functionality â€’ the contracts pallet (see How it Works for more). It's a comfortable option if you want to get a quickstart. cargo install contracts-node --git https://github.com/paritytech/substrate-contracts-node.git --tag v0.1.0 --force --locked Copy "},{"title":"ink! vs. Solidity","type":0,"sectionRef":"#","url":"ink-vs-solidity","content":"ink! vs. Solidity Here is a brief comparison of features between ink! and Solidity: ink!\tSolidityVirtual Machine\tAny Wasm VM\tEVM Encoding\tWasm\tEVM Byte Code Language\tRust\tStandalone Overflow Protection\tEnabled by default\tNone Constructor Functions\tMultiple\tSingle Tooling\tAnything that supports Rust\tCustom Versioning\tSemantic\tSemantic Has Metadata?\tYes\tYes Multi-File Project\tPlanned\tYes Storage Entries\tVariable\t256 bits Supported Types\tDocs\tDocs Has Interfaces?\tYes (Rust Traits)\tYes","keywords":""},{"title":"Overview","type":0,"sectionRef":"#","url":"macros-attributes","content":"","keywords":""},{"title":"Merging Attributesâ€‹","type":1,"pageTitle":"Overview","url":"macros-attributes#merging-attributes","content":"It is possible to merge attributes that share a common flagged entity. The example below demonstrates this for a payable message with a custom selector. #[ink(message)] #[ink(payable)] #[ink(selector = &quot;0xCAFEBABE&quot;)] pub fn transfer(&amp;mut self, from: AccountId, to: AccountId, value: Balance) -&gt; Result&lt;(), Error&gt; { // actual implementation } Copy We can also write the above ink! message definition in the following way: #[ink(message, payable, selector = &quot;0xCAFEBABE&quot;)] pub fn transfer(&amp;mut self, from: AccountId, to: AccountId, value: Balance) -&gt; Result&lt;(), Error&gt; { // actual implementation } Copy "},{"title":"#[ink(anonymous)]","type":0,"sectionRef":"#","url":"macros-attributes/anonymous","content":"#[ink(anonymous)] Applicable to ink! events. Tells the ink! codegen to treat the ink! event as anonymous which omits the event signature as topic upon emitting. Very similar to anonymous events in Solidity. Anonymous events have similar semantics as in Solidity in that their event signature won't be included in their event topics serialization to reduce event emitting overhead. This is especially useful for user defined events. The signature of the event is by default one of the topics of the event, except if you annotate the event with #[ink(anonymous)]. The attribute implies that it is not possible to filter for specific anonymous events by name.","keywords":""},{"title":"#[ink(constructor)]","type":0,"sectionRef":"#","url":"macros-attributes/constructor","content":"","keywords":""},{"title":"Exampleâ€‹","type":1,"pageTitle":"#[ink(constructor)]","url":"macros-attributes/constructor#example","content":"use ink_lang as ink; #[ink::contract] mod erc20 { #[ink(storage)] pub struct Erc20 { ... } impl Erc20 { #[ink(constructor)] pub fn new(initial_supply: Balance) -&gt; Self { .. } #[ink(constructor)] pub fn total_supply(&amp;self) -&gt; Balance { .. } // etc. } } Copy "},{"title":"#[ink::contract]","type":0,"sectionRef":"#","url":"macros-attributes/contract","content":"","keywords":""},{"title":"Header Argumentsâ€‹","type":1,"pageTitle":"#[ink::contract]","url":"macros-attributes/contract#header-arguments","content":"The #[ink::contract] macro can be provided with some additional comma-separated header arguments: "},{"title":"dynamic_storage_allocator: boolâ€‹","type":1,"pageTitle":"#[ink::contract]","url":"macros-attributes/contract#dynamic_storage_allocator-bool","content":"Tells the ink! code generator to allow usage of ink!'s built-in dynamic storage allocator. true: Use the dynamic storage allocator provided by ink!.false: Do NOT use the dynamic storage allocator provided by ink!. This feature is generally only needed for smart contracts that try to model their data in a way that contains storage entites within other storage entities. Contract writers should try to write smart contracts that do not depend on the dynamic storage allocator since enabling it comes at a cost of increased Wasm file size. Although it will enable interesting use cases. Use it with care! An example for this is the following type that could potentially be used within a contract's storage struct definition: // A storage vector of storage vectors. use ink_storage as storage; type VectorOfVectors = storage::Vec&lt;storage::Vec&lt;i32&gt;&gt;; Copy Usage Example: use ink_lang as ink; #[ink::contract(dynamic_storage_allocator = true)] mod my_contract { #[ink(storage)] pub struct MyStorage; impl MyStorage { #[ink(constructor)] pub fn construct() -&gt; Self { MyStorage {} } #[ink(message)] pub fn message(&amp;self) {} } // ... } Copy Default value: false "},{"title":"compile_as_dependency: boolâ€‹","type":1,"pageTitle":"#[ink::contract]","url":"macros-attributes/contract#compile_as_dependency-bool","content":"Tells the ink! code generator to always or nevercompile the smart contract as if it was used as a dependency of another ink! smart contract. Normally this flag is only really useful for ink! developers who want to inspect code generation of ink! smart contracts. The author is not aware of any particular practical use case for users that makes use of this flag but contract writers are encouraged to disprove this. Note that it is recommended to make use of the built-in crate featureink-as-dependency to flag smart contract dependencies listed in a contract'sCargo.toml as actual dependencies to ink!. Usage Example: use ink_lang as ink; #[ink::contract(compile_as_dependency = true)] mod my_contract { #[ink(storage)] pub struct MyStorage; impl MyStorage { #[ink(constructor)] pub fn construct() -&gt; Self { MyStorage {} } #[ink(message)] pub fn message(&amp;self) {} } // ... } Copy Default value: Depends on the crate feature propagation of Cargo.toml. "},{"title":"env: impl Environmentâ€‹","type":1,"pageTitle":"#[ink::contract]","url":"macros-attributes/contract#env-impl-environment","content":"Tells the ink! code generator which environment to use for the ink! smart contract. The environment must implement the Environment (defined in ink_env) trait and provides all the necessary fundamental type definitions for Balance, AccountId etc. When using a custom Environment implementation for a smart contract all types that it exposes to the ink! smart contract and the mirrored types used in the runtime must be aligned with respect to SCALE encoding and semantics. Usage Example: Given a custom Environment implementation: pub struct MyEnvironment; impl ink_env::Environment for MyEnvironment { const MAX_EVENT_TOPICS: usize = 3; type AccountId = u64; type Balance = u128; type Hash = [u8; 32]; type Timestamp = u64; type BlockNumber = u32; type ChainExtension = ::ink_env::NoChainExtension; } Copy A user might implement their ink! smart contract using the above custom Environmentimplementation as demonstrated below: use ink_lang as ink; #[ink::contract(env = MyEnvironment)] mod my_contract { pub struct MyEnvironment; impl ink_env::Environment for MyEnvironment { const MAX_EVENT_TOPICS: usize = 3; type AccountId = u64; type Balance = u128; type Hash = [u8; 32]; type Timestamp = u64; type BlockNumber = u32; type ChainExtension = ::ink_env::NoChainExtension; } #[ink(storage)] pub struct MyStorage; impl MyStorage { #[ink(constructor)] pub fn construct() -&gt; Self { MyStorage {} } #[ink(message)] pub fn message(&amp;self) {} } // ... } Copy Default value: DefaultEnvironment defined in ink_env crate. "},{"title":"Anaylsisâ€‹","type":1,"pageTitle":"#[ink::contract]","url":"macros-attributes/contract#anaylsis","content":"The #[ink::contract] macro fully analyses its input smart contract against invalid arguments and structure. Some example rules include but are not limited to: There must be exactly one #[ink(storage)] struct. This struct defines the layout of the storage that the ink! smart contract operates on. The user is able to use a variety of built-in facilities, combine them in various ways or even provide their own implementations of storage data structures. For more information visit the ink_storage crate documentation. Example: use ink_lang as ink; #[ink::contract] mod flipper { #[ink(storage)] pub struct Flipper { value: bool, } impl Flipper { #[ink(constructor)] pub fn construct() -&gt; Self { Flipper { value: false } } #[ink(message)] pub fn message(&amp;self) {} } } Copy There must be at least one #[ink(constructor)] defined method. Methods flagged with #[ink(constructor)] are special in that they are dispatchable upon contract instantiation. A contract may define multiple such constructors which allow users of the contract to instantiate a contract in multiple different ways. Example: Given the Flipper contract definition above we add an #[ink(constructor)]as follows: use ink_lang as ink; #[ink::contract] mod flipper { #[ink(storage)] pub struct Flipper { value: bool, } impl Flipper { #[ink(constructor)] pub fn new(initial_value: bool) -&gt; Self { Flipper { value: false } } #[ink(message)] pub fn message(&amp;self) {} } } Copy There must be at least one #[ink(message)] defined method. Methods flagged with #[ink(message)] are special in that they are dispatchable upon contract invocation. The set of ink! messages defined for an ink! smart contract define its API surface with which users are allowed to interact. An ink! smart contract can have multiple such ink! messages defined. Note: An ink! message with a &amp;self receiver may only read state whereas an ink! message with a &amp;mut self receiver may mutate the contract's storage. Example: Given the Flipper contract definition above we add some #[ink(message)] definitions as follows: use ink_lang as ink; #[ink::contract] mod flipper { #[ink(storage)] pub struct Flipper { value: bool, } impl Flipper { #[ink(constructor)] pub fn new(initial_value: bool) -&gt; Self { Flipper { value: false } } /// Flips the current value. #[ink(message)] pub fn flip(&amp;mut self) { self.value = !self.value; } /// Returns the current value. #[ink(message)] pub fn get(&amp;self) -&gt; bool { self.value } } } Copy Payable Messages: An ink! message by default will reject calls that additional fund the smart contract. Authors of ink! smart contracts can make an ink! message payable by adding the payableflag to it. An example below: Note that ink! constructors are always implicitly payable and thus cannot be flagged as such. use ink_lang as ink; #[ink::contract] mod flipper { #[ink(storage)] pub struct Flipper { value: bool, } impl Flipper { #[ink(constructor)] pub fn new(initial_value: bool) -&gt; Self { Flipper { value: false } } /// Flips the current value. #[ink(message)] #[ink(payable)] // You can either specify payable out-of-line. pub fn flip(&amp;mut self) { self.value = !self.value; } /// Returns the current value. #[ink(message, payable)] // ... or specify payable inline. pub fn get(&amp;self) -&gt; bool { self.value } } } Copy Controlling the messages selector: Every ink! message and ink! constructor has a unique selector with which the message or constructor can be uniquely identified within the ink! smart contract. These selectors are mainly used to drive the contract's dispatch upon calling it. An ink! smart contract author can control the selector of an ink! message or ink! constructor using the selector flag. An example is shown below: use ink_lang as ink; #[ink::contract] mod flipper { #[ink(storage)] pub struct Flipper { value: bool, } impl Flipper { #[ink(constructor)] #[ink(selector = &quot;0xDEADBEEF&quot;)] // Works on constructors as well. pub fn new(initial_value: bool) -&gt; Self { Flipper { value: false } } /// Flips the current value. #[ink(message)] #[ink(selector = &quot;0xCAFEBABE&quot;)] // You can either specify selector out-of-line. pub fn flip(&amp;mut self) { self.value = !self.value; } /// Returns the current value. #[ink(message, selector = &quot;0xFEEDBEEF&quot;)] // ... or specify selector inline. pub fn get(&amp;self) -&gt; bool { self.value } } } Copy "},{"title":"Interacting with the Contract Executorâ€‹","type":1,"pageTitle":"#[ink::contract]","url":"macros-attributes/contract#interacting-with-the-contract-executor","content":"The ink_env crate provides facitilies to interact with the contract executor that connects ink! smart contracts with the outer world. For example it is possible to query the current call's caller via: use ink_env; ink_env::test::run_test::&lt;ink_env::DefaultEnvironment, _&gt;(|_| { let caller = ink_env::caller::&lt;ink_env::DefaultEnvironment&gt;(); let _caller = caller; Ok(()) }).unwrap(); Copy However, ink! provides a much simpler way to interact with the contract executor via its environment accessor. An example below: use ink_lang as ink; #[ink::contract] mod greeter { #[ink(storage)] pub struct Greeter; impl Greeter { #[ink(constructor)] pub fn new() -&gt; Self { let caller = Self::env().caller(); let message = format!(&quot;thanks for instantiation {:?}&quot;, caller); ink_env::debug_println(&amp;message); Greeter {} } #[ink(message, payable)] pub fn fund(&amp;mut self) { let caller = self.env().caller(); let value = self.env().transferred_balance(); let message = format!(&quot;thanks for the funding of {:?} from {:?}&quot;, value, caller); ink_env::debug_println(&amp;message); } } } Copy "},{"title":"Eventsâ€‹","type":1,"pageTitle":"#[ink::contract]","url":"macros-attributes/contract#events","content":"An ink! smart contract may define events that it can emit during contract execution. Emitting events can be used by third party tools to query information about a contract's execution and state. The following example ink! contract shows how an event Transferred is defined and emitted in the #[ink(constructor)].  use ink_lang as ink; #[ink::contract] mod erc20 { /// Defines an event that is emitted every time value is transferred. #[ink(event)] pub struct Transferred { from: Option&lt;AccountId&gt;, to: Option&lt;AccountId&gt;, value: Balance, } #[ink(storage)] pub struct Erc20 { total_supply: Balance, // more fields ... } impl Erc20 { #[ink(constructor)] pub fn new(initial_supply: Balance) -&gt; Self { let caller = Self::env().caller(); Self::env().emit_event(Transferred { from: None, to: Some(caller), value: initial_supply, }); Self { total_supply: initial_supply } } #[ink(message)] pub fn total_supply(&amp;self) -&gt; Balance { self.total_supply } } } Copy "},{"title":"Example: Flipperâ€‹","type":1,"pageTitle":"#[ink::contract]","url":"macros-attributes/contract#example-flipper","content":"The below code shows the complete implementation of the so-called Flipper ink! smart contract. For us it acts as the &quot;Hello, World!&quot; of the ink! smart contracts because it is minimal while still providing some more or less useful functionality. It controls a single bool value that can be either false or trueand allows the user to flip this value using the Flipper::flip message or retrieve the current value using Flipper::get. use ink_lang as ink; #[ink::contract] pub mod flipper { #[ink(storage)] pub struct Flipper { value: bool, } impl Flipper { /// Creates a new flipper smart contract initialized with the given value. #[ink(constructor)] pub fn new(init_value: bool) -&gt; Self { Self { value: init_value } } /// Flips the current value of the Flipper's bool. #[ink(message)] pub fn flip(&amp;mut self) { self.value = !self.value; } /// Returns the current value of the Flipper's bool. #[ink(message)] pub fn get(&amp;self) -&gt; bool { self.value } } } Copy "},{"title":"#[ink::chain_extension]","type":0,"sectionRef":"#","url":"macros-attributes/chain-extension","content":"","keywords":""},{"title":"Structureâ€‹","type":1,"pageTitle":"#[ink::chain_extension]","url":"macros-attributes/chain-extension#structure","content":"The interface consists of an error code that indicates lightweight errors as well as the definition of some chain extension methods. The overall structure follows that of a simple Rust trait definition. The error code is defined as an associated type definition of the trait definition. The methods are defined as associated trait methods without implementation. Chain extension methods must not have a self receiver such as &amp;self or &amp;mut selfand must have inputs and output that implement SCALE codec. Their return value follows specific rules that can be altered using the handle_status and returns_result attributes which are described in more detail below. "},{"title":"Usageâ€‹","type":1,"pageTitle":"#[ink::chain_extension]","url":"macros-attributes/chain-extension#usage","content":"Usually the chain extension definition using this proc. macro is provided by the author of the chain extension in a separate crate. ink! smart contracts using this chain extension simply depend on this crate and use its associated environment definition in order to make use of the methods provided by the chain extension. "},{"title":"Attributesâ€‹","type":1,"pageTitle":"#[ink::chain_extension]","url":"macros-attributes/chain-extension#attributes","content":"There are three different attributes with which the chain extension methods can be flagged: Attribute\tRequired\tDefault Value\tDescriptionink(extension = N: u32)\tYes\t-\tDetermines the unique function ID of the chain extension method. ink(handle_status = flag: bool)\tOptional\ttrue\tAssumes that the returned status code of the chain extension method always indicates success and therefore always loads and decodes the output buffer of the call. ink(returns_result = flag: bool)\tOptional\ttrue\tBy default chain extension methods are assumed to return a Result&lt;T, E&gt; in the output buffer. Using returns_result = false this check is disabled and the chain extension method may return any other type. As with all ink! attributes multiple of them can either appear in a contiguous list: type Access = i32; use ink_lang as ink; #[ink::chain_extension] pub trait MyChainExtension { type ErrorCode = i32; #[ink(extension = 5, handle_status = false, returns_result = false)] fn key_access_for_account(key: &amp;[u8], account: &amp;[u8]) -&gt; Access; } Copy â€¦or as multiple standalone ink! attributes applied to the same item: type Access = i32; use ink_lang as ink; #[ink::chain_extension] pub trait MyChainExtension { type ErrorCode = i32; #[ink(extension = 5)] #[ink(handle_status = false)] #[ink(returns_result = false)] fn key_access_for_account(key: &amp;[u8], account: &amp;[u8]) -&gt; Access; } Copy "},{"title":"Details: handle_statusâ€‹","type":1,"pageTitle":"#[ink::chain_extension]","url":"macros-attributes/chain-extension#details-handle_status","content":"Default value: true By default all chain extension methods return a Result&lt;T, E&gt; where E: From&lt;Self::ErrorCode&gt;. The Self::ErrorCode represents the error code of the chain extension. This means that a smart contract calling such a chain extension method first queries the returned status code of the chain extension method and only loads and decodes the output if the returned status code indicates a successful call. This design was chosen as it is more efficient when no output besides the error code is required for a chain extension call. When designing a chain extension try to utilize the error code to return errors and only use the output buffer for information that does not fit in a single u32 value. A chain extension method that is flagged with handle_status = false assumes that the returned error code will always indicate success. Therefore it will always load and decode the output buffer and loses the E: From&lt;Self::ErrorCode constraint for the call. "},{"title":"Details: returns_resultâ€‹","type":1,"pageTitle":"#[ink::chain_extension]","url":"macros-attributes/chain-extension#details-returns_result","content":"Default value: true By default chain extension methods are assumed to return a value of type Result&lt;T, E&gt; through the output buffer. Using returns_result = false this check is disabled and the chain extension method may return any other type. Note that if a chain extension method is attributed with returns_result = falseand with handle_status = true it will still return a value of type Result&lt;T, Self::ErrorCode&gt;. "},{"title":"Usage: handle_status + returns_resultâ€‹","type":1,"pageTitle":"#[ink::chain_extension]","url":"macros-attributes/chain-extension#usage-handle_status--returns_result","content":"Use both handle_status = false and returns_result = false for the same chain extension method if a call to it may never fail and never returns a Result type. "},{"title":"Combinationsâ€‹","type":1,"pageTitle":"#[ink::chain_extension]","url":"macros-attributes/chain-extension#combinations","content":"Due to the possibility to flag a chain extension method with handle_status and returns_resultthere are 4 different cases with slightly varying semantics: handle_status\treturns_result\tEffectstrue\ttrue\tThe chain extension method is required to return a value of type Result&lt;T, E&gt; where E: From&lt;Self::ErrorCode&gt;. A call will always check if the returned status code indicates success and only then will load and decode the value in the output buffer. true\tfalse\tThe chain extension method may return any non-Result type. A call will always check if the returned status code indicates success and only then will load and decode the value in the output buffer. The actual return type of the chain extension method is still Result&lt;T, Self::ErrorCode&gt; when the chain extension method was defined to return a value of type T. false\ttrue\tThe chain extension method is required to return a value of type Result&lt;T, E&gt;. A call will always assume that the returned status code indicates success and therefore always load and decode the output buffer directly. false\tfalse\tThe chain extension method may return any non-Result type. A call will always assume that the returned status code indicates success and therefore always load and decode the output buffer directly. "},{"title":"Error Codeâ€‹","type":1,"pageTitle":"#[ink::chain_extension]","url":"macros-attributes/chain-extension#error-code","content":"Every chain extension defines exactly one ErrorCode using the following syntax: use ink_lang as ink; #[ink::chain_extension] pub trait MyChainExtension { type ErrorCode = MyErrorCode; // more definitions ... } Copy The defined ErrorCode must implement FromStatusCode which should be implemented as a more or less trivial conversion from the u32 status code to a Result&lt;(), Self::ErrorCode&gt;. The Ok(()) value indicates that the call to the chain extension method was successful. By convention an error code of 0 represents success. However, chain extension authors may use whatever suits their needs. "},{"title":"Example: Definitionâ€‹","type":1,"pageTitle":"#[ink::chain_extension]","url":"macros-attributes/chain-extension#example-definition","content":"In the below example a chain extension is defined that allows its users to read and write from and to the runtime storage using access privileges: use ink_lang as ink; /// Custom chain extension to read to and write from the runtime. #[ink::chain_extension] pub trait RuntimeReadWrite { type ErrorCode = ReadWriteErrorCode; /// Reads from runtime storage. /// /// # Note /// /// Actually returns a value of type `Result&lt;Vec&lt;u8&gt;, Self::ErrorCode&gt;`. /// #[ink(extension = 1, returns_result = false)] /// fn read(key: &amp;[u8]) -&gt; Vec&lt;u8&gt;; /// /// Reads from runtime storage. /// /// Returns the number of bytes read and up to 32 bytes of the /// read value. Unused bytes in the output are set to 0. /// /// # Errors /// /// If the runtime storage cell stores a value that requires more than /// 32 bytes. /// /// # Note /// /// This requires `ReadWriteError` to implement `From&lt;ReadWriteErrorCode&gt;` /// and may potentially return any `Self::ErrorCode` through its return value. #[ink(extension = 2)] fn read_small(key: &amp;[u8]) -&gt; Result&lt;(u32, [u8; 32]), ReadWriteError&gt;; /// Writes into runtime storage. /// /// # Note /// /// Actually returns a value of type `Result&lt;(), Self::ErrorCode&gt;`. #[ink(extension = 3, returns_result = false)] fn write(key: &amp;[u8], value: &amp;[u8]); /// Returns the access allowed for the key for the caller. /// /// # Note /// /// Assumes to never fail the call and therefore always returns `Option&lt;Access&gt;`. #[ink(extension = 4, returns_result = false, handle_status = false)] fn access(key: &amp;[u8]) -&gt; Option&lt;Access&gt;; /// Unlocks previously aquired permission to access key. /// /// # Errors /// /// If the permission was not granted. /// /// # Note /// /// Assumes the call to never fail and therefore does _NOT_ require `UnlockAccessError` /// to implement `From&lt;Self::ErrorCode&gt;` as in the `read_small` method above. #[ink(extension = 5, handle_status = false)] fn unlock_access(key: &amp;[u8], access: Access) -&gt; Result&lt;(), UnlockAccessError&gt;; } #[derive(scale::Encode, scale::Decode, scale_info::TypeInfo)] pub enum ReadWriteErrorCode { InvalidKey, CannotWriteToKey, CannotReadFromKey, } #[derive(scale::Encode, scale::Decode, scale_info::TypeInfo)] pub enum ReadWriteError { ErrorCode(ReadWriteErrorCode), BufferTooSmall { required_bytes: u32 }, } impl From&lt;ReadWriteErrorCode&gt; for ReadWriteError { fn from(error_code: ReadWriteErrorCode) -&gt; Self { Self::ErrorCode(error_code) } } impl From&lt;scale::Error&gt; for ReadWriteError { fn from(_: scale::Error) -&gt; Self { panic!(&quot;encountered unexpected invalid SCALE encoding&quot;) } } #[derive(scale::Encode, scale::Decode, scale_info::TypeInfo)] pub struct UnlockAccessError { reason: String, } impl From&lt;scale::Error&gt; for UnlockAccessError { fn from(_: scale::Error) -&gt; Self { panic!(&quot;encountered unexpected invalid SCALE encoding&quot;) } } #[derive(scale::Encode, scale::Decode, scale_info::TypeInfo)] pub enum Access { ReadWrite, ReadOnly, WriteOnly, } impl ink_env::chain_extension::FromStatusCode for ReadWriteErrorCode { fn from_status_code(status_code: u32) -&gt; Result&lt;(), Self&gt; { match status_code { 0 =&gt; Ok(()), 1 =&gt; Err(Self::InvalidKey), 2 =&gt; Err(Self::CannotWriteToKey), 3 =&gt; Err(Self::CannotReadFromKey), _ =&gt; panic!(&quot;encountered unknown status code&quot;), } } } Copy All the error types and other utility types used in the chain extension definition above are often required to implement various traits such as SCALE's Encode and Decodeas well as scale-info's TypeInfo trait. A full example of the above chain extension definition can be seenhere. "},{"title":"Example: Environmentâ€‹","type":1,"pageTitle":"#[ink::chain_extension]","url":"macros-attributes/chain-extension#example-environment","content":"In order to allow ink! smart contracts to use the above defined chain extension it needs to be integrated into an Environment definition as shown below: type RuntimeReadWrite = i32; use ink_env::{Environment, DefaultEnvironment}; pub enum CustomEnvironment {} impl Environment for CustomEnvironment { const MAX_EVENT_TOPICS: usize = &lt;DefaultEnvironment as Environment&gt;::MAX_EVENT_TOPICS; type AccountId = &lt;DefaultEnvironment as Environment&gt;::AccountId; type Balance = &lt;DefaultEnvironment as Environment&gt;::Balance; type Hash = &lt;DefaultEnvironment as Environment&gt;::Hash; type BlockNumber = &lt;DefaultEnvironment as Environment&gt;::BlockNumber; type Timestamp = &lt;DefaultEnvironment as Environment&gt;::Timestamp; type ChainExtension = RuntimeReadWrite; } Copy Above we defined the CustomEnvironment which defaults to ink!'s DefaultEnvironmentfor all constants and types but the ChainExtension type which is assigned to our newly defined chain extension. "},{"title":"Example: Usageâ€‹","type":1,"pageTitle":"#[ink::chain_extension]","url":"macros-attributes/chain-extension#example-usage","content":"An ink! smart contract can use the above defined chain extension through the Environmentdefinition defined in the last example section using the env macro parameter as shown below. Note that chain extension methods are accessible through Self::extension() orself.extension(). For example as in Self::extension().read(..) or self.extension().read(..). use ink_lang as ink; #[ink::contract(env = CustomEnvironment)] mod read_writer { use ink_lang as ink; #[ink(storage)] pub struct ReadWriter {} impl ReadWriter { #[ink(constructor)] pub fn new() -&gt; Self { Self {} } #[ink(message)] pub fn read(&amp;self, key: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, ReadWriteErrorCode&gt; { self.env() .extension() .read(&amp;key) } #[ink(message)] pub fn read_small(&amp;self, key: Vec&lt;u8&gt;) -&gt; Result&lt;(u32, [u8; 32]), ReadWriteError&gt; { self.env() .extension() .read_small(&amp;key) } #[ink(message)] pub fn write( &amp;self, key: Vec&lt;u8&gt;, value: Vec&lt;u8&gt;, ) -&gt; Result&lt;(), ReadWriteErrorCode&gt; { self.env() .extension() .write(&amp;key, &amp;value) } #[ink(message)] pub fn access(&amp;self, key: Vec&lt;u8&gt;) -&gt; Option&lt;Access&gt; { self.env() .extension() .access(&amp;key) } #[ink(message)] pub fn unlock_access(&amp;self, key: Vec&lt;u8&gt;, access: Access) -&gt; Result&lt;(), UnlockAccessError&gt; { self.env() .extension() .unlock_access(&amp;key, access) } } /// Custom chain extension to read to and write from the runtime. #[ink::chain_extension] pub trait RuntimeReadWrite { type ErrorCode = ReadWriteErrorCode; #[ink(extension = 1, returns_result = false)] fn read(key: &amp;[u8]) -&gt; Vec&lt;u8&gt;; #[ink(extension = 2)] fn read_small(key: &amp;[u8]) -&gt; Result&lt;(u32, [u8; 32]), ReadWriteError&gt;; #[ink(extension = 3, returns_result = false)] fn write(key: &amp;[u8], value: &amp;[u8]); #[ink(extension = 4, returns_result = false, handle_status = false)] fn access(key: &amp;[u8]) -&gt; Option&lt;Access&gt;; #[ink(extension = 5, handle_status = false)] fn unlock_access(key: &amp;[u8], access: Access) -&gt; Result&lt;(), UnlockAccessError&gt;; } #[derive(scale::Encode, scale::Decode, scale_info::TypeInfo)] pub enum ReadWriteErrorCode { InvalidKey, CannotWriteToKey, CannotReadFromKey, } #[derive(scale::Encode, scale::Decode, scale_info::TypeInfo)] pub enum ReadWriteError { ErrorCode(ReadWriteErrorCode), BufferTooSmall { required_bytes: u32 }, } impl From&lt;ReadWriteErrorCode&gt; for ReadWriteError { fn from(error_code: ReadWriteErrorCode) -&gt; Self { Self::ErrorCode(error_code) } } impl From&lt;scale::Error&gt; for ReadWriteError { fn from(_: scale::Error) -&gt; Self { panic!(&quot;encountered unexpected invalid SCALE encoding&quot;) } } #[derive(scale::Encode, scale::Decode, scale_info::TypeInfo)] pub struct UnlockAccessError { reason: String, } impl From&lt;scale::Error&gt; for UnlockAccessError { fn from(_: scale::Error) -&gt; Self { panic!(&quot;encountered unexpected invalid SCALE encoding&quot;) } } #[derive(scale::Encode, scale::Decode, scale_info::TypeInfo)] pub enum Access { ReadWrite, ReadOnly, WriteOnly, } impl ink_env::chain_extension::FromStatusCode for ReadWriteErrorCode { fn from_status_code(status_code: u32) -&gt; Result&lt;(), Self&gt; { match status_code { 0 =&gt; Ok(()), 1 =&gt; Err(Self::InvalidKey), 2 =&gt; Err(Self::CannotWriteToKey), 3 =&gt; Err(Self::CannotReadFromKey), _ =&gt; panic!(&quot;encountered unknown status code&quot;), } } } pub enum CustomEnvironment {} impl ink_env::Environment for CustomEnvironment { const MAX_EVENT_TOPICS: usize = &lt;ink_env::DefaultEnvironment as ink_env::Environment&gt;::MAX_EVENT_TOPICS; type AccountId = &lt;ink_env::DefaultEnvironment as ink_env::Environment&gt;::AccountId; type Balance = &lt;ink_env::DefaultEnvironment as ink_env::Environment&gt;::Balance; type Hash = &lt;ink_env::DefaultEnvironment as ink_env::Environment&gt;::Hash; type BlockNumber = &lt;ink_env::DefaultEnvironment as ink_env::Environment&gt;::BlockNumber; type Timestamp = &lt;ink_env::DefaultEnvironment as ink_env::Environment&gt;::Timestamp; type ChainExtension = RuntimeReadWrite; } } Copy "},{"title":"Technical Limitationsâ€‹","type":1,"pageTitle":"#[ink::chain_extension]","url":"macros-attributes/chain-extension#technical-limitations","content":"Due to technical limitations it is not possible to refer to the ErrorCode associated type using Self::ErrorCode anywhere within the chain extension and its defined methods. Instead chain extension authors should directly use the error code type when required. This limitation might be lifted in future versions of ink!.It is not possible to declare other chain extension traits as super traits or super chain extensions of another. "},{"title":"#[ink(event)]","type":0,"sectionRef":"#","url":"macros-attributes/event","content":"#[ink(event)] Applicable on struct definitions. Defines an ink! event. A contract can define multiple such ink! events. See our section on Events for a detailed description and examples.","keywords":""},{"title":"#[ink(message)]","type":0,"sectionRef":"#","url":"macros-attributes/message","content":"","keywords":""},{"title":"Messages Return Valueâ€‹","type":1,"pageTitle":"#[ink(message)]","url":"macros-attributes/message#messages-return-value","content":"The return value of a message needs to implement scale::Encode. It is notable that the collections under ink_storage â€’ such as e.g. Vec or HashMap â€’ don't implement scale::Encode. This means you can't just return a Vec from an ink! message. This restriction is intentional â€’ returning a complete data structure with a potentially unbounded content is an anti-pattern for smart contracts. Just think about the unpredicatble gas costs. If you really really need to return a data structure in its entirety then use the ones fromink_prelude (e.g. ink_prelude::vec::Vec). Those implement scale::Encode. "},{"title":"Exampleâ€‹","type":1,"pageTitle":"#[ink(message)]","url":"macros-attributes/message#example","content":"Given the Flipper contract definition above we add some #[ink(message)] definitions as follows: use ink_lang as ink; #[ink::contract] mod flipper { #[ink(storage)] pub struct Flipper { value: bool, } impl Flipper { #[ink(constructor)] pub fn new(initial_value: bool) -&gt; Self { Flipper { value: false } } /// Flips the current value. #[ink(message)] pub fn flip(&amp;mut self) { self.value = !self.value; } /// Returns the current value. #[ink(message)] pub fn get(&amp;self) -&gt; bool { self.value } } } Copy "},{"title":"#[ink(namespace = \"â€¦\")]","type":0,"sectionRef":"#","url":"macros-attributes/namespace","content":"","keywords":""},{"title":"Exampleâ€‹","type":1,"pageTitle":"#[ink(namespace = \"â€¦\")]","url":"macros-attributes/namespace#example","content":"#[ink(namespace = &quot;my_namespace&quot;)] impl MyTrait for MyStorage { #[ink(message)] fn my_message(&amp;self) {} } Copy This changes the resulting selectors of all the ink! messages and ink! constructors within the trait implementation. Thus allowing disambiguation between trait implementations with overlapping message or constructor names. "},{"title":"#[ink(impl)]","type":0,"sectionRef":"#","url":"macros-attributes/impl","content":"","keywords":""},{"title":"Exampleâ€‹","type":1,"pageTitle":"#[ink(impl)]","url":"macros-attributes/impl#example","content":"An implementation block can be defined as a trait implementation for the ink! storage struct using the #[ink(impl)] annotation â€’ even if none of its interior items have any ink! specific attributes on them: use core::convert::TryFrom; use ink_lang_ir as ir; #[ink::contract] mod my_module { #[ink(storage)] pub struct MyStorage { /* storage fields */ } #[ink(impl)] impl MyStorage { fn my_method(&amp;self) -&gt; i32 { /* method implementation */ } } impl MyStorage { #[ink(constructor)] pub fn my_constructor() -&gt; Self { /* constructor implementation */ } #[ink(message)] pub fn my_message(&amp;self) { /* message implementation */ } } } Copy "},{"title":"#[ink(payable)]","type":0,"sectionRef":"#","url":"macros-attributes/payable","content":"","keywords":""},{"title":"Exampleâ€‹","type":1,"pageTitle":"#[ink(payable)]","url":"macros-attributes/payable#example","content":"#[ink(message, payable)] pub fn pay_me(&amp;self) { let _transferred = self.env().transferred_balance(); } Copy See the examples/contract-transfer contract for a more extensive example. "},{"title":"#[ink(selector = \"â€¦\")]","type":0,"sectionRef":"#","url":"macros-attributes/selector","content":"","keywords":""},{"title":"Examplesâ€‹","type":1,"pageTitle":"#[ink(selector = \"â€¦\")]","url":"macros-attributes/selector#examples","content":"impl MyStorage { #[ink(message, selector = &quot;0xDEADBEEF&quot;)] fn my_message(&amp;self) {} } Copy â€¦ then the selector of my_message is simply 0xDEADBEEF since it overrides the composed selector. "},{"title":"Controlling the messages selectorâ€‹","type":1,"pageTitle":"#[ink(selector = \"â€¦\")]","url":"macros-attributes/selector#controlling-the-messages-selector","content":"Every ink! message and ink! constructor has a unique selector with which the message or constructor can be uniquely identified within the ink! smart contract. These selectors are mainly used to drive the contract's dispatch upon calling it. An ink! smart contract author can control the selector of an ink! message or ink! constructor using the selector flag. An example is shown below: use ink_lang as ink; #[ink::contract] mod flipper { #[ink(storage)] pub struct Flipper { value: bool, } impl Flipper { #[ink(constructor)] #[ink(selector = &quot;0xDEADBEEF&quot;)] // Works on constructors as well. pub fn new(initial_value: bool) -&gt; Self { Flipper { value: false } } /// Flips the current value. #[ink(message)] #[ink(selector = &quot;0xCAFEBABE&quot;)] // You can either specify selector out-of-line. pub fn flip(&amp;mut self) { self.value = !self.value; } /// Returns the current value. #[ink(message, selector = &quot;0xFEEDBEEF&quot;)] // or specify selector inline. pub fn get(&amp;self) -&gt; bool { self.value } } } Copy "},{"title":"#[ink(storage)]","type":0,"sectionRef":"#","url":"macros-attributes/storage","content":"","keywords":""},{"title":"Exampleâ€‹","type":1,"pageTitle":"#[ink(storage)]","url":"macros-attributes/storage#example","content":"use ink_lang as ink; #[ink::contract] mod flipper { #[ink(storage)] pub struct Flipper { value: bool, } impl Flipper { #[ink(constructor)] pub fn construct() -&gt; Self { Flipper { value: false } } #[ink(message)] pub fn message(&amp;self) {} } } Copy "},{"title":"#[ink(topic)]","type":0,"sectionRef":"#","url":"macros-attributes/topic","content":"","keywords":""},{"title":"Exampleâ€‹","type":1,"pageTitle":"#[ink(topic)]","url":"macros-attributes/topic#example","content":"#[ink(event)] pub struct Transferred { #[ink(topic)] from: Option&lt;AccountId&gt;, #[ink(topic)] to: Option&lt;AccountId&gt;, amount: Balance } Copy "},{"title":"Why Rust for Smart Contracts?","type":0,"sectionRef":"#","url":"why-rust-for-smart-contracts","content":"Why Rust for Smart Contracts? ink! chooses not to invent a new programming language, but rather adapt a subset of Rust to serve our purpose. If this doesn't already convince you, you find many more good reasons here: Rust is an ideal smart contract language: It is type safe, memory safe, and free of undefined behaviors. It generates small binaries because it doesnâ€™t include extra bloat, like a garbage collector, and advanced optimizations and tree shaking remove dead code. Through compiler flags, Rust can automatically protect against integer overflow.Rust ecosystem: You gain from all of support available to the Rust ecosystem for free. As the language develops, ink! will automatically gain access to new features and functionality, improving how you can write smart contracts in the future.Tooling: Because ink! follows Rust standards, tools like rustfmt, clippy and rust-analyzer already work out of the box. Same goes for code formatting and syntax highlighting in most modern text editors. Also Rust has an integrated test and benchmark runner,No overhead: Minimal runtime.Safe &amp; Efficient: Zero-cost &amp; safe abstractions.Productive: Cargo + crates.io Ecosystem.1st class Wasm: Rust provides the first class support for the WebAssembly.Small Size: In the space-constrained blockchain world size is important. The Rust compiler is a great help for that, since it reorders struct fields in order to make each type as small as possible. Thus Rust data structures are very compact, in many cases even more compact than in C.","keywords":""},{"title":"Why WebAssembly for Smart Contracts?","type":0,"sectionRef":"#","url":"why-webassembly-for-smart-contracts","content":"Why WebAssembly for Smart Contracts? High performance: Wasm is high performance â€” itâ€™s built to be as close to native machine code as possible while still being platform independent.Small size: It facilitates small binaries to ship over the internet to devices with potentially slow internet connection. This is a great fit for the space-constrainted blockchain world.General VM &amp; bytecode: It was developed so that code can be deployed in any browser with the same result. Contrary to the EVM it was not developed towards a very specific use case, this has the benefit of a lot of tooling being available and large companies putting a lot of resources into furthering Wasm development.Efficient JIT execution: 64 and 32-bit integer operation support that maps one-to-one with CPU instructions.Minimalistic: Formal spec that fits on a single page.Deterministic execution: Wasm is easily made deterministic by removing floating point operations, which is necessary for consensus algorithms.Open Standards &gt; Custom Solutions: Wasm is a standard for web browsers developed by W3C workgroup that includes Google, Mozilla, and others. Thereâ€™s been many years of work put into Wasm, both by compiler and standardisation teams.Many languages available: Wasm expands the family of languages available to smart contract developers to include Rust, C/C++, C#, Typescript, Haxe, and Kotlin. This means you can write smart contracts in whichever language youâ€™re familiar with, though weâ€™re partial to Rust due to its lack of runtime overhead and inherent security properties.Memory-safe, sandboxed, and platform-independent.LLVM support: Supported by the LLVM compiler infrastructure project, meaning that Wasm benefits from over a decade of LLVMâ€™s compiler optimisation.Large companies involved: Continually developed by major companies such as Google, Apple, Microsoft, Mozilla, and Facebook.","keywords":""}]