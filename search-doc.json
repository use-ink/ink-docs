[{"title":"Contract Template","type":0,"sectionRef":"#","url":"basics/contract-template","content":"Change into your working directory and run: Copy cargo contract new foobar This will create a new project folder named foobar. Copy cd foobar/ In the lib.rs file you find initial scaffolded code, which you can use as a starting point. Quickly check that it compiles and the trivial tests pass with: Copy cargo +nightly test Also check that you can build the Wasm file by running: Copy cargo +nightly contract build If everything looks good, then we are ready to start programming!","keywords":""},{"title":"Environment Functions","type":0,"sectionRef":"#","url":"basics/environment-functions","content":"ink! exposes a number of handy environment functions. In an #[ink(constructor)] use Self::env() to access those, in an #[ink(message)] use self.env(). So e.g. Self::env().caller() or self.env().caller(). Some handy functions include: caller(): Returns the address of the caller of the executed contract. An example of how to utilize this particular call is found here.account_id(): Returns the account ID of the executed contract.balance(): Returns the balance of the executed contract.block_number(): Returns the current block number.random(): Returns a random hash seed.emit_event(â€¦): Emits an event with the given event data.transfer(â€¦): Transfers value from the contract to the destination account ID.hash_bytes(â€¦): Conducts the crypto hash of the given input and stores the result in output.â€¦and many more â€’ see here for a complete list.","keywords":""},{"title":"Cross-Contract Calling","type":0,"sectionRef":"#","url":"basics/cross-contract-calling","content":"","keywords":""},{"title":"How it Works","type":1,"pageTitle":"Cross-Contract Calling","url":"basics/cross-contract-calling#how-it-works","content":"In order to deploy the delegator smart contract we first have to manually put the code of the other contract, receive its code hash from the signalled event and put their code hash into our calling smart contract. The calling contract looks like this: Copy use ink_storage::Lazy; use other_contract::OtherContract; //--snip-- #[ink(storage)] struct MyContract { /// The other contract. other_contract: Lazy<OtherContract>, } impl MyContract { /// Instantiate `MyContract with the given /// sub-contract codes and some initial value. #[ink(constructor)] pub fn new( other_contract_code_hash: Hash, ) -> Self { let other_contract = OtherContract::new(1337) .endowment(total_balance / 4) .code_hash(other_contract_code_hash) .instantiate() .expect(\"failed at instantiating the `OtherContract` contract\"); Self { other_contract } } /// Calls the other contract. #[ink(message)] pub fn call_other_contract(&self) -> i32 { self.other_contract.get_value() } } //--snip-- It's Cargo.toml contains Copy other_contract = { path = \"other_contract\", default-features = false, features = [\"ink-as-dependency\"] } The other_contract/Cargo.toml contains this: Copy [features] ink-as-dependency = [] The other_contract/lib.rs: Copy #[ink::contract] pub mod other_contract { /// Storage for the other contract. #[ink(storage)] pub struct OtherContract { value: i32, } impl OtherContract { /// Initializes the contract. #[ink(constructor)] pub fn new(value: i32) -> Self { Self { value } } /// Returns the current state. #[ink(message)] pub fn get_value(&self) -> i32 { self.value } } } "},{"title":"Events","type":0,"sectionRef":"#","url":"basics/events","content":"","keywords":""},{"title":"Event Definition","type":1,"pageTitle":"Events","url":"basics/events#event-definition","content":"This is how an event defintion looks: Copy #[ink(event)] pub struct Transferred { #[ink(topic)] from: Option<AccountId>, #[ink(topic)] to: Option<AccountId>, amount: Balance } Add the #[ink(topic)] attribute tag to each item in your event that you want to have indexed. A good rule of thumb is to ask yourself if somebody might want to search for this topic. For this reason the amount in the exemplary event above was not made indexable â€’ there will most probably be a lot of different events with differing amounts each. "},{"title":"Emitting Events in a Constructor","type":1,"pageTitle":"Events","url":"basics/events#emitting-events-in-a-constructor","content":"In a constructor events are emitted via Self::env().emit_event(). See this example: Copy #[ink(constructor)] pub fn new(initial_value: Balance) -> Self { let caller = Self::env().caller(); let mut balances = HashMap::new(); balances.insert(caller, initial_supply); Self::env().emit_event(Transferred { from: None, to: Some(caller), amount: initial_supply }); Self { total_supply: initial_supply, balances } } "},{"title":"Emitting Events from Messages","type":1,"pageTitle":"Events","url":"basics/events#emitting-events-from-messages","content":"In a message events are emitted via self.env().emit_event(): Copy #[ink(message)] pub fn transfer(&mut self, to: AccountId, amount: Balance) -> Result { let from = self.env().caller(); // implementation hidden self.env().emit_event(Transferred { from: Some(from), to: Some(to), amount }); Ok(()) } "},{"title":"Anonymous Events","type":1,"pageTitle":"Events","url":"basics/events#anonymous-events","content":"#[ink(anonymous)] Applicable to ink! events. Tells the ink! codegen to treat the ink! event as anonymous which omits the event signature as topic upon emitting. Very similar to anonymous events in Solidity. "},{"title":"Mutating Storage Values","type":0,"sectionRef":"#","url":"basics/mutating-values","content":"","keywords":""},{"title":"Mutable and Immutable Functions","type":1,"pageTitle":"Mutating Storage Values","url":"basics/mutating-values#mutable-and-immutable-functions","content":"You may have noticed that the function templates included self as the first parameter of the contract functions. It is through self that you gain access to all your contract functions and storage items. If you are simply reading from the contract storage, you only need to pass &self. But if you want to modify storage items, you will need to explicitly mark it as mutable, &mut self. Copy impl MyContract { #[ink(message)] pub fn my_getter(&self) -> u32 { self.my_number } #[ink(message)] pub fn my_setter(&mut self, new_value: u32) { self.my_number = new_value; } } "},{"title":"Lazy Storage Values","type":1,"pageTitle":"Mutating Storage Values","url":"basics/mutating-values#lazy-storage-values","content":"There is a Lazy type that can be used for ink! storage values that don't need to be loaded in some or most cases. Because they do not meet this criteria, many simple ink! examples, including those in this workshop, do not require the use Lazy values. Since there is some overhead associated with Lazy values, they should only be used where required. Copy #[ink(storage)] pub struct MyContract { // Store some number my_number: ink_storage::Lazy<u32>, } impl MyContract { #[ink(constructor)] pub fn new(init_value: i32) -> Self { Self { my_number: Default::default(), } } #[ink(message)] pub fn my_setter(&mut self, new_value: u32) { ink_storage::Lazy::<u32>::set(&mut self.my_number, new_value); } #[ink(message)] pub fn my_adder(&mut self, add_value: u32) { let my_number = &mut self.my_number; let cur = ink_storage::Lazy::<u32>::get(my_number); ink_storage::Lazy::<u32>::set(my_number, cur + add_value); } } "},{"title":"Contract Testing","type":0,"sectionRef":"#","url":"basics/off-chain-testing","content":"","keywords":""},{"title":"Unit Tests","type":1,"pageTitle":"Contract Testing","url":"basics/off-chain-testing#unit-tests","content":"Testing contracts off-chain is done by cargo test and users can simply use the standard routines of creating unit test modules within the ink! project: Copy #[cfg(test)] mod tests { use super::*; #[test] fn my_test() { ... } } Test instances of contracts can be created with something like: Copy let contract = MyContract::my_constructor(a, b); Messages can simply be called on the returned instance as if MyContract::my_constructor returns aSelf instance. See the flipper example. "},{"title":"Off-chain Testing","type":1,"pageTitle":"Contract Testing","url":"basics/off-chain-testing#off-chain-testing","content":"The #[ink::test] proc. macro enables more elaborate off-chain testing. If you annotate a test with this attribute it will be executed in a simulated environment, similar to as it would be run on-chain. You then have fine-grained control over how a contract is called; for example you can influence the block advancement, the value transferred to it, by which account it is called, which storage it is run with, etc.. See the examples/erc20 contract on how to utilize those or the documentation for details. At the moment there are some known limitations to our off-chain environment and we are working on making it behave as close to the real chain environment as possible. "},{"title":"On-chain Testing","type":1,"pageTitle":"Contract Testing","url":"basics/off-chain-testing#on-chain-testing","content":"The easiest way to do on-chain testing is torun a local substrate node, deploy your contract there and interact with it. "},{"title":"Reading Values from Storage","type":0,"sectionRef":"#","url":"basics/reading-values","content":"","keywords":""},{"title":"Contract Functions","type":1,"pageTitle":"Reading Values from Storage","url":"basics/reading-values#contract-functions","content":"As you can see in the contract template, all of your contract functions are part of your contract module. Copy impl MyContract { // Public and Private functions can go here } "},{"title":"Public and Private Functions","type":1,"pageTitle":"Reading Values from Storage","url":"basics/reading-values#public-and-private-functions","content":"In Rust, you can make as many implementations as you want. As a stylistic choice, we recommend breaking up your implementation definitions for your private and public functions: Copy impl MyContract { /// Public function #[ink(message)] pub fn my_public_function(&self) { /* --snip-- */ } /// Private function fn my_private_function(&self) { /* --snip-- */ } /* --snip-- */ } You can also choose to split things up however is most clear for your project. Note that all public functions must use the #[ink(message)] attribute. "},{"title":"Storage Value API","type":1,"pageTitle":"Reading Values from Storage","url":"basics/reading-values#storage-value-api","content":"Without going into so much detail, storage values are a part of the underlying ink! core layer. In the background, they use a more primitive cell type which holds an Option<T>. When we try to get the value from storage, we unwrap the value, which is why it panics if it is not initialized! Copy impl<T> Value<T> where T: scale::Codec, { /// Returns an immutable reference to the wrapped value. pub fn get(&self) -> &T { self.cell.get().unwrap() } /// Returns a mutable reference to the wrapped value. pub fn get_mut(&mut self) -> &mut T { self.cell.get_mut().unwrap() } /// Sets the wrapped value to the given value. pub fn set(&mut self, val: T) { self.cell.set(val); } } In that same file, you can find the other APIs exposed by storage values, however these three are the most commonly used. "},{"title":"Getting a Value","type":1,"pageTitle":"Reading Values from Storage","url":"basics/reading-values#getting-a-value","content":"We already showed you how to initialize a storage value. Getting the value is just as simple: Copy impl MyContract { #[ink(message)] pub fn my_getter(&self) -> u32 { self.number } } In Rust, if the last expression in a function does not have a semicolon, then it will be the return value. "},{"title":"Storing Values","type":0,"sectionRef":"#","url":"basics/storing-values","content":"","keywords":""},{"title":"Supported Types","type":1,"pageTitle":"Storing Values","url":"basics/storing-values#supported-types","content":"Contracts may store types that are encodable and decodable with Parity Codec which includes the most common types such as bool, u{8,16,32,64,128}, i{8,16,32,64,128}, String, tuples, and arrays. ink! provides smart contracts Substrate specific types like AccountId, Balance, and Hash as if they were primitive types. Also ink! provides storage types for more elaborate storage interactions through the storage module: Copy use ink_storage::collections::{Vec, HashMap, Stash, Bitvec}; Here is an example of how you would store an AccountId and Balance: Copy // We are importing the default ink! types use ink_lang as ink; #[ink::contract] mod MyContract { // Our struct will use those default ink! types #[ink(storage)] pub struct MyContract { // Store some AccountId my_account: AccountId, // Store some Balance my_balance: Balance, } /* --snip-- */ } You can find all the supported Substrate types in crates/storage/src/lib.rs. "},{"title":"Initializing Storage in Constructors","type":1,"pageTitle":"Storing Values","url":"basics/storing-values#initializing-storage-in-constructors","content":"Constructors are how values get initialized. Every ink! smart contract must have a constructor which is run once when a contract is created. ink! smart contracts can have multiple constructors: Copy use ink_lang as ink; #[ink::contract] mod mycontract { #[ink(storage)] pub struct MyContract { number: u32, } impl MyContract { /// Constructor that initializes the `u32` value to the given `init_value`. #[ink(constructor)] pub fn new(init_value: u32) -> Self { Self { number: init_value, } } /// Constructor that initializes the `u32` value to the `u32` default. /// /// Constructors can delegate to other constructors. #[ink(constructor)] pub fn default() -> Self { Self { number: Default::default(), } } /* --snip-- */ } } "},{"title":"Trait Definitions","type":0,"sectionRef":"#","url":"basics/trait-definitions","content":"","keywords":""},{"title":"Example","type":1,"pageTitle":"Trait Definitions","url":"basics/trait-definitions#example","content":"Defined in the base_erc20.rs module. Copy use ink_lang as ink; #[ink::trait_definition] pub trait BaseErc20 { /// Creates a new ERC-20 contract and initializes it with the initial supply for the instantiator. #[ink(constructor)] fn new(initial_supply: Balance) -> Self; /// Returns the total supply. #[ink(message)] fn total_supply(&self) -> Balance; /// Transfers `amount` from caller to `to`. #[ink(message, payable)] fn transfer(&mut self, to: AccountId, amount: Balance); } An ink! smart contract definition can then implement this trait definition as follows: Copy use ink_lang as ink; #[ink::contract] mod erc20 { use base_erc20::BaseErc20; #[ink(storage)] pub struct Erc20 { total_supply: Balance, // more fields ... } impl BaseErc20 for Erc20 { #[ink(constructor)] fn new(initial_supply: Balance) -> Self { // implementation ... } #[ink(message)] fn total_supply(&self) -> Balance { // implementation ... } #[ink(message, payable)] fn transfer(&mut self, to: AccountId, amount: Balance) { // implementation ... } } } Calling the above Erc20 explicitely through its trait implementation can be done just as if it was normal Rust code: Copy // --- Instantiating the ERC-20 contract: // let mut erc20 = <Erc20 as BaseErc20>::new(1000); // --- Is just the same as: use base_erc20::BaseErc20; let mut erc20 = Erc20::new(1000); // --- Retrieving the total supply: // assert_eq!(<Erc20 as BaseErc20>::total_supply(&erc20), 1000); // --- Is just the same as: use base_erc20::BaseErc20; assert_eq!(erc20.total_supply(), 1000); There are still many limitations to ink! trait definitions and trait implementations. For example it is not possible to define associated constants or types or have default implemented methods. These limitations exist because of technical intricacies, however, please expect that many of those will be tackled in future ink! releases. "},{"title":"Overview","type":0,"sectionRef":"#","url":"cargo-contract-cli","content":"","keywords":""},{"title":"What it is","type":1,"pageTitle":"Overview","url":"cargo-contract-cli#what-it-is","content":"cargo-contract is a CLI tool which helps you set up and manage WebAssembly smart contracts written with ink!. You can find it here on GitHuband here on crates.io. The tool has a number of handy capabilities: TODO update Copy cargo-contract 0.7.0 Utilities to develop Wasm smart contracts USAGE: cargo contract <SUBCOMMAND> OPTIONS: -h, --help Prints help information -V, --version Prints version information SUBCOMMANDS: new Setup and create a new smart contract project build Compiles the smart contract generate-metadata Generate contract metadata artifacts test Test the smart contract off-chain deploy Upload the smart contract code to the chain instantiate Instantiate a deployed smart contract call Arguments required for creating and sending an extrinsic to a substrate node "},{"title":"Usage","type":1,"pageTitle":"Overview","url":"cargo-contract-cli#usage","content":"You can install it this way: Copy cargo install cargo-contract --force Use the --force to ensure you are updated to the most recent cargo-contract version. In order to initialize a new ink! project you can use: Copy cargo contract new flipper This will create a folder flipper in your work directory. The folder contains a scaffold Cargo.toml and a lib.rs, which both contain the necessary building blocks for using ink!. The lib.rs contains our hello world contract â€’ the Flipper, which we explain in the next section. In order to build the contract just execute these commmands in the flipper folder: Copy cargo contract build As a result you'll get the file target/flipper.contract. It's a JSON which bundles the contract's metadata and its Wasm blob. This file needs to be used when deploying the contract. You additionally get the individual target/flipper.wasm and target/metadata.json in the folder as well. "},{"title":"Overview","type":0,"sectionRef":"#","url":"canvas","content":"","keywords":""},{"title":"What is the Canvas Test Network?","type":1,"pageTitle":"Overview","url":"canvas#what-is-the-canvas-test-network","content":"We have a demonstration testnet running. You can request some tokens to play with from our Faucet and deploy your contracts via the Canvas UI. The Canvas UI can also be used to deploy your contract to e.g. a Substrate chain which you run locally and execute calls there. If you want a quickstart you can use our canvas-node project â€’ a simple Substrate blockchain which is configured to include the contracts pallet (see How it Works for more). "},{"title":"Overview","type":0,"sectionRef":"#","url":"datastructures/custom","content":"","keywords":""},{"title":"Lazy","type":1,"pageTitle":"Overview","url":"datastructures/custom#lazy","content":"Data structures provided by the ink_storage crate are inherently lazy. We will explain what this means below! The ink_storage crate provides high-level and low-level lazy data structures. The difference between high-level and low-level lies in the distinction in how these data structures are aware of the elements that they operate on. For high-level data structures they are fully aware about the elements they contain, do all the clean-up by themselves so the user can concentrate on the business logic. For low-level data structures the responsibility about the elements lies in the hands of the contract author. Also they operate on cells (Option<T>) instead of entities of type T. But what does that mean exactly? TODO what are high-level and what are low-level data structures The ink_storage::Lazy type caches their entities and acts lazily on the storage. This means that a read or write operation is only performed when it really needs to in order to satisfy other inputs. Data types such as Rust primitives i32 or Rust's very own Vec or data structures can also be used to operate on the contract's storage, however, they will load their contents eagerly which is often not what you want. An example follows with the below contract storage and a message that operates on either of the two fields. Copy #[ink(storage)] pub struct TwoValues { offset: i32, a: i32, b: i32, } impl TwoValues { #[ink(message)] pub fn set(&mut self, which: bool, new_value: i32) { match which { true => { self.a = self.offset + new_value; }, false => { self.b = self.offset + new_value; }, } } } Whenever we call TwoValues::set always both a and b are loaded despite the fact the we only operate on one of them at a time. This is very costly since storage accesses are in fact database look-ups. In order to prevent this eager loading of storage contents we can make use of ink_storage::Lazy or other lazy data structures defined in that crate: Copy #[ink(storage)] pub struct TwoValues { offset: i32, a: ink_storage::Lazy<i32>, b: ink_storage::Lazy<i32>, } impl TwoValues { #[ink(message)] pub fn set(&mut self, which: bool, new_value: i32) { match which { true => { self.a = offset + new_value; }, false => { self.b = offset + new_value; }, } } } Now a and b are only loaded when the contract really needs their values. Note that offset remained i32 since it is always needed and could spare the minor overhead of the ink_storage::Lazy wrapper. "},{"title":"Your Custom Datastructure","type":0,"sectionRef":"#","url":"datastructures/custom-datastructure","content":"","keywords":""},{"title":"Custom Data Sturctures","type":1,"pageTitle":"Your Custom Datastructure","url":"datastructures/custom-datastructure#custom-data-sturctures","content":"While the ink_storage crate provides tons of useful utilities and data structures to organize and manipulate the contract's storage contract authors are not limited by its capabilities. By implementing the core SpreadLayout and PackedLayout traits users are able to define their very own custom storage data structures with their own set of requirement and features that work along the ink_storage data structures as long as they fulfill the mere requirements stated by those two traits. In the future we plan on providing some more ink! workshops and tutorials guiding the approach to design and implement a custom storage data structure. "},{"title":"Dynamic Allocation","type":0,"sectionRef":"#","url":"datastructures/dynamic-allocation","content":"","keywords":""},{"title":"Dynamic Storage Allocator","type":1,"pageTitle":"Dynamic Allocation","url":"datastructures/dynamic-allocation#dynamic-storage-allocator","content":"In the previous section we have seen how the default mode of operation is to spread information and how we can opt-in to packing information into single cells via ink_storage::Packed. However, what if we wanted to store a vector of a vector of i32 for example? Naturally a user would try to construct this as follows: Copy use ink_storage::Vec as StorageVec; #[ink(storage)] pub struct Matrix { values: StorageVec<StorageVec<i32>>, } However, this will fail compilation with an error indicating that StorageVec<T> requires for its T to be packed (T: PackedLayout) which StorageVec<T> itself does not since it always stores all of its elements into different cells. The same applies to many other storage data sturctures provided by ink_storage and is a trade-off the ink! team decided for the case of efficiency of the overall system. Instead what a user can do in order to get their vector-of-vector to be working is to make use of ink!'s dynamic storage allocator capabilities. For this the contract author has to first enable the feature via: Copy use ink_lang as ink; #[ink::contract(dynamic_storage_allocator = true)] mod matrix { // contract code ... } And then we can define our Matrix #[ink(storage)] as follows: Copy use ink_storage::{ Vec as StorageVec, Box as StorageBox, }; #[ink(storage)] pub struct Matrix { values: StorageVec<StorageBox<StorageVec<i32>>>, } With ink_storage::Box<T> we can use a T: SpreadLayout as if it was T: PackedLayout since the ink_storage::Box<T> itself suffices the requirements and can be put into a single contract storage cell. The whole concept works quite similar to how Rust's Box works: by an indirection - contract authors are therefore advised to make use of dynamic storage allocator capabilities only if other ways of dealing with ones problems are not applicable. "},{"title":"Lazy vs. Eager","type":0,"sectionRef":"#","url":"datastructures/lazy-eager","content":"","keywords":""},{"title":"In Summary","type":1,"pageTitle":"Lazy vs. Eager","url":"datastructures/lazy-eager#in-summary","content":"TODO The new ink_storage crate provides everything you need to operate on your contract's storage. There are low-level and high-level data structures depending on your need of control. All provided data structures operate lazily on the contract's storage and cache their reads and writes for a more gas efficient storage access. Users should prefer high-level data structures found in the collections module over the low-level data structures found in the lazy module. For a list of all the new storage data structure visit ink_storage's documentation. "},{"title":"Opting out of Storage","type":0,"sectionRef":"#","url":"datastructures/opting-out","content":"","keywords":""},{"title":"Opting-out of Storage","type":1,"pageTitle":"Opting out of Storage","url":"datastructures/opting-out#opting-out-of-storage","content":"If you are in need of storing some temporary information across method and message boundaries ink! will have your back with the ink_storage::Memory abstraction. It allows you to simply opt-out of using the storage for the wrapped entity at all and thus is very similar to Solidity's very own memory annotation. An example below: Copy #[ink(storage)] pub struct OptedOut { a: i32, b: ink_storage::Lazy<i32>, c: ink_storage::Memory<i32>, } The the above example a and b are normal storage entities, however, c on the other hand side will never load from or store to contract storage and will always be reset to the default value of its i32 type for every contract call. It can be accesses from all ink! messages or methods via self.c but will never manipulate the contract storage and thus acts wonderfully as some shared local information. "},{"title":"HashMap","type":0,"sectionRef":"#","url":"datastructures/hashmap","content":"","keywords":""},{"title":"Storage HashMap","type":1,"pageTitle":"HashMap","url":"datastructures/hashmap#storage-hashmap","content":"In addition to storing individual values, ink! also supports a HashMap which allows you to store items in a key-value mapping. Here is an example of a mapping from user to a number: Copy #[ink(storage)] pub struct MyContract { // Store a mapping from AccountIds to a u32 my_number_map: ink_storage::collections::HashMap<AccountId, u32>, } This means that for a given key, you can store a unique instance of a value type. In this case, each \"user\" gets their own number, and we can build logic so that only they can modify their own number. "},{"title":"Storage HashMap API","type":1,"pageTitle":"HashMap","url":"datastructures/hashmap#storage-hashmap-api","content":"You can find the full HashMap API in the crate documentation part of ink!. Here are some of the most common functions you might use: Copy /// Inserts a key-value pair into the map. /// /// Returns the previous value associated with the same key if any. /// If the map did not have this key present, `None` is returned. pub fn insert(&mut self, key: K, new_value: V) -> Option<V> {/* --snip-- */} /// Removes the key/value pair from the map associated with the given key. /// /// - Returns the removed value if any. pub fn take<Q>(&mut self, key: &Q) -> Option<V> {/* --snip-- */} /// Returns a shared reference to the value corresponding to the key. /// /// The key may be any borrowed form of the map's key type, /// but `Hash` and `Eq` on the borrowed form must match those for the key type. pub fn get<Q>(&self, key: &Q) -> Option<&V> {/* --snip-- */} /// Returns a mutable reference to the value corresponding to the key. /// /// The key may be any borrowed form of the map's key type, /// but `Hash` and `Eq` on the borrowed form must match those for the key type. pub fn get_mut<Q>(&mut self, key: &Q) -> Option<&mut V> {/* --snip-- */} /// Returns `true` if there is an entry corresponding to the key in the map. pub fn contains_key<Q>(&self, key: &Q) -> bool {/* --snip-- */} /// Converts the OccupiedEntry into a mutable reference to the value in the entry /// with a lifetime bound to the map itself. pub fn into_mut(self) -> &'a mut V {/* --snip-- */} /// Gets the given key's corresponding entry in the map for in-place manipulation. pub fn entry(&mut self, key: K) -> Entry<K, V> {/* --snip-- */} "},{"title":"Initializing a HashMap","type":1,"pageTitle":"HashMap","url":"datastructures/hashmap#initializing-a-hashmap","content":"Not initializing storage before you use it is a common error that can break your smart contract. For each key in a storage value, the value needs to be set before you can use it. To do this, we will create a private function which handles when the value is set and when it is not, and make sure we never work with uninitialized storage. So given my_number_map, imagine we wanted the default value for any given key to be 0. We can build a function like this: Copy #![cfg_attr(not(feature = \"std\"), no_std)] use ink_lang as ink; #[ink::contract] mod mycontract { #[ink(storage)] pub struct MyContract { // Store a mapping from AccountIds to a u32 my_number_map: ink_storage::collections::HashMap<AccountId, u32>, } impl MyContract { /// Public function. /// Default constructor. #[ink(constructor)] pub fn default() -> Self { Self { my_number_map: Default::default(), } } /// Private function. /// Returns the number for an AccountId or 0 if it is not set. fn my_number_or_zero(&self, of: &AccountId) -> u32 { let balance = self.my_number_map.get(of).unwrap_or(&0); *balance } } } Here we see that after we get the value from my_number_map we call unwrap_or which will either unwrap the value stored in storage, or if there is no value, return some known value. Then, when building functions that interact with this HashMap, you need to always remember to call this function rather than getting the value directly from storage. Here is an example: Copy #![cfg_attr(not(feature = \"std\"), no_std)] use ink_lang as ink; #[ink::contract] mod mycontract { #[ink(storage)] pub struct MyContract { // Store a mapping from AccountIds to a u32 my_number_map: ink_storage::collections::HashMap<AccountId, u32>, } impl MyContract { // Get the value for a given AccountId #[ink(message)] pub fn get(&self, of: AccountId) -> u32 { self.my_number_or_zero(&of) } // Get the value for the calling AccountId #[ink(message)] pub fn get_my_number(&self) -> u32 { let caller = self.env().caller(); self.my_number_or_zero(&caller) } // Returns the number for an AccountId or 0 if it is not set. fn my_number_or_zero(&self, of: &AccountId) -> u32 { let value = self.my_number_map.get(of).unwrap_or(&0); *value } } } "},{"title":"Contract Caller","type":1,"pageTitle":"HashMap","url":"datastructures/hashmap#contract-caller","content":"As you might have noticed in the example above, we use a special function called self.env().caller(). This function is available throughout the contract logic and will always return to you the contract caller. NOTE: The contract caller is not the same as the origin caller. If a user triggers a contract which then calls a subsequent contract, the self.env().caller() in the second contract will be the address of the first contract, not the original user. self.env().caller() can be used a number of different ways. In the examples above, we are basically creating an \"access control\" layer which allows a user to modify their own value, but no one else. You can also do things like define a contract owner during contract deployment: Copy #![cfg_attr(not(feature = \"std\"), no_std)] use ink_lang as ink; #[ink::contract] mod mycontract { #[ink(storage)] pub struct MyContract { // Store a contract owner owner: AccountId, } impl MyContract { #[ink(constructor)] pub fn new(init_value: i32) -> Self { Self { owner: Self::env().caller(); } } /* --snip-- */ } } Then you can write permissioned functions which checks that the current caller is the owner of the contract. Incrementing My Value# The final step in our Incrementer contract is to allow each user to update increment their own value. "},{"title":"Modifying a HashMap","type":1,"pageTitle":"HashMap","url":"datastructures/hashmap#modifying-a-hashmap","content":"Making changes to the value of a HashMap is just as sensitive as getting the value. If you try to modify some value before it has been initialized, your contract will panic! But have no fear, we can continue to use the my_number_or_zero function we created to protect us from these situations! Copy impl MyContract { /* --snip-- */ // Set the value for the calling AccountId #[ink(message)] pub fn set_my_number(&mut self, value: u32) { let caller = self.env().caller(); self.my_number_map.insert(caller, value); } // Add a value to the existing value for the calling AccountId #[ink(message)] pub fn add_my_number(&mut self, value: u32) { let caller = self.env().caller(); let my_number = self.my_number_or_zero(&caller); self.my_number_map.insert(caller, my_number + value); } /// Returns the number for an AccountId or 0 if it is not set. fn my_number_or_zero(&self, of: &AccountId) -> u32 { *self.my_number_map.get(of).unwrap_or(&0) } } Here we have written two kinds of functions which modify a HashMap. One which simply inserts the value directly into storage, with no need to read the value first, and the other which modifies the existing value. Note how we can always insert the value without worry, as that initialized the value in storage, but before you can get or modify anything, we need to call my_number_or_zero to make sure we are working with a real value. "},{"title":"Feel the Pain (Optional)","type":1,"pageTitle":"HashMap","url":"datastructures/hashmap#feel-the-pain-optional","content":"We will not always have an existing value on our contract's storage. We can take advantage of the Rust Option<T> type to help use on this task. If there's no value on the contract storage we will insert a new one; on the contrary if there is an existing value we will only update it. ink! HashMaps expose the well-known entry API that we can use to achieve this type of \"upsert\" behavior: Copy let caller = self.env().caller(); self.my_number_map .entry(caller) .and_modify(|old_value| old_value += by) .or_insert(by); "},{"title":"Spread & Packed","type":0,"sectionRef":"#","url":"datastructures/spread-packed-layout","content":"","keywords":""},{"title":"Spread & Packed Modes","type":1,"pageTitle":"Spread & Packed","url":"datastructures/spread-packed-layout#spread--packed-modes","content":"Storing or loading complex data structures to and from contract storage can be done in many different ways. You could store all information into a single storage cell or you could try to store all information into as many different cells as possible. Both strategies have pros and cons under different conditions. For example it might be a very good idea to store all the information under the same cell if all the information is very compact. For example when we are dealing with a byte vector that is expected to never be larger than approx a thousand elements it would probably be more efficient if we store all those thousand bytes in the same cell and especially if we often access many of those (or all) in our contract messages. On the other hand spreading information across as many cells as possible might be much more efficient if we are dealing with big data structures, a lot of information that is not compact, or when messages that operate on the data always only need a small fraction of the whole data. An example for this use case is if you have a vector of user accounts where each account stores potentially a lot of information, e.g. a 32-byte hash etc and where our messages only every operate on only a few of those at a time. The ink_storage crate provides the user full control over the strategy or a mix of these two root strategies through some fundamental abstractions that we are briefly presenting to you. "},{"title":"Default: Spreading Mode","type":1,"pageTitle":"Spread & Packed","url":"datastructures/spread-packed-layout#default-spreading-mode","content":"By default ink! spreads information to as many cells as possible. For example if you have the following #[ink(storage)] struct every field will live in its own single storage cell. Note that for c all 32 bytes will share the same cell! Copy #[ink(storage)] pub struct Spreaded { a: i32, b: ink_storage::Lazy<i32>, c: [u8; 32], } "},{"title":"Packing Storage","type":1,"pageTitle":"Spread & Packed","url":"datastructures/spread-packed-layout#packing-storage","content":"We can alter this behaviour by using the ink_storage::Pack abstraction: Copy pub struct Spreaded { a: i32, b: ink_storage::Lazy<i32>, c: [u8; 32], } #[ink(storage)] pub struct Packed { packed: ink_storage::Pack<Spreaded>, } Now all fields of Spreaded will share the same storage cell. This means whenever one of them is stored to or loaded from the contract storage, all of them are stored or loaded. A user has to choose wisely what mode of operation is more suitable for their contract. These abstractions can be combined in various ways, yielding full control to the users. For example, in the following only a and b share a common storage cell while c lives in its own: Copy pub struct Spreaded { a: i32, b: ink_storage::Lazy<i32>, } #[ink(storage)] pub struct Packed { packed: ink_storage::Pack<Spreaded>, c: [u8; 32], } "},{"title":"Spreading Array Cells","type":1,"pageTitle":"Spread & Packed","url":"datastructures/spread-packed-layout#spreading-array-cells","content":"If we prefer to store all bytes of c into their own storage cell we can make use of the SmallVec data structure. The SmallVec is a high-level data structure that allows to efficiently organize a fixed number of elements similar to a Rust array. However, unlike a Rust array it acts lazily upon the storage and spreads its elements into different cells. Copy use typenum::U32; pub struct Spreaded { a: i32, b: ink_storage::Lazy<i32>, } #[ink(storage)] pub struct Packed { packed: ink_storage::Pack<Spreaded>, c: SmallVec<u8, U32>, } "},{"title":"Overview","type":0,"sectionRef":"#","url":"examples","content":"In our examples folder you find a number of examples written in ink!. Some of the most interesting ones: delegator â€’ Implements cross-contract calling.trait-erc20 â€’ Defines a trait for Erc20 contracts and implements it.erc721 â€’ An exemplary implementation of Erc721 NFT tokens.dns â€’ A simple DomainNameService smart contract.â€¦and more, just rummage through the folder ðŸ™ƒ. To build a single example navigate to the root of the example and run: Copy cargo contract build As a result you'll get a file target/flipper.wasm file, a metadata.json file and a <contract-name>.contract file in the target folder of your contract. The .contract file combines the Wasm and metadata into one file and needs to be used when deploying the contract. For further information, please have a look at the Play with It section or our smart contracts workshop.","keywords":""},{"title":"Frequently Asked Questions","type":0,"sectionRef":"#","url":"faq","content":"","keywords":""},{"title":"Is it \"ink\" or \"ink!\"? What does the \"!\" stand for?","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#is-it-ink-or-ink-what-does-the--stand-for","content":"TODO "},{"title":"Who is \"Squink\"?","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#who-is-squink","content":"This is Squink todo todo "},{"title":"What's the relationship of Substrate/Polkadot?","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#whats-the-relationship-of-substratepolkadot","content":"TODO "},{"title":"How to do cross-contract calling?","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#how-to-do-cross-contract-calling","content":"See the Cross-contract calling section. "},{"title":"What is a contract's ABI or Metadata?","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#what-is-a-contracts-abi-or-metadata","content":"TODO "},{"title":"Can a re-entrancy bug occur in ink! contracts?","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#can-a-re-entrancy-bug-occur-in-ink-contracts","content":"TODO "},{"title":"What are chain-extensions?","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#what-are-chain-extensions","content":"TODO "},{"title":"How can I use ink! with a Substrate chain with a custom chain config?","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#how-can-i-use-ink-with-a-substrate-chain-with-a-custom-chain-config","content":"TODO "},{"title":"What does the #![cfg_attr(not(feature = \"std\"), no_std)] at the beginning of each contract mean?","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#what-does-the-cfg_attrnotfeature--std-no_std-at-the-beginning-of-each-contract-mean","content":"TODO "},{"title":"Overflow Safety?","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#overflow-safety","content":"Being written in Rust, ink! can provide compile-time overflow/underflow safety. Using a Rust compiler configuration, you can specify whether you want to support overflowing math, or if you want contract execution to panic when overflows occur. No need to continually import \"Safe Math\" libraries, although Rust also provides integrated checked, wrapped, and saturated math functions. Note: There are some known issues regarding functionality of compiler level overflow checks and the resulting size of the Wasm blob. This feature may change or be iterated on in the future. "},{"title":"What is the difference between memory and storage?","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#what-is-the-difference-between-memory-and-storage","content":"In ink!, memory refers to computer memory, while storage refers to the on-chain storage used by a contract instance. Memory is temporary and only lasts until the contract execution is done, while storage is persistent and lasts over many contract executions. The contract storage is built on top of the runtime storage, and access is considered to be slow. "},{"title":"Compile Your Contract","type":0,"sectionRef":"#","url":"getting-started/building-your-contract","content":"Run the following command to compile your smart contract: Copy cargo +nightly contract build This special command will turn your ink! project into a Wasm binary and a metadata file (a.k.a. the contract ABI). These two files can be used for deploying your contract to your chain. If all goes well, you should see a target folder which contains this .wasm and metadata.json file. Copy target â””â”€â”€ flipper.wasm â””â”€â”€ metadata.json Let's take a look at the structure of the metadata.json: Copy { \"registry\": { \"strings\": [...], \"types\": [...] }, \"storage\": {...}, \"contract\": { \"name\": ..., \"constructors\": [...], \"messages\": [...], \"events\": [], \"docs\": [] } } You can see that this file describes all the interfaces that can be used to interact with your contract. Registry provides the strings and custom types used throughout the rest of the JSON.Storage defines all the storage items managed by your contract and how to ultimately access them.Contract stores information about the callable functions like constructors and messages a user can call to interact with your contract. It also has helpful information like the events that are emitted by the contract or any docs. If you look close at the constructors and messages, you will also notice a selector which is a 4-byte hash of the function name and is used to route your contract calls to the correct functions. The Canvas UI uses this file to generate a friendly interface for deploying and interacting with your contract. :) In the next section we will start a Canvas node and configure the Canvas UI to interact with it.","keywords":""},{"title":"Call Your Contract","type":0,"sectionRef":"#","url":"getting-started/calling-your-contract","content":"","keywords":""},{"title":"get()","type":1,"pageTitle":"Call Your Contract","url":"getting-started/calling-your-contract#get","content":"If you take a look back at our contract's default() function, we set the initial value of the Flipper contract to false. Let's check that this is the case. In the Message to Send section, select the \"get(): bool\" message and accept the default values for the other options. Press \"Call\" and confirm that it returns the value false:  NOTE: You might be wondering: \"Why did we need to specify gas when reading a value from a contract?\" If you notice right above the \"Call\" button is a select box that allows you to \"Send call as RPC call\" or \"Send as transaction\". For a read-only request like this, we can simply use an RPC call which will simulate a transaction, but not actually store anything on-chain. Thus, you will still need to specify the right amount of gas to cover your \"virtual fee\", but don't worry, nothing will be charged when making a call this way. :) "},{"title":"flip()","type":1,"pageTitle":"Call Your Contract","url":"getting-started/calling-your-contract#flip","content":"So let's make the value turn true now! The alternative message to send we can make with the UI is flip(). Again, accept the default values for the other options. You will notice that the flip() message defaults to a transaction call.  If the transaction was successful, we should then be able to go back to the get() function and see our updated storage:  Woohoo! You deployed your first smart contract! "},{"title":"Moving Forward","type":1,"pageTitle":"Call Your Contract","url":"getting-started/calling-your-contract#moving-forward","content":"If you are looking for a guided tutorial on how to build a more complex smart contract you might want to check out our ERC-20 tutorial. "},{"title":"Creating an ink! Project","type":0,"sectionRef":"#","url":"getting-started/creating-an-ink-project","content":"","keywords":""},{"title":"Contract Source Code","type":1,"pageTitle":"Creating an ink! Project","url":"getting-started/creating-an-ink-project#contract-source-code","content":"The ink CLI automatically generates the source code for the \"Flipper\" contract, which is about the simplest \"smart\" contract you can build. You can take a sneak peak as to what will come by looking at the source code here: Flipper Example Source Code The Flipper contract is nothing more than a bool which gets flipped from true to false through the flip() function. "},{"title":"Testing Your Contract","type":1,"pageTitle":"Creating an ink! Project","url":"getting-started/creating-an-ink-project#testing-your-contract","content":"You will see at the bottom of the source code there is a simple test which verifies the functionality of the contract. We can quickly test that this code is functioning as expected using the off-chain test environment that ink! provides. In your project folder run: Copy cargo +nightly test To which you should see a successful test completion: Copy $ cargo +nightly test running 2 tests test flipper::tests::it_works ... ok test flipper::tests::default_works ... ok test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out Now that we are feeling confident things are working, we can actually compile this contract to Wasm in the next step. "},{"title":"Deploy Your Contract","type":0,"sectionRef":"#","url":"getting-started/deploy-your-contract","content":"","keywords":""},{"title":"Putting Your Code on the Blockchain","type":1,"pageTitle":"Deploy Your Contract","url":"getting-started/deploy-your-contract#putting-your-code-on-the-blockchain","content":"Open the specially designed Upload section of the Canvas UI. Use the dropdown to select a deployment account with some account balance, like Alice. Enter a name for the contract in the input field. Provide the flipper.wasm and metadata.json files as the Wasm blob and optional ABI, respectively.  Click Upload and then Sign & Submit on the confirmation page. This should emit a contracts.PutCode event. If the transaction succeeds you will get an system.ExtrinsicSuccess event and your WASM contract will be stored on your Substrate blockchain!  "},{"title":"Creating an Instance of Your Contract","type":1,"pageTitle":"Deploy Your Contract","url":"getting-started/deploy-your-contract#creating-an-instance-of-your-contract","content":"Smart contracts exist as an extension of the account system on the blockchain. Thus creating an instance of this contract will create a new AccountId which will store any balance managed by the smart contract and allow us to interact with the contract. After you uploaded the contract in the previous step, a confirmation screen displays the information that represents our smart contract. We now need to deploy our smart contract to create an instance. Press the \"Deploy Code\" button on the confirmation screen. To instantiate our contract, accept the default options to give this contract account an endowment of 1000 Units in order to pay the storage rent and set a maximum gas allowed value of 1000000:  Note: As mentioned earlier, contract creation involves creation of a new Account. As such, you must be sure to give the contract account at least the existential deposit defined by your blockchain. We also need to be able to pay the contract's rent (endowment). If we consume all of this deposit, the contract will become invalid. We can always refill the contract's balance and keep it on chain. When you press Deploy, you should see a flurry of events appear including the creation of a new account (system.NewAccount) and the instantiation of the contract (contracts.instantiate):  "},{"title":"Setup","type":0,"sectionRef":"#","url":"getting-started/setup","content":"","keywords":""},{"title":"Rust & Cargo","type":1,"pageTitle":"Setup","url":"getting-started/setup#rust--cargo","content":"A prerequisite for compiling smart contracts is to have Rust and Cargo installed. Here's an installation guide. "},{"title":"ink! CLI","type":1,"pageTitle":"Setup","url":"getting-started/setup#ink-cli","content":"The first tool we will be installing is cargo-contract, a CLI tool for helping setting up and managing WebAssembly smart contracts written with ink!. You can install the utility using Cargo with: Copy cargo install cargo-contract --vers 0.7.1 --force --locked Use the --force to ensure you are updated to the most recent cargo-contract version. You can then use cargo contract --help to start exploring the commands made available to you. "},{"title":"Substrate Framework Prerequisites","type":1,"pageTitle":"Setup","url":"getting-started/setup#substrate-framework-prerequisites","content":"With ink! you can write smart contracts for blockchains built on Substrate. Follow theofficial installation steps from the Substrate Developer Hub Knowledge Base to set up all Substrate prerequisites. Copy rustup component add rust-src --toolchain nightly rustup target add wasm32-unknown-unknown --toolchain stable "},{"title":"Installing The Canvas Node","type":1,"pageTitle":"Setup","url":"getting-started/setup#installing-the-canvas-node","content":"The canvas-node is a simple Substrate blockchain which is configured to include the Substrate module for smart contract functionality â€’ the contracts pallet (see How it Works for more). It's a comfortable option if you want to get a quickstart. Copy cargo install canvas-node --git https://github.com/paritytech/canvas-node.git --tag v0.1.3 --force --locked "},{"title":"Run a Substrate Node","type":0,"sectionRef":"#","url":"getting-started/running-substrate","content":"The canvas-node is a simple Substrate blockchain which is configured to include the contracts module. It's a comfortable option if you want to get a quickstart. After successfully installing canvas, you can start a local development chain by running: Copy canvas --dev --tmp You should start to see blocks being produced by your node in your terminal. You can interact with your node using the Canvas UI: https://paritytech.github.io/canvas-ui The UI will connect to the locally running node by default.","keywords":""},{"title":"How it works â€’ Substrate","type":0,"sectionRef":"#","url":"how-it-works","content":" Substrate's Framework for Runtime Aggregation of Modularised Entities (FRAME) contains a module which implements an API for typical functions smart contracts need (storage, querying information about accounts, â€¦). This module is called the contracts pallet, The contracts pallet requires smart contracts to be uploaded to the blockchain as a Wasm blob. ink! is a smart contract language which targets the API exposed by contracts. Hence ink! contracts are compiled to Wasm. When executing cargo contract build an additional file metadata.json is created. It contains information about e.g. what methods the contract provides for others to call.","keywords":""},{"title":"Troubleshooting","type":0,"sectionRef":"#","url":"getting-started/troubleshooting","content":"","keywords":""},{"title":"Unexpected Epoch Change","type":1,"pageTitle":"Troubleshooting","url":"getting-started/troubleshooting#unexpected-epoch-change","content":"There is a known issue with the Substrate block production (BABE) on a running chain. If you stop your node for too long (closing the terminal, putting your computer to sleep, etc...), you will get the following error: Copy ClientImport(\"Unexpected epoch change\") To solve this you will need to restart your node with: canvas --dev --tmp. At that point, you will need to re-deploy any contracts and re-do any steps that you may have done before on your node. As long as you keep your node running, you should face no issues. "},{"title":"Old Contracts in Local Storage","type":1,"pageTitle":"Troubleshooting","url":"getting-started/troubleshooting#old-contracts-in-local-storage","content":"The Polkadot UI uses its own local storage to track the contracts that you have deployed. This means that if you deploy a contract using the UI, and then purge your Canvas node, you will still see the old contracts in the UI even though they do not exist on-chain! You can simply remove any old artifacts from the UI or reset your local storage. So remember, when you start a new chain with the --tmp flag or use the purge-chain subcommand, you will need to re-deploy any contracts and re-do any steps that you may have done before on your node. "},{"title":"Transaction vs RPC","type":1,"pageTitle":"Troubleshooting","url":"getting-started/troubleshooting#transaction-vs-rpc","content":"When interacting with contracts using the Canvas UI, you have the option to submit your calls as a transaction or via the RPC:  When you send as a transaction, it should be exactly as you expect. A transaction is submitted to contract, a fee is deducted from your account, and the state of your blockchain can change. In these situations, no value is returned from your contract calls, only a \"Success\" or \"Failed\" extrinsic message along with any events you emit. However, there may be some calls that you want to \"test\", rather than actually submit a transaction. Or you may want to peek at the value that would be returned if you called the contract function. For these scenarios, you can submit an RPC call, which will run all of your contract logic, but not actually submit a transaction or update the state of your chain. However, you will still need to specify the right amount of gas to cover your \"virtual fee\", but don't worry, nothing will be charged when making a call this way. :) "},{"title":"Contract State Rent","type":1,"pageTitle":"Troubleshooting","url":"getting-started/troubleshooting#contract-state-rent","content":"The Substrate contracts pallet has a state rent system that forces contracts to stay funded if they want to stay on the blockchain. This means that the more you use a contract, the more fees are taken from it, and at some point, the contract will run out of fees and turn into a non-functioning tombstone. We try to avoid this by giving the contract a large endowment when we initially deploy it. However, if your contract does become a tombstone, for the purposes of this tutorial, the best solution is to just redeploy your contract to the chain. The best way to prevent this in general is to make sure your contract stays well funded. In real world scenarios, there is a process that you can go through to recover a tombstone contract and get it functioning again, however this is beyond the scope of this tutorial. "},{"title":"Other Issues","type":1,"pageTitle":"Troubleshooting","url":"getting-started/troubleshooting#other-issues","content":"If you run into any other issues during this tutorial, please report an issue! "},{"title":"Overview","type":0,"sectionRef":"#","url":"ink-macros-attributes","content":"","keywords":""},{"title":"ink! Macros & Attributes","type":1,"pageTitle":"Overview","url":"ink-macros-attributes#ink-macros--attributes","content":"All of these ink! attributes are available to specify inside an ink! module. An ink! module is the module that is flagged by #[ink::contract] containing all the ink! definitions: Copy use ink_lang as ink; #[ink::contract] mod erc20 { #[ink(storage)] pub struct Erc20 { ... } impl Erc20 { #[ink(constructor)] pub fn new(initial_supply: Balance) -> Self { .. } #[ink(constructor)] pub fn total_supply(&self) -> Balance { .. } // etc. ... } } We won't be going into the details for any of those but will briefly present the entire set of ink! specific attributes below: See here for a more detailed description of those and also for details on the #[ink::contract] macro. "},{"title":"Merging of ink! Attributes","type":1,"pageTitle":"Overview","url":"ink-macros-attributes#merging-of-ink-attributes","content":"It is possible to merge attributes that share a common flagged entity. The example below demonstrates this for a payable message with a custom selector. Copy #[ink(message)] #[ink(payable)] #[ink(selector = \"0xCAFEBABE\")] pub fn transfer(&mut self, from: AccountId, to: AccountId, value: Balance) -> Result<(), Error> { // actual implementation } We can also write the above ink! message definition in the following way: Copy #[ink(message, payable, selector = \"0xCAFEBABE\")] pub fn transfer(&mut self, from: AccountId, to: AccountId, value: Balance) -> Result<(), Error> { // actual implementation } "},{"title":"#[ink(anonymous)]","type":0,"sectionRef":"#","url":"ink-macros-attributes/anonymous","content":"Applicable to ink! events. Tells the ink! codegen to treat the ink! event as anonymous which omits the event signature as topic upon emitting. Very similar to anonymous events in Solidity.","keywords":""},{"title":"#[ink(constructor)]","type":0,"sectionRef":"#","url":"ink-macros-attributes/constructor","content":"Applicable to method. Flags a method for the ink! storage struct as constructor making it available to the API for instantiating the contract.","keywords":""},{"title":"#[ink(event)]","type":0,"sectionRef":"#","url":"ink-macros-attributes/event","content":"Applicable on struct definitions. Defines an ink! event. A contract can define multiple such ink! events.","keywords":""},{"title":"#[ink(implementation)]","type":0,"sectionRef":"#","url":"ink-macros-attributes/implementation","content":"Applicable to ink! implementation blocks. Tells the ink! codegen that some implementation block shall be granted access to ink! internals even without it containing any ink! messages or ink! constructors.","keywords":""},{"title":"#[ink(message)]","type":0,"sectionRef":"#","url":"ink-macros-attributes/message","content":"Applicable to methods. Flags a method for the ink! storage struct as message making it available to the API for calling the contract.","keywords":""},{"title":"#[ink(namespace = \"â€¦\")]","type":0,"sectionRef":"#","url":"ink-macros-attributes/namespace","content":"Applicable to ink! trait implementation blocks. Changes the resulting selectors of all the ink! messages and ink! constructors within the trait implementation. Allows to disambiguate between trait implementations with overlapping message or constructor names. Use only with great care and consideration!","keywords":""},{"title":"#[ink(selector = \"â€¦\")]","type":0,"sectionRef":"#","url":"ink-macros-attributes/selector","content":"Applicable to ink! messages and ink! constructors. Specifies a concrete dispatch selector for the flagged entity. This allows a contract author to precisely control the selectors of their APIs making it possible to rename their API without breakage.","keywords":""},{"title":"#[ink(payable)]","type":0,"sectionRef":"#","url":"ink-macros-attributes/payable","content":"Applicable to ink! messages. Allows receiving value as part of the call of the ink! message. ink! constructors are implicitly payable.","keywords":""},{"title":"#[ink(storage)]","type":0,"sectionRef":"#","url":"ink-macros-attributes/storage","content":"","keywords":""},{"title":"[ink(storage)]","type":1,"pageTitle":"#[ink(storage)]","url":"ink-macros-attributes/storage#inkstorage","content":"Applicable on struct definitions. Defines the ink! storage struct. There can only be one ink! storage definition per contract. "},{"title":"#[ink(topic)]","type":0,"sectionRef":"#","url":"ink-macros-attributes/topic","content":"Applicate on ink! event field. Tells the ink! codegen to provide a topic hash for the given field. Every ink! event can only have a limited number of such topic field. Similar semantics as to indexed event arguments in Solidity.","keywords":""},{"title":"Why Rust for Smart Contracts?","type":0,"sectionRef":"#","url":"why-rust-for-smart-contracts","content":"No overhead: Minimal runtime Safe & Efficient: Zero-cost & safe abstractions Productive: Cargo + crates.io Ecosystem 1st class Wasm support Rust has an integrated test and benchmark runner, a linter, a code formatter and syntax highlighting in most modern text editors. Rust data structures are very compact - in many cases even more compact than in C, since the compiler reorders struct fields to make each type as small as possible. Size is important in the space-constrained world of blockchains. Because ink! follows Rust standards, tools like rustfmt and rust-analyzer already work out of the box.","keywords":""},{"title":"ink! vs. Solidity","type":0,"sectionRef":"#","url":"ink-vs-solidity","content":"Rust is an ideal smart contract language. It is type safe, memory safe, and free of undefined behaviors. It generates small binaries because it doesnâ€™t include extra bloat, like a garbage collector, and advanced optimizations and tree shaking remove dead code. Through compiler flags, Rust can automatically protect against integer overflow. ink! chooses not to invent a new programming language, but rather adapt a subset of Rust to serve this purpose. As a result, you gain from all of the tooling and support available to the Rust ecosystem for free. In addition, as the language develops, ink! will automatically gain access to new features and functionality, improving how you can write smart contracts in the future. Here is a brief comparison of features between ink! and Solidity: ink!\tSolidityVirtual Machine\tAny Wasm VM\tEVM Encoding\tWasm\tEVM Byte Code Language\tRust\tStandalone Overflow Protection\tEnabled by default\tNone Constructor Functions\tMultiple\tSingle Tooling\tAnything that supports Rust\tCustom Versioning\tSemantic\tSemantic Has Metadata?\tYes\tYes Multi-File Project\tPlanned\tYes Storage Entries\tVariable\t256 bits Supported Types\tDocs\tDocs Has Interfaces?\tYes (Rust Traits)\tYes","keywords":""},{"title":"Why WebAssembly for Smart Contracts?","type":0,"sectionRef":"#","url":"why-webassembly-for-smart-contracts","content":"General VM & bytecode Efficient JIT execution Formal spec that fits on a single page Deterministic execution Open Standards > Custom Solutions","keywords":""}]